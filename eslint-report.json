[{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/rule-test/non_violation.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/rule-test/violation.js","messages":[{"ruleId":"indent","severity":2,"message":"Expected indentation of 2 spaces but found 4.","line":5,"column":1,"nodeType":"Keyword","messageId":"wrongIndentation","endLine":5,"endColumn":5,"fix":{"range":[67,71],"text":"  "}},{"ruleId":"sonarjs/no-duplicate-string","severity":2,"message":"Define a constant instead of duplicating this literal 6 times.","line":35,"column":13,"nodeType":"Literal","endLine":35,"endColumn":39},{"ruleId":"max-len","severity":2,"message":"This line has a length of 457. Maximum allowed is 200.","line":46,"column":1,"nodeType":"Program","messageId":"max","endLine":46,"endColumn":458},{"ruleId":"no-plusplus","severity":2,"message":"Unary operator '++' used.","line":62,"column":3,"nodeType":"UpdateExpression","messageId":"unexpectedUnaryOp","endLine":62,"endColumn":8},{"ruleId":"eol-last","severity":2,"message":"Newline required at end of file but not found.","line":65,"column":27,"nodeType":"Program","messageId":"missing","fix":{"range":[1765,1765],"text":"\n"}}],"errorCount":5,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"/* eslint-env browser */\n/* eslint-env es6 */\n\nfunction indent() {\n    return 'Bad';\n}\nconsole.log(indent());\n\nfunction cognitivecomplexity() {\n  const ans = 20;\n  if (ans > 1) {\n    console.log(ans);\n    if (ans > 2) {\n      console.log(ans);\n      if (ans > 3) {\n        console.log(ans);\n        if (ans > 4) {\n          console.log(ans);\n          if (ans > 5) {\n            console.log(ans);\n            if (ans > 5) {\n              console.log(ans);\n            }\n          }\n        }\n      }\n    }\n  }\n  return ans;\n}\nconsole.log(cognitivecomplexity());\n\nfunction noduplicatestring() {\n  const lang = ['Java', 'PHP', 'Javascript', 'HTML', 'C', 'React'];\n  const a = 'I love to write programs' + lang[0];\n  const b = 'I love to write programs' + lang[1];\n  const c = 'I love to write programs' + lang[2];\n  const d = 'I love to write programs' + lang[3];\n  const e = 'I love to write programs' + lang[4];\n  const f = 'I love to write programs' + lang[5];\n  return [a, b, c, d, e, f];\n}\nconsole.log(noduplicatestring());\n\nfunction maxlen() {\n  return 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.';\n}\nconsole.log(maxlen());\n\nfunction nomultipleemptylines() {\n  console.log('line 1');\n\n\n  console.log('line 2');\n\n  return 'Bad';\n}\nconsole.log(nomultipleemptylines());\n\nfunction noplusplus() {\n  let ans = 1;\n  ans++;\n  return ans;\n}\nconsole.log(noplusplus());","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/config.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/errors/ForbiddenError.js","messages":[{"ruleId":"func-names","severity":1,"message":"Unexpected unnamed function.","line":3,"column":24,"nodeType":"FunctionExpression","messageId":"unnamed","endLine":3,"endColumn":33}],"errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\n\nconst ForbiddenError = function (message, error) {\n  Error.call(this, message);\n  Error.captureStackTrace(this, this.constructor);\n  this.name = 'ForbiddenError';\n  this.message = message;\n  this.status = 403;\n  if (error) this.inner = error;\n};\n\nForbiddenError.prototype = Object.create(Error.prototype);\nForbiddenError.prototype.constructor = ForbiddenError;\n\nmodule.exports = ForbiddenError;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/errors/InternalError.js","messages":[{"ruleId":"func-names","severity":1,"message":"Unexpected unnamed function.","line":3,"column":23,"nodeType":"FunctionExpression","messageId":"unnamed","endLine":3,"endColumn":32}],"errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\n\nconst InternalError = function (message, error) {\n  Error.call(this, message);\n  Error.captureStackTrace(this, this.constructor);\n  this.name = 'InternalError';\n  this.message = message;\n  this.status = 500;\n  if (error) this.inner = error;\n};\n\nInternalError.prototype = Object.create(Error.prototype);\nInternalError.prototype.constructor = InternalError;\n\nmodule.exports = InternalError;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/errors/NotFoundError.js","messages":[{"ruleId":"func-names","severity":1,"message":"Unexpected unnamed function.","line":3,"column":23,"nodeType":"FunctionExpression","messageId":"unnamed","endLine":3,"endColumn":32}],"errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\n\nconst NotFoundError = function (message, error) {\n  Error.call(this, message);\n  Error.captureStackTrace(this, this.constructor);\n  this.name = 'NotFoundError';\n  this.message = message;\n  this.status = 404;\n  if (error) this.inner = error;\n};\n\nNotFoundError.prototype = Object.create(Error.prototype);\nNotFoundError.prototype.constructor = NotFoundError;\n\nmodule.exports = NotFoundError;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/errors/NotImplementedError.js","messages":[{"ruleId":"func-names","severity":1,"message":"Unexpected unnamed function.","line":3,"column":29,"nodeType":"FunctionExpression","messageId":"unnamed","endLine":3,"endColumn":38}],"errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\n\nconst NotImplementedError = function (message, error) {\n  Error.call(this, message);\n  Error.captureStackTrace(this, this.constructor);\n  this.name = 'NotImplementedError';\n  this.message = message;\n  this.status = 501;\n  if (error) this.inner = error;\n};\n\nNotImplementedError.prototype = Object.create(Error.prototype);\nNotImplementedError.prototype.constructor = NotImplementedError;\n\nmodule.exports = NotImplementedError;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/errors/UnauthorizedError.js","messages":[{"ruleId":"func-names","severity":1,"message":"Unexpected unnamed function.","line":3,"column":27,"nodeType":"FunctionExpression","messageId":"unnamed","endLine":3,"endColumn":36}],"errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\n\nconst UnauthorizedError = function (message, error) {\n  Error.call(this, message);\n  Error.captureStackTrace(this, this.constructor);\n  this.name = 'UnauthorizedError';\n  this.message = message;\n  this.status = 401;\n  if (error) this.inner = error;\n};\n\nUnauthorizedError.prototype = Object.create(Error.prototype);\nUnauthorizedError.prototype.constructor = UnauthorizedError;\n\nmodule.exports = UnauthorizedError;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/errors/ValidationError.js","messages":[{"ruleId":"func-names","severity":1,"message":"Unexpected unnamed function.","line":3,"column":25,"nodeType":"FunctionExpression","messageId":"unnamed","endLine":3,"endColumn":34}],"errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\n\nconst ValidationError = function (message, error) {\n  Error.call(this, message);\n  Error.captureStackTrace(this, this.constructor);\n  this.name = 'ValidationError';\n  this.message = message;\n  this.status = 409;\n  if (error) this.inner = error;\n};\n\nValidationError.prototype = Object.create(Error.prototype);\nValidationError.prototype.constructor = ValidationError;\n\nmodule.exports = ValidationError;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/errors/index.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/index.js","messages":[{"ruleId":"no-lonely-if","severity":2,"message":"Unexpected if as the only statement in an else block.","line":268,"column":7,"nodeType":"IfStatement","messageId":"unexpectedLonelyIf","endLine":295,"endColumn":8}],"errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/*\n * Living Meta-Analysis server.\n *\n * Author: Jacek Kopecky jacek.kopecky@port.ac.uk\n */\n\n'use strict';\n\nconsole.log('LiMA server starting at ' + new Date());\nconst express = require('express');\nconst googleOpenID = require('simple-google-openid');\nconst cors = require('cors');\nconst http = require('http');\nconst https = require('https');\nconst fs = require('fs');\nconst cookieParser = require('cookie-parser');\n\nconst config = require('./config');\n\nconst apiRoutes = require('./routes');\nconst redirectApi = require('./routes/redirected-api');\nconst storage = require('./storage');\nconst NotFoundError = require('./errors/NotFoundError');\n\nconst api = process.env.REDIRECT_API ? redirectApi : apiRoutes;\nconst ROOT_PAGE = './webpages/';\nconst CONSOLE_BORDER = '**************************************************';\n\nstorage.setup();\n\nconst app = express({ caseSensitive: true });\napp.set('case sensitive routing', true);\napp.set('strict routing', true);\n\napp.use(googleOpenID(process.env.GOOGLE_CLIENT_ID || config.googleClientID));\napp.use(cookieParser());\n\n/* closed beta\n *\n *\n *    ####  #       ####   ####  ###### #####     #####  ###### #####   ##\n *   #    # #      #    # #      #      #    #    #    # #        #    #  #\n *   #      #      #    #  ####  #####  #    #    #####  #####    #   #    #\n *   #      #      #    #      # #      #    #    #    # #        #   ######\n *   #    # #      #    # #    # #      #    #    #    # #        #   #    #\n *    ####  ######  ####   ####  ###### #####     #####  ######   #   #    #\n *\n *\n */\n\n// in closed beta, restrict access to HTML pages:\n// if we don't get a valid closed-beta code in the lima-beta-code cookie,\n// we will redirect to a coming-soon page\n\nif (!process.env.TESTING) {\n  // regex for quickly checking for selected paths to be allowed: /css, /js, /img, /api, /version\n  const closedBetaAllowedURLs = /^\\/(css|js|img|api|version|\\.well-known)\\//;\n\n  app.use('/', async (req, res, next) => {\n    if (req.url.match(closedBetaAllowedURLs)) {\n      next();\n    } else if (await isValidBetaCode(req.cookies['lima-beta-code'])) {\n      next();\n    } else if (req.url === '/') {\n      res.sendFile('coming-soon.html', { root: ROOT_PAGE });\n    } else {\n      res.redirect('/');\n    }\n  });\n}\n\nasync function isValidBetaCode(betaCodeCookies) {\n  if (betaCodeCookies) {\n    const codeKey = storage.shared.datastore.key(['BetaCode', betaCodeCookies]);\n    const codes = await storage.shared.datastore.get(codeKey);\n    if (codes[0]) return true;\n    return false;\n  } else {\n    return false;\n  }\n}\n\n/* routes\n *\n *\n *        #####   ####  #    # ##### ######  ####\n *        #    # #    # #    #   #   #      #\n *        #    # #    # #    #   #   #####   ####\n *        #####  #    # #    #   #   #           #\n *        #   #  #    # #    #   #   #      #    #\n *        #    #  ####   ####    #   ######  ####\n *\n *\n */\n\nif (config.demoApiDelay) {\n  // this is a delay for demonstration purposes so the server seems slow\n  app.use((req, res, next) => setTimeout(next, config.demoApiDelay));\n}\n\n// allow local testing of pages\napp.use(cors({ origin: 'http://localhost:8080' }));\n\napp.use('/api', api.router);\n\napp.get('/version', oneLineVersion);\napp.get('/version/', oneLineVersion);\napp.get('/version/log',\n  (req, res) => res.redirect('https://github.com/jacekkopecky/living-meta-analysis/commits/master'));\n\napp.get(['/profile', '/profile/*'],\n  (req, res) => res.sendFile('profileRedirect.html', { root: ROOT_PAGE }));\n\napp.use('/', express.static('webpages', { extensions: ['html'] }));\n\n// the routes below would catch any of the above so need to come last\n\napp.use(`/:user(${config.USER_RE})/`, SLASH_URL);\napp.get(`/:user(${config.USER_RE})/`,\n  api.users.EXISTS_USER,\n  (req, res) => res.sendFile('profile/profile.html', { root: ROOT_PAGE }));\n\napp.use(`/:user(${config.USER_RE})/:title(${config.URL_TITLE_RE})/`, SLASH_URL);\napp.get(`/:user(${config.USER_RE})/${config.NEW_PAPER_TITLE}/`,\n  api.users.EXISTS_USER,\n  (req, res) => res.sendFile('profile/paper.html', { root: ROOT_PAGE }));\napp.get(`/:user(${config.USER_RE})/${config.NEW_META_TITLE}/`,\n  api.users.EXISTS_USER,\n  (req, res) => res.sendFile('react-dist/metaanalysis.html', { root: ROOT_PAGE }));\napp.get(`/:user(${config.USER_RE})/:title(${config.URL_TITLE_RE})/`,\n  api.users.EXISTS_USER,\n  async (req, res, next) => {\n    try {\n      const kind = req.query.type || await api.getKindForTitle(req.params.user, req.params.title);\n      if (kind === 'paper') {\n        res.sendFile('profile/paper.html', { root: ROOT_PAGE });\n      } else if (kind === 'metaanalysis') {\n        res.sendFile('react-dist/metaanalysis.html', { root: ROOT_PAGE });\n      } else {\n        next(new NotFoundError());\n      }\n    } catch (error) {\n      next(new NotFoundError());\n    }\n  });\n\nfunction SLASH_URL(req, res, next) {\n  let end = req.originalUrl.indexOf('?');\n  let query = '';\n  if (end === -1) {\n    end = req.originalUrl.length;\n  } else {\n    query = req.originalUrl.substring(end);\n  }\n  if (req.originalUrl[end - 1] === '/') {\n    next();\n  } else {\n    res.redirect(req.originalUrl.substring(0, end) + '/' + query);\n  }\n}\n\n\n/* version\n *\n *\n *         #    # ###### #####   ####  #  ####  #    #\n *         #    # #      #    # #      # #    # ##   #\n *         #    # #####  #    #  ####  # #    # # #  #\n *         #    # #      #####       # # #    # #  # #\n *          #  #  #      #   #  #    # # #    # #   ##\n *           ##   ###### #    #  ####  #  ####  #    #\n *\n *\n */\n\nfunction oneLineVersion(req, res) {\n  res.sendFile('version.txt', { root: '.' });\n}\n\n/* error handling\n *\n *\n *  ###### #####  #####   ####  #####     #    #   ##   #    # #####  #      # #    #  ####\n *  #      #    # #    # #    # #    #    #    #  #  #  ##   # #    # #      # ##   # #    #\n *  #####  #    # #    # #    # #    #    ###### #    # # #  # #    # #      # # #  # #\n *  #      #####  #####  #    # #####     #    # ###### #  # # #    # #      # #  # # #  ###\n *  #      #   #  #   #  #    # #   #     #    # #    # #   ## #    # #      # #   ## #    #\n *  ###### #    # #    #  ####  #    #    #    # #    # #    # #####  ###### # #    #  ####\n *\n *\n */\n\napp.use(() => { throw new NotFoundError(); });\n\n// eslint-disable-next-line no-unused-vars\napp.use((err, req, res, next) => {\n  // eslint-disable-line no-unused-vars\n  if (err.status === 404) {\n    res.status(404).sendFile('404.html', { root: ROOT_PAGE });\n  } else if (err.status === 401) {\n    res.set('WWW-Authenticate', 'Bearer realm=\"accounts.google.com\"');\n    res.status(401).sendFile('401.html', { root: ROOT_PAGE });\n  } else if (err && err.status) {\n    res.status(err.status).send(err.message);\n  } else {\n    console.error('internal error');\n    console.error(err);\n    if (err && err.stack) console.error(err.stack);\n    res.status(500).send('internal server error');\n  }\n});\n\nprocess.on('unhandledRejection', (err) => {\n  console.error('unhandled promise, logging the error (if any)');\n  if (err) {\n    console.error(err.stack || err);\n  }\n});\n\n/* start server\n *\n *\n *    ####  #####   ##   #####  #####     ####  ###### #####  #    # ###### #####\n *   #        #    #  #  #    #   #      #      #      #    # #    # #      #    #\n *    ####    #   #    # #    #   #       ####  #####  #    # #    # #####  #    #\n *        #   #   ###### #####    #           # #      #####  #    # #      #####\n *   #    #   #   #    # #   #    #      #    # #      #   #   #  #  #      #   #\n *    ####    #   #    # #    #   #       ####  ###### #    #   ##   ###### #    #\n *\n *\n */\n\nconst port = process.env.PORT || config.port;\nlet httpsPort = process.env.PORT || config.httpsPort;\n\nconst serverReady = startServer();\n\nfunction startServer() {\n  return new Promise((resolve, reject) => {\n    if (process.env.TESTING) {\n      console.info(CONSOLE_BORDER);\n      console.info('');\n      console.info('RUNNING IN TESTING MODE');\n      console.info('');\n      console.info(CONSOLE_BORDER);\n    }\n\n    if (process.env.DISABLE_HTTPS || process.env.TESTING) {\n      if (!process.env.TESTING) {\n        console.warn(CONSOLE_BORDER);\n        console.warn('');\n        console.warn('WARNING: DISABLING HTTPS, THIS SERVER IS INSECURE');\n        console.warn('');\n        console.warn(CONSOLE_BORDER);\n      }\n      httpsPort = null;\n    }\n\n    if (!httpsPort) {\n      // only HTTP\n      http.createServer(app)\n        .listen(port, () => {\n          console.log(`LiMA server listening on insecure port ${port}`);\n          resolve();\n        });\n    } else {\n      // HTTPS; with HTTP redirecting to that\n      if (process.env.GAE_APPLICATION) {\n        http.createServer(app)\n          .listen(port, () => {\n            console.log(`LiMA server running on App Engine, Port: ${port}`);\n            resolve();\n          });\n      } else {\n        try {\n          const credentials = {};\n          credentials.key = fs.readFileSync(config.httpsKey, 'utf8');\n          credentials.cert = fs.readFileSync(config.httpsCert, 'utf8');\n          https.createServer(credentials, app).listen(httpsPort, () => {\n            console.log(`LiMA server listening on HTTPS port ${httpsPort}`);\n\n            // HTTP app will just redirect to HTTPS\n            const redirectApp = express();\n            redirectApp.get('*', (req, res) => res.redirect('https://' + req.hostname + req.url));\n\n            http.createServer(redirectApp).listen(port, () => {\n              console.log(`LiMA redirect server listening on port ${port}`);\n              resolve();\n            });\n          });\n        } catch (error) {\n          console.log(error);\n          reject(error);\n        }\n      }\n    }\n  });\n}\n\nmodule.exports = { serverReady };\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/lib/tools.js","messages":[{"ruleId":"no-restricted-globals","severity":2,"message":"Unexpected use of 'isNaN'.","line":40,"column":77,"nodeType":"Identifier","messageId":"defaultMessage","endLine":40,"endColumn":82}],"errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\n\nlet lastTime = 0;\n/*\n * Return a unique-enough timestamp.\n * We ensure uniqueness in these ways:\n * 1) at first, return the current Date.now()\n * 2) if Date.now() returns the same value as the last timestamp we created, return that value + 1;\n * 3) if the above has happened, Date.now() can actually return a lower value than the last time,\n *    in which case we simply return the next greater number;\n * 4) the above only works while the app is running, so if many timestamps are needed quickly,\n *    the timestamps get into the future, then if the app restarts quickly enough, it can start\n *    generating non-unique times, but generating timestamps is unlikely to happen a lot in a\n *    short time, and a quick restart followed by further generating of timestamps is very unlikely.\n */\nmodule.exports.uniqueNow = function uniqueNow() {\n  let currTime = Date.now();\n  if (lastTime >= currTime) {\n    currTime = lastTime + 1;\n  }\n  lastTime = currTime;\n  return currTime;\n};\n\nmodule.exports.string = function string(val) {\n  if (val === undefined || val === null) return val;\n\n  if (typeof val === 'object' || typeof val === 'function') {\n    console.error(`not a string: ${val}`);\n    console.error(new Error());\n    return undefined;\n  }\n\n  return '' + val;\n};\n\nmodule.exports.number = function number(val) {\n  if (val === undefined || val === null) return val;\n\n  if (val === '' || typeof val === 'object' || typeof val === 'function' || isNaN(val)) {\n    console.error(`not a number: ${val}`);\n    console.error(new Error());\n    return undefined;\n  }\n\n  return +val;\n};\n\nmodule.exports.bool = function bool(val) {\n  if (val === undefined || val === null) return val;\n\n  if (typeof val === 'object' || typeof val === 'function') {\n    console.error(`not a boolean: ${val}`);\n    console.error(new Error());\n    return undefined;\n  }\n\n  return !!val;\n};\n\nmodule.exports.array = function array(val, f) {\n  if (val === undefined || val === null) return val;\n\n  if (Array.isArray(val)) {\n    return val.map(f).filter(defined);\n  }\n\n  console.error(`not an array: ${val}`);\n  console.error(new Error());\n  return undefined;\n};\n\nmodule.exports.assoc = function assoc(val, f) {\n  if (val === undefined || val === null) return val;\n\n  if (typeof val === 'object') {\n    const retval = {};\n    for (const k of Object.keys(val)) {\n      retval[k] = f(val[k]);\n    }\n    return retval;\n  }\n\n  console.error(`not an object: ${val}`);\n  console.error(new Error());\n  return undefined;\n};\n\nfunction defined(x) { return x !== undefined; }\n\nmodule.exports.deleteCHECKvalues = function deleteCHECKvalues(obj) {\n  if (obj !== null && (typeof obj === 'object' || typeof obj === 'function')) {\n    for (const key of Object.keys(obj)) {\n      if (key.startsWith('CHECK')) delete obj[key];\n      else deleteCHECKvalues(obj[key]);\n    }\n  }\n};\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/routes/fake-auth.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/routes/index.js","messages":[{"ruleId":"import/order","severity":2,"message":"`simple-google-openid` import should occur before import of `../config`","line":7,"column":19,"nodeType":"CallExpression","endLine":7,"endColumn":50}],"errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\n\nconst express = require('express');\nconst config = require('../config');\n\n// guard middleware enforcing that a user is logged in\nlet GOOGLE_USER = require('simple-google-openid').guardMiddleware({ realm: 'accounts.google.com' });\nconst fakeAuthMiddleware = require('./fake-auth');\n\nconst api = express.Router({ caseSensitive: true });\nconst jsonBodyParser = express.json(config.jsonParserOptions);\n\nconst metaanalyses = require('./metaanalyses');\nconst papers = require('./papers');\nconst users = require('./users');\n\nconst storage = require('../storage');\n\nif (process.env.TESTING) {\n  // Fake middleware while in testing mode to allow all requests\n  GOOGLE_USER = (req, res, next) => next();\n  /*\n  * allows fake bearer tokens for authentication\n  * something like:\n  *\n  * Authorization: Fake jack\n  *\n  * this will be interpreted as user jack@fake.example.org\n  *\n  */\n  api.use(fakeAuthMiddleware);\n}\n\n/* -------------------------------------------------------------------------- */\n/*                                   Routes                                   */\n/* -------------------------------------------------------------------------- */\n\n// todo top users/papers/metaanalyses would currently return all of them, which is a privacy issue\n// we may need editorial control, tags like 'public' or absence of tags like 'private'\n// api.get('/topusers', listTopUsers);\n// api.get('/toppapers', listTopPapers);\n\napi.get('/', (req, res) => res.redirect('/docs/api'));\n\n/* ---------------------------------- Users --------------------------------- */\n\napi.get('/user', GOOGLE_USER, users.checkUser);\napi.post('/user', GOOGLE_USER, jsonBodyParser, users.saveUser);\n\napi.get(`/profile/:user(${config.USER_RE})`, users.returnUserProfile);\n\n/* --------------------------------- Papers --------------------------------- */\n\n// todo include /titles to return all titles\napi.get('/titles', listTitles);\napi.get(`/papers/:user(${config.USER_RE})/`, papers.listPapersForUser);\n\napi.get(`/papers/:user(${config.USER_RE})/:title(${config.URL_TITLE_RE})/`, papers.getPaperVersion);\napi.get(`/papers/:user(${config.USER_RE})/:title(${config.URL_TITLE_RE})/:time([0-9]+)/`, papers.getPaperVersion);\napi.post(`/papers/:user(${config.USER_RE})/:title(${config.URL_TITLE_RE})/`, GOOGLE_USER, users.SAME_USER, jsonBodyParser, papers.savePaper);\n// todo above, a user that isn't SAME_USER should be able to submit new comments\n\n/* ------------------------------ Metaanalyses ------------------------------ */\n\napi.get('/topmetaanalyses', metaanalyses.listTopMetaanalyses);\napi.get(`/metaanalyses/:user(${config.USER_RE})`, metaanalyses.listMetaanalysesForUser);\napi.get(`/metaanalyses/:user(${config.USER_RE})/:title(${config.URL_TITLE_RE})/`, metaanalyses.getMetaanalysisVersion);\napi.get(`/metaanalyses/:user(${config.USER_RE})/:title(${config.URL_TITLE_RE})/:time([0-9]+)/`, metaanalyses.getMetaanalysisVersion);\napi.post(`/metaanalyses/:user(${config.USER_RE})/:title(${config.URL_TITLE_RE})/`, GOOGLE_USER, users.SAME_USER, jsonBodyParser, metaanalyses.saveMetaanalysis);\n\n/* -------------------------------------------------------------------------- */\n/*                                   Shared                                   */\n/* -------------------------------------------------------------------------- */\n\n// TODO: Test/Review function\nasync function getKindForTitle(user, title) {\n  const metaanalyses = await storage.metaanalyses.getMetaanalysisByTitle(\n    user,\n    title,\n  );\n\n  if (metaanalyses) return 'metaanalysis';\n  const paper = await storage.papers.getPaperByTitle(user, title);\n  if (paper) return 'paper';\n  throw new Error('Nothing found');\n}\n\n// todo: implement using a query\nfunction listTitles(req, res) {\n  res.send([]);\n}\n\nmodule.exports = {\n  router: api,\n  metaanalyses,\n  papers,\n  users,\n  getKindForTitle,\n};\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/routes/metaanalyses.js","messages":[{"ruleId":"object-curly-newline","severity":2,"message":"Expected a line break after this opening brace.","line":1,"column":7,"nodeType":"ObjectPattern","messageId":"expectedLinebreakAfterOpeningBrace","endLine":1,"endColumn":8,"fix":{"range":[7,7],"text":"\n"}},{"ruleId":"object-curly-newline","severity":2,"message":"Expected a line break before this closing brace.","line":1,"column":76,"nodeType":"ObjectPattern","messageId":"expectedLinebreakBeforeClosingBrace","endLine":1,"endColumn":77,"fix":{"range":[75,75],"text":"\n"}},{"ruleId":"implicit-arrow-linebreak","severity":2,"message":"Expected no linebreak before this expression.","line":102,"column":7,"nodeType":"Identifier","messageId":"unexpected","endLine":102,"endColumn":13,"fix":{"range":[3734,3741],"text":" "}},{"ruleId":"function-paren-newline","severity":2,"message":"Unexpected newline before ')'.","line":103,"column":5,"nodeType":"Punctuator","messageId":"unexpectedBefore","endLine":103,"endColumn":6,"fix":{"range":[3799,3804],"text":""}}],"errorCount":4,"warningCount":0,"fixableErrorCount":4,"fixableWarningCount":0,"source":"const { NotFoundError, ValidationError, NotImplementedError, InternalError } = require('../errors');\nconst storage = require('../storage');\nconst config = require('../config');\nconst tools = require('../lib/tools');\nconst { extractPaperForSending, extractReceivedComment, extractReceivedColumnEntry } = require('./papers');\n\n/* -------------------------------------------------------------------------- */\n/*                               Route Handlers                               */\n/* -------------------------------------------------------------------------- */\n\nasync function listMetaanalysesForUser(req, res, next) {\n  try {\n    const mas = await storage.metaanalyses.getMetaanalysesEnteredBy(req.params.user);\n    if (mas.length === 0) throw new Error('no metaanalyses found');\n\n    const retval = [];\n    mas.forEach((m) => {\n      retval.push(extractMetaanalysisForSending(m, false, req.params.user));\n    });\n    res.json(retval);\n  } catch (error) {\n    next(new NotFoundError());\n  }\n}\n\nasync function getMetaanalysisVersion(req, res, next) {\n  try {\n    const ma = await storage.metaanalyses.getMetaanalysisByTitle(req.params.user, req.params.title, req.params.time, true);\n    const username = await storage.users.getUsernameOfUser(ma.enteredBy);\n    res.json(extractMetaanalysisForSending(ma, true, req.params.user, username));\n  } catch (e) {\n    next(e && e.status ? e : new NotFoundError());\n  }\n}\n\nasync function saveMetaanalysis(req, res, next) {\n  // extract from incoming data stuff that is allowed\n  try {\n    const ma = await storage.metaanalyses.saveMetaanalysis(extractReceivedMetaanalysis(req.body), req.user.emails[0].value, req.params.title);\n    res.json(extractMetaanalysisForSending(ma, false, req.params.user));\n  } catch (e) {\n    console.log(e);\n    if (e instanceof ValidationError || e instanceof NotImplementedError) {\n      next(e);\n    } else {\n      next(new InternalError(e));\n    }\n  }\n}\n\nasync function listTopMetaanalyses(req, res, next) {\n  try {\n    const mas = await storage.metaanalyses.listMetaanalyses();\n\n    const retval = [];\n    for (const ma of mas) {\n      retval.push({\n        title: ma.title,\n        enteredBy: ma.enteredBy,\n      });\n    }\n    res.json(retval);\n  } catch (error) {\n    console.log(error);\n\n    next(new InternalError());\n  }\n}\n\n/* -------------------------------------------------------------------------- */\n/*                                   Helpers                                  */\n/* -------------------------------------------------------------------------- */\n\nfunction extractMetaanalysisForSending(storageMetaanalysis, includePapers, user, username) {\n  const retval = {\n    id: storageMetaanalysis.id,\n    title: storageMetaanalysis.title,\n    enteredBy: storageMetaanalysis.enteredBy,\n    enteredByUsername: username,\n    ctime: storageMetaanalysis.ctime,\n    mtime: storageMetaanalysis.mtime,\n    published: storageMetaanalysis.published,\n    description: storageMetaanalysis.description,\n    tags: storageMetaanalysis.tags,\n    columns: storageMetaanalysis.columns,\n    paperOrder: storageMetaanalysis.paperOrder,\n    hiddenCols: storageMetaanalysis.hiddenCols,\n    hiddenExperiments: storageMetaanalysis.hiddenExperiments,\n    excludedExperiments: storageMetaanalysis.excludedExperiments,\n    aggregates: storageMetaanalysis.aggregates,\n    groupingColumn: storageMetaanalysis.groupingColumn,\n    groupingAggregates: storageMetaanalysis.groupingAggregates,\n    graphs: storageMetaanalysis.graphs,\n    // todo comments in various places?\n  };\n\n  if (user) retval.apiurl = apiMetaanalysisURL(user, retval.title);\n\n  if (includePapers && storageMetaanalysis.papers) {\n    retval.papers = [];\n    storageMetaanalysis.papers.forEach((p) =>\n      retval.papers.push(extractPaperForSending(p, true, user)),\n    );\n  }\n\n  return retval;\n}\n\nfunction extractReceivedMetaanalysis(receivedMetaanalysis) {\n  // expecting receivedMetaanalysis to come from JSON.parse()\n  const retval = {\n    id: tools.string(receivedMetaanalysis.id), // identifies the MA to be changed\n    title: tools.string(receivedMetaanalysis.title),\n    CHECKenteredBy: tools.string(receivedMetaanalysis.enteredBy), // can't be changed but should be checked\n    CHECKctime: tools.number(receivedMetaanalysis.ctime), // can't be changed but should be checked\n    // mtime: tools.number(receivedMetaanalysis.mtime),              // will be updated\n    published: tools.string(receivedMetaanalysis.published),\n    description: tools.string(receivedMetaanalysis.description),\n    tags: tools.array(receivedMetaanalysis.tags, tools.string),\n    columns: tools.array(receivedMetaanalysis.columns, extractReceivedMetaanalysisColumnEntry),\n    paperOrder: tools.array(receivedMetaanalysis.paperOrder, tools.string),\n    hiddenCols: tools.array(receivedMetaanalysis.hiddenCols, tools.string),\n    hiddenExperiments: tools.array(receivedMetaanalysis.hiddenExperiments, tools.string),\n    excludedExperiments: tools.array(receivedMetaanalysis.excludedExperiments, tools.string),\n    aggregates: tools.array(receivedMetaanalysis.aggregates, extractReceivedAggregate),\n    groupingColumn: tools.string(receivedMetaanalysis.groupingColumn),\n    groupingAggregates: tools.array(receivedMetaanalysis.groupingAggregates, extractReceivedAggregate),\n    graphs: tools.array(receivedMetaanalysis.graphs, extractReceivedGraph),\n  };\n\n  return retval;\n}\n\nfunction extractReceivedMetaanalysisColumnEntry(recCol) {\n  const col = extractReceivedColumnEntry(recCol);\n  if (col) {\n    col.sourceColumnMap = tools.assoc(recCol.sourceColumnMap, tools.string);\n    delete col.obsoleteIDForMigration;\n  }\n\n  return col;\n}\n\nfunction extractReceivedAggregate(recAggr) {\n  // expecting receivedAggregate to come from JSON.parse()\n  return {\n    formula: tools.string(recAggr.formula),\n    comments: tools.array(recAggr.comments, extractReceivedComment),\n    title: tools.string(recAggr.title),\n  };\n}\n\nfunction extractReceivedGraph(recGraph) {\n  // uses a formula string just like computed columns and aggregates\n  return {\n    formula: tools.string(recGraph.formula),\n    comments: tools.array(recGraph.comments, extractReceivedComment),\n    title: tools.string(recGraph.title),\n  };\n}\n\nfunction apiMetaanalysisURL(user, title) {\n  return `/api/metaanalyses/${user}/${title || config.NEW_META_TITLE}`;\n}\n\nmodule.exports = {\n  listMetaanalysesForUser,\n  getMetaanalysisVersion,\n  saveMetaanalysis,\n  listTopMetaanalyses,\n};\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/routes/papers.js","messages":[{"ruleId":"object-curly-newline","severity":2,"message":"Expected a line break after this opening brace.","line":1,"column":7,"nodeType":"ObjectPattern","messageId":"expectedLinebreakAfterOpeningBrace","endLine":1,"endColumn":8,"fix":{"range":[7,7],"text":"\n"}},{"ruleId":"object-curly-newline","severity":2,"message":"Expected a line break before this closing brace.","line":1,"column":76,"nodeType":"ObjectPattern","messageId":"expectedLinebreakBeforeClosingBrace","endLine":1,"endColumn":77,"fix":{"range":[75,75],"text":"\n"}},{"ruleId":"arrow-parens","severity":2,"message":"Expected parentheses around arrow function argument.","line":16,"column":20,"nodeType":"ArrowFunctionExpression","messageId":"expectedParens","endLine":16,"endColumn":21,"fix":{"range":[705,706],"text":"(p)"}},{"ruleId":"function-paren-newline","severity":2,"message":"Expected newline before ')'.","line":41,"column":23,"nodeType":"Punctuator","messageId":"expectedBefore","endLine":41,"endColumn":24,"fix":{"range":[1485,1485],"text":"\n"}}],"errorCount":4,"warningCount":0,"fixableErrorCount":4,"fixableWarningCount":0,"source":"const { NotFoundError, ValidationError, NotImplementedError, InternalError } = require('../errors');\nconst storage = require('../storage');\nconst config = require('../config');\nconst tools = require('../lib/tools');\n\n/* -------------------------------------------------------------------------- */\n/*                               Route Handlers                               */\n/* -------------------------------------------------------------------------- */\n\nasync function listPapersForUser(req, res, next) {\n  try {\n    const papers = await storage.papers.getPapersEnteredBy(req.params.user);\n    if (papers.length === 0) throw new Error('no papers found');\n\n    const retval = [];\n    papers.forEach(p => {\n      retval.push(extractPaperForSending(p, false, req.params.user));\n    });\n    res.json(retval);\n  } catch (error) {\n    next(new NotFoundError());\n  }\n}\n\nasync function getPaperVersion(req, res, next) {\n  try {\n    const paper = await storage.papers.getPaperByTitle(req.params.user, req.params.title);\n    const username = await storage.users.getUsernameOfUser(paper.enteredBy);\n    res.json(extractPaperForSending(paper, true, req.params.user, username));\n  } catch (e) {\n    next(e.status ? e : new NotFoundError());\n  }\n}\n\nasync function savePaper(req, res, next) {\n  // extract from incoming data stuff that is allowed\n  try {\n    const p = await storage.papers.savePaper(\n      extractReceivedPaper(req.body),\n      req.user.emails[0].value,\n      req.params.title);\n    res.json(extractPaperForSending(p, true, req.params.user));\n  } catch (e) {\n    if (e instanceof ValidationError || e instanceof NotImplementedError) {\n      next(e);\n    } else {\n      next(new InternalError(e));\n    }\n  }\n}\n\n/* -------------------------------------------------------------------------- */\n/*                                   Helpers                                  */\n/* -------------------------------------------------------------------------- */\n\nfunction extractPaperForSending(storagePaper, includeDataValues, user, username) {\n  const retval = {\n    id: storagePaper.id,\n    title: storagePaper.title,\n    enteredBy: storagePaper.enteredBy,\n    enteredByUsername: username,\n    ctime: storagePaper.ctime,\n    mtime: storagePaper.mtime,\n    reference: storagePaper.reference,\n    description: storagePaper.description,\n    link: storagePaper.link,\n    doi: storagePaper.doi,\n    tags: storagePaper.tags,\n    // todo comments in various places?\n  };\n\n  if (user) retval.apiurl = apiPaperURL(user, retval.title);\n\n  if (includeDataValues) {\n    retval.experiments = storagePaper.experiments;\n    retval.columns = storagePaper.columns;\n    retval.hiddenCols = storagePaper.hiddenCols;\n  }\n\n  return retval;\n}\n\nfunction extractReceivedPaper(receivedPaper) {\n  // expecting receivedPaper to come from JSON.parse()\n  const retval = {\n    id: tools.string(receivedPaper.id), // identifies the paper to be changed\n    title: tools.string(receivedPaper.title),\n    CHECKenteredBy: tools.string(receivedPaper.enteredBy), // can't be changed but should be checked\n    CHECKctime: tools.number(receivedPaper.ctime), // can't be changed but should be checked\n    // mtime: tools.number(receivedPaper.mtime),           // will be updated\n    reference: tools.string(receivedPaper.reference),\n    description: tools.string(receivedPaper.description),\n    link: tools.string(receivedPaper.link),\n    doi: tools.string(receivedPaper.doi),\n    tags: tools.array(receivedPaper.tags, tools.string),\n    experiments: tools.array(receivedPaper.experiments, extractReceivedExperiment),\n    columns: tools.array(receivedPaper.columns, extractReceivedColumnEntry),\n    hiddenCols: tools.array(receivedPaper.hiddenCols, tools.string),\n  };\n\n  // todo anything else recently added to the data\n\n  return retval;\n}\n\nfunction extractReceivedExperiment(receivedExperiment) {\n  const retval = {\n    title: tools.string(receivedExperiment.title),\n    CHECKenteredBy: tools.string(receivedExperiment.enteredBy),\n    CHECKctime: tools.number(receivedExperiment.ctime),\n    description: tools.string(receivedExperiment.description),\n    data: tools.assoc(receivedExperiment.data, extractReceivedExperimentDatum),\n    comments: tools.array(receivedExperiment.comments, extractReceivedComment),\n  };\n  return retval;\n}\n\nfunction extractReceivedExperimentDatum(receivedDatum) {\n  const retval = {\n    value: tools.string(receivedDatum.value),\n    CHECKenteredBy: tools.string(receivedDatum.enteredBy),\n    CHECKctime: tools.number(receivedDatum.ctime),\n    comments: tools.array(receivedDatum.comments, extractReceivedComment),\n  };\n  return retval;\n}\n\nfunction extractReceivedComment(receivedComment) {\n  const retval = {\n    CHECKby: tools.string(receivedComment.by),\n    CHECKctime: tools.number(receivedComment.ctime),\n    onVersionBy: tools.string(receivedComment.onVersionBy),\n    text: tools.string(receivedComment.text),\n    hidden: tools.bool(receivedComment.hidden),\n  };\n  return retval;\n}\n\nfunction extractReceivedColumnEntry(recCol) {\n  if (typeof recCol === 'object') {\n    return {\n      id: tools.string(recCol.id),\n      title: tools.string(recCol.title),\n      description: tools.string(recCol.description),\n      type: tools.string(recCol.type),\n      formula: tools.string(recCol.formula),\n      comments: tools.array(recCol.comments, extractReceivedComment),\n      obsoleteIDForMigration: tools.string(recCol.obsoleteIDForMigration),\n    };\n  }\n\n  return undefined;\n}\n\nfunction apiPaperURL(user, title) {\n  return `/api/papers/${user}/${title || config.NEW_PAPER_TITLE}`;\n}\n\nmodule.exports = {\n  listPapersForUser,\n  getPaperVersion,\n  savePaper,\n  extractPaperForSending,\n  extractReceivedColumnEntry,\n  extractReceivedComment,\n};\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/routes/redirected-api.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/routes/users.js","messages":[{"ruleId":"operator-linebreak","severity":2,"message":"'||' should be placed at the beginning of the line.","line":28,"column":68,"nodeType":"LogicalExpression","messageId":"operatorAtBeginning","endLine":28,"endColumn":70,"fix":{"range":[1316,1326],"text":"\n      || "}},{"ruleId":"operator-linebreak","severity":2,"message":"'||' should be placed at the beginning of the line.","line":29,"column":54,"nodeType":"LogicalExpression","messageId":"operatorAtBeginning","endLine":29,"endColumn":56,"fix":{"range":[1372,1382],"text":"\n      || "}}],"errorCount":2,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"const { UnauthorizedError, NotFoundError, InternalError } = require('../errors');\nconst storage = require('../storage');\nconst tools = require('../lib/tools');\n\n/* -------------------------------------------------------------------------- */\n/*                               Route Handlers                               */\n/* -------------------------------------------------------------------------- */\n\nasync function saveUser(req, res, next) {\n  const user = extractReceivedUser(req.user);\n  user.mtime = Date.now(); // update modification time - this is the last time the user agreed to T&C&PP\n  user.username = tools.string(req.body.username);\n  try {\n    const storageUser = await storage.users.saveUser(user.email, user);\n    res.json(extractUserForSending(storageUser));\n  } catch (err) {\n    next(err instanceof Error ? err : new InternalError(err));\n  }\n}\n\n// Check that the user is known to LiMA and that LiMA has up-to-date values from the identity provider.\nasync function checkUser(req, res, next) {\n  const email = req.user.emails[0].value;\n  try {\n    const storageUser = await storage.users.getUser(email);\n    // Check whether there are any changes to the Google Object\n    const strippedGoogleUser = extractReceivedUser(req.user);\n    if (strippedGoogleUser.displayName !== storageUser.displayName ||\n      strippedGoogleUser.email !== storageUser.email ||\n      JSON.stringify(strippedGoogleUser.photos) !== JSON.stringify(storageUser.photos)) {\n      Object.assign(storageUser, strippedGoogleUser);\n      try {\n        const savedUser = await storage.users.saveUser(storageUser.email, storageUser);\n        res.json(extractUserForSending(savedUser));\n      } catch (err) {\n        next(new InternalError(err));\n      }\n    } else {\n      res.json(extractUserForSending(storageUser));\n    }\n  } catch (error) {\n    // User is not known to LiMA, return 401 to be caught by caller\n    next(new UnauthorizedError('Please register with LiMA at /register'));\n  }\n}\n\nasync function returnUserProfile(req, res, next) {\n  try {\n    const user = await storage.users.getUser(req.params.user);\n    res.json(extractUserForSending(user));\n  } catch (err) {\n    if (err && err.status) {\n      next(err);\n    } else {\n      next(new NotFoundError());\n    }\n  }\n}\n\n/* -------------------------------------------------------------------------- */\n/*                                 Middleware                                 */\n/* -------------------------------------------------------------------------- */\n\nasync function SAME_USER(req, res, next) {\n  const email = req.user.emails[0].value;\n  try {\n    const user = await storage.users.getUser(email);\n    if (user.email === req.params.user || user.username === req.params.user) {\n      next();\n    } else {\n      throw new Error();\n    }\n  } catch (error) {\n    next(new UnauthorizedError('Please register with LiMA at /register'));\n  }\n}\n\nasync function EXISTS_USER(req, res, next) {\n  try {\n    await storage.users.getUser(req.params.user);\n    next();\n  } catch (error) {\n    next(new NotFoundError());\n  }\n}\n\n/* -------------------------------------------------------------------------- */\n/*                                   Helpers                                  */\n/* -------------------------------------------------------------------------- */\n\nfunction extractReceivedUser(receivedUser) {\n  // expecting receivedUser to be a Javascript object\n  const retval = {\n    displayName: tools.string(receivedUser.displayName),\n    email: tools.string(receivedUser.emails[0].value),\n    photos: tools.array(receivedUser.photos, extractReceivedPhoto),\n  };\n\n  return retval;\n}\n\nfunction extractReceivedPhoto(recPhoto) {\n  const retval = {\n    value: tools.string(recPhoto.value),\n  };\n  return retval;\n}\n\n/**\n * @param {User} user\n */\nfunction extractUserForSending(user) {\n  const retval = {\n    displayName: user.displayName,\n    name: user.name,\n    email: user.email,\n    photos: user.photos,\n    joined: user.ctime,\n    username: user.username,\n  };\n  return retval;\n}\n\nmodule.exports = {\n  SAME_USER,\n  EXISTS_USER,\n  saveUser,\n  checkUser,\n  returnUserProfile,\n};\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/storage/index.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/storage/metaanalyses.js","messages":[{"ruleId":"no-multi-assign","severity":2,"message":"Unexpected chained assignment.","line":114,"column":26,"nodeType":"AssignmentExpression","messageId":"unexpectedChain","endLine":114,"endColumn":52}],"errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const { datastore, checkForDisallowedChanges, fillByAndCtimes } = require('./shared');\nconst users = require('./users');\nconst tools = require('../lib/tools');\nconst config = require('../config');\nconst { ValidationError, NotImplementedError, InternalError } = require('../errors');\n\n\nasync function getMetaanalysesEnteredBy(user) {\n  // todo also return metaanalyses contributed to by `email`\n  if (!user) {\n    throw new Error('user parameter required');\n  }\n\n  const email = await users.getEmailAddressOfUser(user);\n  const query = datastore.createQuery('Metaanalysis').filter('enteredBy', '=', email);\n\n  try {\n    const [metaanalyses] = await datastore.runQuery(query);\n    return metaanalyses;\n  } catch (error) {\n    throw new InternalError();\n  }\n}\n\nasync function getMetaanalysisByTitle(user, title, time, includePapers) {\n  // todo if time is specified, compute a version as of that time\n  if (time) {\n    throw new NotImplementedError('getMetaanalysisByTitle with time not implemented');\n  }\n\n  // todo different users can use different titles for the same thing\n\n  if (title === config.NEW_META_TITLE) {\n    const email = await users.getEmailAddressOfUser(user);\n    return newMetaanalysis(email);\n  }\n\n  const query = datastore.createQuery('Metaanalysis').filter('title', '=', title);\n\n  const [[metaanalyses]] = await datastore.runQuery(query);\n  if (metaanalyses) {\n    let ma = metaanalyses;\n    if (includePapers) {\n      ma = await getMetaanalysisWithPapers(ma, time);\n    }\n    return ma;\n  }\n\n  throw new Error('No metaanalysis found');\n}\n\nasync function getMetaanalysisWithPapers(ma, time) {\n  if (time) {\n    throw new NotImplementedError('getMetaanalysisWithPapers with time not implemented');\n  }\n\n  if (!ma.paperOrder || ma.paperOrder.length === 0) return ma;\n\n  // use a shallow copy of ma\n  ma = { ...ma };\n\n  const createDatastoreKey = (id) => datastore.key(['Paper', id]);\n  const keys = ma.paperOrder.map(createDatastoreKey);\n\n  const [papers] = await datastore.get(keys);\n\n  ma.papers = [];\n  // populate the papers array in the order of ma.paperOrder\n  papers.forEach((p) => {\n    const index = ma.paperOrder.indexOf(p.id);\n    if (index !== -1) ma.papers[index] = p;\n  });\n\n  return ma;\n}\n\nasync function listMetaanalyses() {\n  const query = datastore.createQuery('Metaanalysis');\n  const [retval] = await datastore.runQuery(query);\n  return retval;\n}\n\nfunction newMetaanalysis(email) {\n  const time = tools.uniqueNow();\n  return {\n    enteredBy: email,\n    ctime: time,\n    mtime: time,\n  };\n}\n\nasync function saveMetaanalysis(metaanalysis, email, origTitle, options) {\n  options = options || {};\n  // todo multiple users' views on one metaanalysis\n  // compute this user's version of this metaanalysis, as it is in the database\n  // compute a diff between what's submitted and the user's version of this metaanalysis\n  // detect any update conflicts (how?)\n  // add the diff to the metaanalysis as a changeset\n  // update the metaanalysis data only if the user is the one who it's enteredBy\n  // only allow editing a comment if it's the last one by this user\n  //   (must allow editing the last comment by this user in case in the meantime another user\n  //    has added another comment)\n\n  // the following serializes this save after the previous one, whether it fails or succeeds\n  // this way we can't have two concurrent saves create metaanalyses with the same title\n\n\n  // prepare the metaanalysis for saving\n  const ctime = tools.uniqueNow();\n  let original = null;\n  if (!metaanalysis.id) {\n    metaanalysis.id = '/id/ma/' + ctime;\n    metaanalysis.enteredBy = email;\n    metaanalysis.ctime = metaanalysis.mtime = ctime;\n  } else {\n    const query = datastore.createQuery('Metaanalysis').filter('id', '=', metaanalysis.id);\n    const [[retval]] = await datastore.runQuery(query);\n    original = retval || null;\n\n    if (options.restoring) {\n      // metaanalysis is a metaanalysis we're restoring from some other datastore\n      // reject the save if we already have it\n      if (original) throw new Error(`metaanalysis ${metaanalysis.id} already exists`);\n      // otherwise save unchanged\n    } else {\n      // metaanalysis overwrites an existing metaanalysis\n      if (!original || origTitle !== original.title) {\n        throw new ValidationError(\n          `failed saveMetaanalysis: did not find id ${metaanalysis.id} with title ${origTitle}`,\n        );\n      }\n      if (email !== original.enteredBy) {\n        throw new NotImplementedError('not implemented saving someone else\\'s metaanalysis');\n      }\n\n      metaanalysis.enteredBy = original.enteredBy;\n      metaanalysis.ctime = original.ctime;\n      metaanalysis.mtime = tools.uniqueNow();\n    }\n  }\n\n  // validate incoming data\n  await checkForDisallowedChanges(metaanalysis, original);\n\n  // put ctime and enteredBy on every experiment, datum, and comment that doesn't have them\n  fillByAndCtimes(metaanalysis, original, email);\n\n  // for now, we choose to ignore if the incoming metaanalysis specifies\n  // the wrong immutable values here do not save any of the validation values\n  tools.deleteCHECKvalues(metaanalysis);\n\n  // save the metaanalysis in the data store\n  const key = datastore.key(['Metaanalysis', metaanalysis.id]);\n  // this is here until we add versioning on the metaanalyses themselves\n  const logKey = datastore.key(['Metaanalysis', metaanalysis.id,\n    'MetaanalysisLog', metaanalysis.id + '/' + metaanalysis.mtime]);\n  if (!options.restoring) console.log('saveMetaanalysis saving (into Metaanalysis and MetaanalysisLog)');\n\n  try {\n    await datastore.save([\n      { key, data: metaanalysis },\n      {\n        key: logKey,\n        data: [\n          {\n            name: 'mtime',\n            value: metaanalysis.mtime,\n          },\n          {\n            name: 'enteredBy',\n            value: email,\n          },\n          {\n            name: 'metaanalysis',\n            value: metaanalysis,\n            excludeFromIndexes: true,\n          },\n        ],\n      },\n    ]);\n    return metaanalysis;\n  } catch (error) {\n    console.error('error saving metaanalysis', error);\n    throw error;\n  }\n}\n\nmodule.exports = {\n  saveMetaanalysis,\n  getMetaanalysisByTitle,\n  getMetaanalysesEnteredBy,\n  listMetaanalyses,\n};\n\n/* -------------------------------------------------------------------------- */\n/*                                    Types                                   */\n/* -------------------------------------------------------------------------- */\n\n/**\n * @typedef {Object} Metaanalysis\n * @property {string} title\n * @property {string} enteredBy\n * @property {number} ctime\n * @property {number} mtime\n * @property {string} published\n * @property {string} description\n * @property {string[]} tags\n */\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/storage/papers.js","messages":[{"ruleId":"consistent-return","severity":2,"message":"Expected to return a value at the end of async function 'savePaper'.","line":62,"column":16,"nodeType":"FunctionDeclaration","messageId":"missingReturn"},{"ruleId":"no-multi-assign","severity":2,"message":"Unexpected chained assignment.","line":85,"column":19,"nodeType":"AssignmentExpression","messageId":"unexpectedChain","endLine":85,"endColumn":38}],"errorCount":2,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const { datastore, checkForDisallowedChanges, fillByAndCtimes } = require('./shared');\nconst { ValidationError, NotImplementedError } = require('../errors');\nconst tools = require('../lib/tools');\nconst users = require('./users');\nconst config = require('../config');\n\nasync function getPapersEnteredBy(user) {\n  if (!user) {\n    throw new Error('user parameter required');\n  }\n  const email = await users.getEmailAddressOfUser(user);\n  const query = datastore.createQuery('Paper').filter('enteredBy', '=', email);\n  const [papers] = await datastore.runQuery(query);\n  return papers;\n}\n\nasync function getPaperByTitle(user, title, time) {\n  // todo if time is specified, compute a version as of that time\n  if (time) throw new NotImplementedError('getPaperByTitle with time not implemented');\n\n  if (!user || !title) {\n    throw new Error('user and title parameters required');\n  }\n\n  // todo different users can use different titles for the same thing\n\n  if (title === config.NEW_PAPER_TITLE) {\n    const email = await users.getEmailAddressOfUser(user);\n    return newPaper(email);\n  }\n  const validUser = await users.getUser(user);\n  if (!validUser) return false;\n\n  const query = datastore.createQuery('Paper').filter('title', '=', title);\n  const [[paper]] = await datastore.runQuery(query);\n\n  if (paper) {\n    return paper;\n  }\n\n  throw new Error('No paper found');\n}\n\nfunction newPaper(email) {\n  const time = tools.uniqueNow();\n  return {\n    enteredBy: email,\n    ctime: time,\n    mtime: time,\n  };\n}\n\nconst currentPaperSave = Promise.resolve();\n\n/**\n * @param {Paper} paper\n * @param {string} email\n * @param {string} origTitle\n * @param {} options\n * @return {Promise<Paper>}\n */\nasync function savePaper(paper, email, origTitle, options) {\n  options = options || {};\n  // todo multiple users' views on one paper\n  // compute this user's version of this paper, as it is in the database\n  // compute a diff between what's submitted and the user's version of this paper\n  // detect any update conflicts (how?)\n  // add the diff to the paper as a changeset\n  // update the paper data only if the user is the one who it's enteredBy\n  // only allow editing a comment if it's the last one by this user\n  //   (must allow editing the last comment by this user in case in the meantime another user\n  //    has added another comment)\n\n  // the following serializes this save after the previous one, whether it fails or succeeds\n  // this way we can't have two concurrent saves create papers with the same title\n  await currentPaperSave;\n\n  // prepare the paper for saving\n  const ctime = tools.uniqueNow();\n  let original = null;\n\n  if (!paper.id) {\n    paper.id = '/id/p/' + ctime;\n    paper.enteredBy = email;\n    paper.ctime = paper.mtime = ctime;\n  } else {\n    const query = datastore.createQuery('Paper').filter('id', '=', paper.id);\n    const [[paperSearch]] = await datastore.runQuery(query);\n    if (paperSearch) {\n      original = paperSearch;\n\n      if (options.restoring && original) {\n        // paper is a paper we're restoring from some other datastore\n        // reject the save if we already have it\n        throw new Error(`paper ${paper.id} already exists`);\n        // otherwise save unchanged\n      } else {\n        // paper overwrites an existing paper\n        if (!original || origTitle !== original.title) {\n          throw new ValidationError(\n            `failed savePaper: did not find id ${paper.id} with title ${origTitle}`,\n          );\n        }\n        if (email !== original.enteredBy) {\n          throw new NotImplementedError('not implemented saving someone else\\'s paper');\n        }\n\n        paper.enteredBy = original.enteredBy;\n        paper.ctime = original.ctime;\n        paper.mtime = tools.uniqueNow();\n      }\n    }\n  }\n\n  // validate incoming data\n  await checkForDisallowedChanges(paper, original);\n\n  // put ctime and enteredBy on every experiment, datum, and comment that doesn't have them\n  fillByAndCtimes(paper, original, email);\n\n  // for now, we choose to ignore if the incoming paper specifies the wrong immutable values here\n  // do not save any of the validation values\n  tools.deleteCHECKvalues(paper);\n\n  // save the paper in the data store\n  const key = datastore.key(['Paper', paper.id]);\n  // this is here until we add versioning on the papers themselves\n  const logKey = datastore.key(['Paper', paper.id,\n    'PaperLog', paper.id + '/' + paper.mtime]);\n  try {\n    await datastore.save(\n      [\n        { key, data: paper },\n        {\n          key: logKey,\n          data:\n            [\n              {\n                name: 'mtime',\n                value: paper.mtime,\n              },\n              {\n                name: 'enteredBy',\n                value: email,\n              },\n              {\n                name: 'paper',\n                value: paper,\n                excludeFromIndexes: true,\n              },\n            ],\n        },\n      ],\n    );\n    return paper;\n  } catch (error) {\n    console.error('error saving paper');\n    console.error(error);\n  }\n}\n\nmodule.exports = {\n  getPapersEnteredBy,\n  savePaper,\n  getPaperByTitle,\n};\n\n/* -------------------------------------------------------------------------- */\n/*                                    Types                                   */\n/* -------------------------------------------------------------------------- */\n\n/**\n * @typedef {Object} Comment\n * @property {string} by\n * @property {string} onVersionBy\n * @property {string} text\n * @property {number} ctime\n * @property {boolean} hidden\n */\n\n/**\n * @typedef {Object} Experiment\n * @property {string} title\n * @property {string} description\n * @property {string} enteredBy\n * @property {number} ctime\n * @property {Object.<string, ExperimentData[]>} data\n * @property {Comment[]} comments\n */\n\n/**\n * @typedef {Object} ExperimentData\n * @property {string} value\n * @property {number} ctime\n * @property {string} enteredBy\n * @property {Comment[]} comments\n */\n\n/**\n * @typedef {Object} Paper\n * @property {string} id\n * @property {string} title\n * @property {string} enteredBy\n * @property {number} ctime\n * @property {number} mtime\n * @property {string} reference\n * @property {string} description\n * @property {string} link\n * @property {string} doi\n * @property {string[]} tags\n * @property {string} modifiedBy\n * @property {Comment[]} comments\n * @property {string[]} columns\n * @property {Experiment[]} experiments\n */\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/storage/scripts/betacodes.js","messages":[{"ruleId":"object-shorthand","severity":2,"message":"Expected property shorthand.","line":19,"column":9,"nodeType":"Property","messageId":"expectedPropertyShorthand","endLine":19,"endColumn":19,"fix":{"range":[564,574],"text":"code"}},{"ruleId":"object-shorthand","severity":2,"message":"Expected property shorthand.","line":21,"column":9,"nodeType":"Property","messageId":"expectedPropertyShorthand","endLine":21,"endColumn":25,"fix":{"range":[622,638],"text":"comment"}},{"ruleId":"arrow-parens","severity":2,"message":"Expected parentheses around arrow function argument.","line":27,"column":43,"nodeType":"ArrowFunctionExpression","messageId":"expectedParens","endLine":27,"endColumn":46,"fix":{"range":[828,831],"text":"(err)"}},{"ruleId":"arrow-parens","severity":2,"message":"Expected parentheses around arrow function argument.","line":44,"column":17,"nodeType":"ArrowFunctionExpression","messageId":"expectedParens","endLine":44,"endColumn":24,"fix":{"range":[1273,1280],"text":"(element)"}}],"errorCount":4,"warningCount":0,"fixableErrorCount":4,"fixableWarningCount":0,"source":"const uid = require('uid');\nconst readline = require('readline');\nconst fs = require('fs');\nconst { datastore } = require('../shared');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.question('Enter the number of codes you want: ', (numCodes) => {\n  rl.question('Enter a comment for the codes: ', async (comment) => {\n    let betaCodes = '';\n    const codes = [];\n    for (let i = 0; i < numCodes; i++) {\n      const code = uid(12);\n      const dateGenerated = new Date().toISOString();\n      codes.push({\n        code: code,\n        timeGenerated: dateGenerated,\n        comment: comment,\n      });\n      betaCodes += `${code} # ${dateGenerated} ${comment}\\n`;\n    }\n    console.log('Saving in datastore');\n    await saveCodes(codes);\n    fs.appendFile('codes.txt', betaCodes, err => {\n      if (err) {\n        console.error(err);\n      } else {\n        console.log('Successfully generated beta codes and saved in codes.txt');\n        console.log();\n        console.log(betaCodes);\n        console.log('to print, paste these in https://lima.soc.port.ac.uk/admin/print-invites');\n      }\n    });\n    rl.close();\n  });\n});\n\nasync function saveCodes(codes) {\n  const kind = 'BetaCode';\n  const entities = [];\n  codes.forEach(element => {\n    const codeKey = datastore.key([kind, element.code]);\n    entities.push({\n      key: codeKey,\n      data: element,\n    });\n  });\n  await datastore.upsert(entities);\n}\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/storage/scripts/migrate.js","messages":[{"ruleId":"lines-around-directive","severity":2,"message":"Expected newline after \"use strict\" directive.","line":1,"column":1,"nodeType":"ExpressionStatement","messageId":"expected","endLine":1,"endColumn":14,"fix":{"range":[13,13],"text":"\n"}},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 53 to the 40 allowed.","line":170,"column":10,"nodeType":null,"endLine":170,"endColumn":22},{"ruleId":"arrow-parens","severity":2,"message":"Expected parentheses around arrow function argument.","line":320,"column":18,"nodeType":"ArrowFunctionExpression","messageId":"expectedParens","endLine":320,"endColumn":22,"fix":{"range":[11342,11346],"text":"(user)"}},{"ruleId":"arrow-parens","severity":2,"message":"Expected parentheses around arrow function argument.","line":336,"column":18,"nodeType":"ArrowFunctionExpression","messageId":"expectedParens","endLine":336,"endColumn":25,"fix":{"range":[11746,11753],"text":"(element)"}}],"errorCount":4,"warningCount":0,"fixableErrorCount":3,"fixableWarningCount":0,"source":"'use strict';\nconst { datastore } = require('../shared');\n\nlet maPapers;\n/*\n * change metaanalysis from an old format to the new one on load from datastore, if need be\n */\nfunction migrateAggregates(metaanalysis) {\n  // 2017-05-02: move graph aggregates to graphs\n  //     when all is migrated: just remove this code\n  // migrate aggregate graphs to graphs\n  if (metaanalysis.aggregates) {\n    const oldGraphs = ['forestPlotNumberAggr', 'forestPlotPercentAggr',\n      'grapeChartNumberAggr', 'grapeChartPercentAggr'];\n    // going backwards so we can safely delete array elements\n    for (let i = metaanalysis.aggregates.length - 1; i >= 0; i -= 1) {\n      const formulaName = metaanalysis.aggregates[i].formula.split('(')[0];\n      if (oldGraphs.indexOf(formulaName) !== -1) {\n        const graph = metaanalysis.aggregates[i];\n        metaanalysis.aggregates.splice(i, 1);\n        graph.formula = graph.formula.replace('Aggr', 'Graph');\n        if (!metaanalysis.graphs) {\n          metaanalysis.graphs = [];\n        }\n        metaanalysis.graphs.unshift(graph);\n        metaanalysis.migrated = true;\n      }\n    }\n  }\n}\n\nasync function migrateColumns(metaanalysis) {\n  // 2017-06-28: migrate global columns to private columns\n  //     when all is migrated:\n  //       remove this code,\n  //       update tests to check migration no longer does this\n  //       remove all remaining mentions of global columns\n  //       remove columns from datastore\n  // prepare the papers this metaanalysis depends on\n  maPapers = await Promise.all(metaanalysis.paperOrder.map(async (paperId) => {\n    // find the paper with the matching ID\n    const query = datastore.createQuery('Paper').filter('id', '=', paperId);\n    const [retval] = await datastore.runQuery(query);\n    if (retval.length === 0) {\n      throw new Error(`metaanalysis ${metaanalysis.title} has a paper ${paperId} that isn't in the datastore`);\n    }\n    return retval[0];\n  }));\n}\n\nfunction migrateCheck(metaanalysis) {\n  // convert columns from string to object\n  if (!metaanalysis.columns) metaanalysis.columns = [];\n  let maxId = 0;\n  metaanalysis.columns.forEach(async (col, colIndex) => {\n    if (typeof col === 'string') {\n      // migrate the string into an object\n      const query = datastore.createQuery('Column').filter('id', '=', col);\n      const [retval] = await datastore.runQuery(query);\n      if (retval.length === 0) throw new Error(`metaanalysis ${metaanalysis.title} uses nonexistent column ${col}`);\n      const column = retval[0];\n      const colObject = {\n        id: '' + (maxId += 1),\n        title: column.title,\n        description: column.description,\n        type: column.type,\n      };\n\n      // add sourceColumnMap { paperId: columnId }\n      colObject.sourceColumnMap = {};\n\n      maPapers.forEach((paper) => {\n        // go through paper's columns, find the one whose obsolete id matches col, use its ID in this map\n        const paperCol = paper.columns.find((paperColObject) => paperColObject.obsoleteIDForMigration === col);\n        if (paperCol) colObject.sourceColumnMap[paper.id] = paperCol.id;\n        // if the paper doesn't have such a column, just don't have a mapping;\n        // the column in the paper, and the mapping here, will get added when\n        // the metaanalysis is being edited and the user puts in a datum in this column\n      });\n      metaanalysis.columns[colIndex] = colObject;\n      // migrate hidden columns so it uses the right column ID\n      if (metaanalysis.hiddenCols) {\n        const colPos = metaanalysis.hiddenCols.indexOf(col);\n        if (colPos !== -1) {\n          metaanalysis.hiddenCols[colPos] = colObject.id;\n        }\n      }\n      // convert grouping column to new ID\n      if (metaanalysis.groupingColumn === col) metaanalysis.groupingColumn = colObject.id;\n      // migrate every parameter in computed anything into the right ID\n      for (const fieldName of ['columns', 'aggregates', 'groupingAggregates', 'graphs']) {\n        if (metaanalysis[fieldName]) {\n          metaanalysis[fieldName].forEach((computed) => {\n            if (!computed.formula) return; // not computed\n            // replace all occurrences of col in the formula with colObject.id\n            computed.formula = computed.formula.split(col).join(colObject.id);\n          });\n        }\n      }\n      metaanalysis.migrated = true;\n    }\n  });\n}\n\nfunction removeMissingData(metaanalysis) {\n  // check that every computed thing's formula doesn't contain '/id/col/',\n  // remove offending ones because they don't have data in the metaanalysis anyway so no loss\n  // also migrate customName to title and add type: result\n  for (const fieldName of ['columns', 'aggregates', 'groupingAggregates', 'graphs']) {\n    if (metaanalysis[fieldName]) {\n      let computedIndex = metaanalysis[fieldName].length - 1;\n      while (computedIndex >= 0) {\n        const computed = metaanalysis[fieldName][computedIndex];\n        if (computed.formula) {\n          if (computed.formula.indexOf('/id/col/') !== -1) {\n            metaanalysis[fieldName].splice(computedIndex, 1);\n            metaanalysis.migrated = true;\n          }\n          if (computed.customName) {\n            computed.title = computed.customName;\n            delete computed.customName;\n            metaanalysis.migrated = true;\n          }\n          if (!computed.type && fieldName === 'columns') {\n            computed.type = 'result';\n            metaanalysis.migrated = true;\n          }\n        }\n        computedIndex -= 1;\n      }\n    }\n  }\n}\n\nfunction migrateMetaanalysis(metaanalysis) {\n  // 2017-02-23: move columnOrder to columns\n  //     when all is migrated: just remove this code\n  if (metaanalysis.columnOrder) {\n    metaanalysis.columns = metaanalysis.columnOrder;\n    delete metaanalysis.columnOrder;\n    metaanalysis.migrated = true;\n  }\n\n  migrateAggregates(metaanalysis);\n\n  migrateColumns(metaanalysis);\n\n  migrateCheck(metaanalysis);\n\n  removeMissingData(metaanalysis);\n\n  // if we have a hiddenColumn that's not migrated, drop it\n  if (metaanalysis.hiddenCols) {\n    let hiddenIndex = metaanalysis.hiddenCols.length - 1;\n    while (hiddenIndex >= 0) {\n      if (metaanalysis.hiddenCols[hiddenIndex].startsWith('/id/col/')) {\n        metaanalysis.hiddenCols.splice(hiddenIndex, 1);\n        metaanalysis.migrated = true;\n      }\n      hiddenIndex -= 1;\n    }\n  }\n\n  return metaanalysis;\n}\n\n/*\n * change paper from an old format to the new one on load from datastore, if need be\n */\nfunction migratePaper(paper, columns) {\n  // 2017-02-23: move columnOrder to columns\n  //     when all is migrated: just remove this code\n  if (paper.columnOrder) {\n    paper.columns = paper.columnOrder;\n    delete paper.columnOrder;\n    paper.migrated = true;\n  }\n\n  // 2017-06-27: migrate global columns to private columns\n  //     when all is migrated:\n  //       remove this code,\n  //       remove obsoleteIDForMigration from api.js\n  //       update tests to check migration no longer does this\n  //       remove all remaining mentions of global columns\n  //       remove columns from datastore\n\n  // if we have a datum whose column ID isn't in paper.columns then add it there\n  if (!paper.columns) paper.columns = [];\n  if (paper.experiments) {\n    paper.experiments.forEach((exp) => {\n      if (exp.data) {\n        Object.keys(exp.data).forEach((colId) => {\n          if (colId.startsWith('/id/col/') && paper.columns.indexOf(colId) === -1) {\n            paper.columns.push(colId);\n            paper.migrated = true;\n          }\n        });\n      }\n    });\n  }\n\n  let maxId = 0;\n  paper.columns.forEach((col, colIndex) => {\n    if (typeof col === 'string') {\n      // migrate the string into an object\n      if (!columns[col]) throw new Error(`paper ${paper.title} uses nonexistent column ${col}`);\n      const colObject = {\n        id: '' + (maxId += 1),\n        title: columns[col].title,\n        description: columns[col].description,\n        type: columns[col].type,\n        obsoleteIDForMigration: col,\n      };\n      paper.columns[colIndex] = colObject;\n      // migrate experiment data so it uses the column ID\n      if (paper.experiments) {\n        paper.experiments.forEach((exp) => {\n          if (exp.data && col in exp.data) {\n            exp.data[colObject.id] = exp.data[col];\n            delete exp.data[col];\n          }\n        });\n      }\n      // migrate hidden columns so it uses the right column ID\n      if (paper.hiddenCols) {\n        const colPos = paper.hiddenCols.indexOf(col);\n        if (colPos !== -1) {\n          paper.hiddenCols[colPos] = colObject.id;\n        }\n      }\n      // migrate every parameter in computed anything into the right ID\n      paper.columns.forEach((computed) => {\n        if (!computed.formula) return; // not computed\n        // replace all occurrences of col in the formula with colObject.id\n        computed.formula = computed.formula.split(col).join(colObject.id);\n      });\n      paper.migrated = true;\n    }\n  });\n  // check that every computed column's formula doesn't contain '/id/col/',\n  // remove offending ones because they don't have data in the paper anyway so no loss\n  // also migrate customName to title and add type: result\n  let computedIndex = paper.columns.length - 1;\n  while (computedIndex >= 0) {\n    const computed = paper.columns[computedIndex];\n    if (computed.formula) {\n      if (computed.formula.indexOf('/id/col/') !== -1) {\n        paper.columns.splice(computedIndex, 1);\n        paper.migrated = true;\n      }\n      if (computed.customName || !computed.type) {\n        computed.title = computed.customName;\n        delete computed.customName;\n        computed.type = 'result';\n        paper.migrated = true;\n      }\n    }\n    computedIndex -= 1;\n  }\n  // if we have a hiddenColumn that's not migrated, drop it\n  if (paper.hiddenCols) {\n    let hiddenIndex = paper.hiddenCols.length - 1;\n    while (hiddenIndex >= 0) {\n      if (paper.hiddenCols[hiddenIndex].startsWith('/id/col/')) {\n        paper.hiddenCols.splice(hiddenIndex, 1);\n        paper.migrated = true;\n      }\n      hiddenIndex -= 1;\n    }\n  }\n\n  return paper;\n}\n\n/*\n * change user from an old format to the new one on load from datastore, if need be\n */\nfunction migrateUser(user) {\n  // 2017-06-08: Only store limited user information\n  //     when all is migrated: just remove this code\n  if (user.emails) {\n    user.email = user.emails[0].value;\n    delete user.emails;\n    delete user.CHECKid;\n    delete user.id;\n    delete user.name;\n    delete user.provider;\n    user.migrated = true;\n  }\n  return user;\n}\n\nasync function getAllColumns() {\n  try {\n    console.log('getAllColumns: making a datastore request');\n    const retval = {};\n    const [results] = await datastore.createQuery('Column').run();\n\n    results.forEach((result) => {\n      try {\n        retval[result.id] = result;\n      } catch (error) {\n        console.error('error in a column entity (ignoring)', error);\n      }\n    });\n\n    console.log(`getAllColumns: ${Object.keys(retval).length} done`);\n    return retval;\n  } catch (error) {\n    console.error('error retrieving columns', error);\n    setTimeout(getAllColumns, 60 * 1000); // try loading again in a minute\n    throw error;\n  }\n}\n\nasync function migrateAllUsers() {\n  const kind = 'User';\n  const [retval] = await datastore.createQuery(kind).run();\n  const entities = [];\n  retval.forEach(user => {\n    const val = migrateUser(user);\n    const userKey = datastore.key([kind, val.email]);\n    entities.push({\n      key: userKey,\n      data: val,\n    });\n  });\n  await datastore.upsert(entities);\n}\n\nasync function migrateAllPapers() {\n  const columns = getAllColumns();\n  const kind = 'Paper';\n  const [retval] = await datastore.createQuery(kind).run();\n  const entities = [];\n  retval.forEach(element => {\n    const val = migratePaper(element, columns);\n    const paperKey = datastore.key([kind, element.id]);\n    entities.push({\n      key: paperKey,\n      data: val,\n    });\n  });\n  await datastore.upsert(entities);\n}\n\nasync function migrateAllMetaanalysis() {\n  const kind = 'Metaanalysis';\n  const [retval] = await datastore.createQuery(kind).run();\n  const entities = [];\n  for (const element of retval) {\n    try {\n      const val = migrateMetaanalysis(element);\n      const metaanalysisKey = datastore.key([kind, val.id]);\n      entities.push({\n        key: metaanalysisKey,\n        data: val,\n      });\n    } catch (error) {\n      console.log(error);\n    }\n  }\n  await datastore.upsert(entities);\n}\n\nasync function migrate() {\n  await migrateAllUsers();\n  await migrateAllPapers();\n  await migrateAllMetaanalysis();\n  console.log('Migration complete');\n}\n\nmigrate();\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/storage/shared.js","messages":[{"ruleId":"import/order","severity":2,"message":"`@google-cloud/datastore` import should occur before import of `../config`","line":4,"column":23,"nodeType":"CallExpression","endLine":4,"endColumn":57,"fix":{"range":[0,184],"text":"const { Datastore } = require('@google-cloud/datastore');\nconst config = require('../config');\nconst { ValidationError } = require('../errors');\nconst tools = require('../lib/tools');\n"}},{"ruleId":"import/order","severity":2,"message":"`fs` import should occur before import of `../config`","line":5,"column":12,"nodeType":"CallExpression","endLine":5,"endColumn":25,"fix":{"range":[0,210],"text":"const fs = require('fs');\nconst config = require('../config');\nconst { ValidationError } = require('../errors');\nconst tools = require('../lib/tools');\nconst { Datastore } = require('@google-cloud/datastore');\n"}},{"ruleId":"import/order","severity":2,"message":"`path` import should occur before import of `../config`","line":6,"column":14,"nodeType":"CallExpression","endLine":6,"endColumn":29,"fix":{"range":[0,240],"text":"const path = require('path');\nconst config = require('../config');\nconst { ValidationError } = require('../errors');\nconst tools = require('../lib/tools');\nconst { Datastore } = require('@google-cloud/datastore');\nconst fs = require('fs');\n"}},{"ruleId":"no-use-before-define","severity":2,"message":"'forbiddenUsernames' was used before it was defined.","line":113,"column":26,"nodeType":"Identifier","messageId":"usedBeforeDefined","endLine":113,"endColumn":44}],"errorCount":4,"warningCount":0,"fixableErrorCount":3,"fixableWarningCount":0,"source":"const config = require('../config');\nconst { ValidationError } = require('../errors');\nconst tools = require('../lib/tools');\nconst { Datastore } = require('@google-cloud/datastore');\nconst fs = require('fs');\nconst path = require('path');\n\nconst TITLE_REXP = new RegExp(`^${config.TITLE_RE}$`);\nconst USERNAME_REXP = new RegExp(`^${config.USERNAME_RE}$`);\n\nconst knownColumnIDs = {};\n\nconst datastoreConfig = {\n  namespace: config.gcloudDatastoreNamespace,\n};\n\nif (!process.env.GAE_APPLICATION && config.gcloudProject) {\n  datastoreConfig.projectId = config.gcloudProject.projectId;\n  datastoreConfig.keyFilename = config.gcloudProject.keyFilename;\n}\n\nconst datastore = new Datastore(datastoreConfig);\n\nfunction fillByAndCtimes(current, original, email) {\n  const orig = original || {};\n  if (!current.enteredBy) current.enteredBy = orig.enteredBy || email;\n  if (!current.ctime) current.ctime = orig.ctime || tools.uniqueNow();\n\n  fillByAndCtimeInComments(current.comments, orig.comments, email);\n  fillExperiment(current, orig, email);\n  fillColumns(current, orig, email);\n  fillAggregate(current, orig, email);\n}\n\nfunction fillInfoCheck(exp, orig, email) {\n  if (!exp.enteredBy) exp.enteredBy = orig.enteredBy || email;\n  if (!exp.ctime) exp.ctime = orig.ctime || tools.uniqueNow();\n}\n\nfunction fillExperiment(current, orig, email) {\n  if (current.experiments) {\n    for (let expIndex = 0; expIndex < current.experiments.length; expIndex++) {\n      const exp = current.experiments[expIndex];\n      const origExp = (orig.experiments || [])[expIndex] || {};\n      fillInfoCheck(exp, origExp, email);\n      fillByAndCtimeInComments(exp.comments, origExp.comments, email);\n      for (const col of Object.keys(exp.data || {})) {\n        const expCol = exp.data[col];\n        const origCol = (origExp.data || {})[col] || {};\n        const origColIfSameVal = expCol.value === origCol.value ? origCol : {};\n        fillInfoCheck(expCol, origColIfSameVal, email);\n        fillByAndCtimeInComments(expCol.comments, origCol.comments, email);\n      }\n    }\n  }\n}\n\nfunction fillColumns(current, orig, email) {\n  if (current.columns) {\n    for (let colIndex = 0; colIndex < current.columns.length; colIndex++) {\n      if (typeof current.columns[colIndex] === 'object') {\n        const col = current.columns[colIndex];\n        const origCol = (orig.columns || [])[colIndex] || {};\n        fillByAndCtimeInComments(col.comments, origCol.comments, email);\n      }\n    }\n  }\n}\n\nfunction fillAggregate(current, orig, email) {\n  if (current.aggregates) {\n    for (let aggrIndex = 0; aggrIndex < current.aggregates.length; aggrIndex++) {\n      const aggr = current.aggregates[aggrIndex];\n      const origAggr = (orig.aggregates || [])[aggrIndex] || {};\n      fillByAndCtimeInComments(aggr.comments, origAggr.comments, email);\n    }\n  }\n}\n\nfunction fillByAndCtimeInComments(comments, origComments, email) {\n  origComments = origComments || [];\n  if (!Array.isArray(comments)) return;\n  for (let i = 0; i < comments.length; i++) {\n    const com = comments[i];\n    const origCom = origComments[i] || {};\n    const origComIfSameText = origCom.text === com.text ? origCom : {};\n    if (!com.by) com.by = origComIfSameText.by || email;\n    if (!com.ctime) com.ctime = origComIfSameText.ctime || tools.uniqueNow();\n  }\n}\n\nasync function titleCheck(current, original) {\n  if (current.title !== original.title) {\n    if (!TITLE_REXP.test(current.title)) {\n      throw new ValidationError('title cannot contain spaces or special characters');\n    }\n    const [[metaanalysesCheck]] = await datastore.createQuery('Metaanalysis').filter('title', '=', current.title).run();\n    const [[paperCheck]] = await datastore.createQuery('Metaanalysis').filter('title', '=', current.title).run();\n    if (metaanalysesCheck || paperCheck) {\n      throw new ValidationError('title must be unique');\n    }\n    if (current.title === config.NEW_PAPER_TITLE || current.title === config.NEW_META_TITLE) {\n      throw new ValidationError('cannot use a reserved name');\n    }\n  }\n\n  // check that username hasn't changed or if it has, that it is empty or unique\n  if (current.username != null && current.username !== original.username) {\n    if (!USERNAME_REXP.test(current.username)) {\n      throw new ValidationError('username cannot contain spaces or special characters');\n    }\n    const [[usernameCheck]] = await datastore.createQuery('User').filter('username', '=', current.username).run();\n    if (usernameCheck || forbiddenUsernames.includes(current.username)) {\n      throw new ValidationError('username must be unique, must not be from the forbidden list');\n    }\n    // todo: do we need extra checks here? I.e. length of username? encodings? emojis?\n  }\n}\n\nfunction columnCheck(current) {\n  if (current.columns) {\n    current.columns.forEach((colObject) => {\n      if (colObject.formula && colObject.id) throw new ValidationError('computed column must not have ID');\n      if (!colObject.formula && !colObject.id) throw new ValidationError('column without ID must have formula');\n\n      if (colObject.id) {\n        if (knownColumnIDs[colObject.id]) {\n          throw new ValidationError('two columns cannot have the same ID');\n        }\n        knownColumnIDs[colObject.id] = true;\n      }\n    });\n  }\n}\n\nfunction experimentCommentOwnerCheck(origComments, comments) {\n  const changedCommentByOwner = {};\n  for (let i = 0; i < origComments.length; i++) {\n    const comment = comments[i];\n    const origComment = origComments[i];\n    if (comment.CHECKby !== origComment.by) {\n      throw new ValidationError('cannot change comment owner');\n    }\n    if (comment.CHECKby in changedCommentByOwner) {\n      throw new ValidationError('cannot edit comment before the last by a given owner');\n    }\n    if (comment.text !== origComment.text) {\n      changedCommentByOwner[comment.CHECKby] = 1;\n    }\n  }\n}\n\nfunction experimentCommentCheck(origExp, exp) {\n  for (const origDataKey of Object.keys(origExp.data)) {\n    if (!(origDataKey in exp.data)) {\n      throw new ValidationError('cannot remove experiment data');\n    }\n\n    const { comments } = exp.data[origDataKey];\n    const origComments = origExp.data[origDataKey].comments;\n\n    if (origComments) {\n      if (!comments || comments.length < origComments.length) {\n        throw new ValidationError('cannot remove comments');\n      }\n\n      experimentCommentOwnerCheck(origComments, comments);\n    }\n  }\n}\n\nfunction experimentCheck(current, original) {\n  for (let expIndex = 0; expIndex < current.experiments.length; expIndex++) {\n    const exp = current.experiments[expIndex];\n    const origExp = (original.experiments || [])[expIndex] || {};\n\n    // check experiment titles are there (but need not be unique)\n    if (!TITLE_REXP.test(exp.title)) {\n      throw new ValidationError('experiment title cannot contain spaces or special characters');\n    }\n\n    if (origExp.data) {\n      if (!exp.data) throw new ValidationError('cannot remove experiment data array');\n      experimentCommentCheck(origExp, exp);\n    }\n    if (exp.data) {\n      for (const dataKey of Object.keys(exp.data)) {\n        if (!knownColumnIDs[dataKey]) {\n          throw new ValidationError('cannot include data with unknown column ID ' + dataKey);\n        }\n      }\n    }\n  }\n}\n\n\nasync function checkForDisallowedChanges(current, original) {\n  original = original || {};\n\n  // check that title hasn't changed or if it has, that it is unique\n  await titleCheck(current, original);\n\n  // check that no two columns have the same ID\n  // check that computed columns don't have IDs and that the others do\n  // also prepare a hash of known column IDs for use later\n  columnCheck(current);\n\n\n  // check that every experiment has at least the data values that were there originally\n  // check that only last comment by a given user has changed, if any\n  if (current.experiments) {\n    experimentCheck(current, original);\n  }\n}\n\n// on start of web server put all file names in /webpages into this list, with and without filename extensions\nconst forbiddenUsernames = [];\n\nfunction getForbiddenUsernames() {\n  // start initially with those defined in config\n  const retval = [...config.FORBIDDEN_USERNAMES];\n\n  // then populate the rest by taking a look at /webpages\n  const files = fs.readdirSync(path.join(__dirname, '..', '..', 'webpages'));\n\n  files.forEach((name) => {\n    addUsernameIfNotThere(retval, name);\n    addUsernameIfNotThere(retval, name.replace(/\\..*$/, ''));\n  });\n\n  function addUsernameIfNotThere(arr, name) {\n    // don't add usernames that wouldn't be allowed anyway\n    if (!name) return;\n    if (!name.match(USERNAME_REXP)) return;\n\n    if (arr.indexOf(name) === -1) arr.push(name.toLowerCase());\n  }\n\n  // push all the found forbidden usernames into the global array\n  forbiddenUsernames.push(...retval);\n}\n\nmodule.exports = {\n  datastore,\n  fillByAndCtimes,\n  checkForDisallowedChanges,\n  forbiddenUsernames,\n  getForbiddenUsernames,\n};\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/storage/users.js","messages":[{"ruleId":"import/newline-after-import","severity":2,"message":"Expected 1 empty line after require statement not followed by another require.","line":3,"column":1,"nodeType":null,"fix":{"range":[177,177],"text":"\n"}}],"errorCount":1,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"const { datastore, checkForDisallowedChanges, forbiddenUsernames } = require('./shared');\nconst { ForbiddenError } = require('../errors');\nconst tools = require('../lib/tools');\nconst LOCAL_STORAGE_SPECIAL_USER = 'lima@local';\n\n/**\n * @param {string} user\n * @return {Promise<User>}\n */\nasync function getUser(user) {\n  if (!user) {\n    throw new Error('user parameter required');\n  }\n\n  if (forbiddenUsernames.indexOf(user) !== -1) {\n    throw new ForbiddenError('provided username is a reserved word');\n  }\n\n  let query;\n\n  if (user.includes('@')) {\n    // user is an email\n    query = datastore.createQuery('User').filter('email', '=', user);\n  } else {\n    query = datastore.createQuery('User').filter('username', '=', user);\n  }\n\n  try {\n    const [[retval]] = await datastore.runQuery(query);\n    if (retval) {\n      return retval;\n    } else {\n      throw new Error('User not found');\n    }\n  } catch (error) {\n    throw new Error('User not found');\n  }\n}\n\nasync function saveUser(email, user, options) {\n  options = options || {};\n  // todo do we want to keep a Log of users?\n  if (!email || !user) {\n    throw new Error('email/user parameters required');\n  }\n\n  if (email === LOCAL_STORAGE_SPECIAL_USER) {\n    throw new Error('must not add the user ' + LOCAL_STORAGE_SPECIAL_USER);\n  }\n\n  if (!user.ctime) { // new user\n    user.ctime = tools.uniqueNow();\n  }\n\n  let original = null;\n\n  try {\n    original = await getUser(email);\n  } catch (error) {\n    // original user does't exist\n  }\n\n  // reject the save if we're restoring from another datastore and we already have this user\n  if (options.restoring && original) {\n    throw new Error(`user ${user.email} already exists`);\n  }\n  checkForDisallowedChanges(user, original);\n  const key = datastore.key(['User', email]);\n  console.log('saveUser making a datastore request');\n  try {\n    await datastore.save({\n      key,\n      data: user,\n    });\n    // then return the user\n    return user;\n  } catch (err) {\n    console.error('error saving user', err);\n    throw err;\n  }\n}\n\n// Take either the email address, or username and return the email address\nasync function getEmailAddressOfUser(username) {\n  if (username.indexOf('@') !== -1) return username;\n\n  const query = datastore.createQuery('User').filter('username', '=', username);\n\n  try {\n    const [[user]] = await datastore.runQuery(query);\n\n    if (user) {\n      return user.email;\n    } else {\n      throw new Error('No email found');\n    }\n  } catch (error) {\n    return null;\n  }\n}\n\n// Take either the email address, or username and return the username (or null if there is none)\nasync function getUsernameOfUser(user) {\n  if (user.indexOf('@') === -1) return user;\n  const retval = await getUser(user);\n  return retval.username;\n}\n\nmodule.exports = {\n  getUser,\n  saveUser,\n  getEmailAddressOfUser,\n  getUsernameOfUser,\n  forbiddenUsernames,\n};\n\n/* -------------------------------------------------------------------------- */\n/*                                    Types                                   */\n/* -------------------------------------------------------------------------- */\n\n/**\n  * @typedef {Object} User\n  * @property {number} ctime\n  * @property {number} mtime The user last 'registered' i.e. agreed to t&c's (may have changed username)\n  * @property {string} email\n  * @property {string} displayName\n  * @property {string} username See regex for exact allowed names\n  * @property {[{value: string}]} photos\n  * @todo add favourites\n*/\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/MetaanalysisApp.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/layout/Footer.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/layout/Header.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/layout/OnTabChange.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/layout/Tabs.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/AddColumn.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/AddExperiment.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/AddPaper.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/ColumnRearranger.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/Comments.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/Details.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/EditContext.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/Editable.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/Info.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/Metaanalysis.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/Metadata.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/PlotsDefinitions.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/Popup.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/RowRearranger.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/UserContext.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/aggregates/AddAnalysis.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/aggregates/Aggregates.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/aggregates/FilterModerators.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/aggregates/Formulas.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/aggregates/GroupingAggregates.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/aggregates/SimpleAggregates.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/datatable/Cell.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/datatable/DataTable.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/datatable/Paper.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/plots/AddGraph.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/plots/GrapeChart.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/plots/GraphEditor.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/plots/GroupingForestPlots.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/plots/PlotSelector.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/plots/Plots.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/plots/SimpleForestPlots.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/tags/NewTag.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/tags/Tag.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/tags/TagList.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/metaanalysis.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/tools/datatools.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/tools/editTools.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/tools/google-auth.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/tools/graphtools.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/tools/modifyColumns.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]}]
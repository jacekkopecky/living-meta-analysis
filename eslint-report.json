[{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/config.js","messages":[{"ruleId":"strict","severity":2,"message":"'use strict' is unnecessary inside of modules.","line":1,"column":1,"nodeType":"ExpressionStatement","messageId":"module","endLine":1,"endColumn":14,"fix":{"range":[0,13],"text":""}},{"ruleId":"prefer-template","severity":2,"message":"Unexpected string concatenation.","line":11,"column":12,"nodeType":"BinaryExpression","messageId":"unexpectedStringConcatenation","endLine":11,"endColumn":48,"fix":{"range":[359,395],"text":"`${EMAIL_ADDRESS_RE  }|${  USERNAME_RE}`"}}],"errorCount":2,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"'use strict';\n\nconst EMAIL_ADDRESS_RE = '[a-zA-Z0-9.+-]+@[a-zA-Z0-9.+-]+';\nconst USERNAME_RE = '[a-zA-Z][a-zA-Z0-9_.-]{0,}';\n// when updating this, change the clientside copy in register.html\n// the above has to be {0,} rather than * because https://github.com/expressjs/express/issues/2495\n\nmodule.exports = {\n  // shared constants\n  USERNAME_RE,\n  USER_RE: EMAIL_ADDRESS_RE + '|' + USERNAME_RE,\n  FORBIDDEN_USERNAMES: [ // should be treated as case-insensitive\n    // routes\n    'api', 'version', 'profile',\n    // just common words\n    'test', 'lima',\n  ],\n  NEW_PAPER_TITLE: 'new-paper',\n  NEW_META_TITLE: 'new-metaanalysis',\n\n  // TITLE_RE was '[a-zA-Z0-9.-]+', now it accepts unicode letters and digits\n  // see webpages/js/tools.js\n  URL_TITLE_RE: '[a-zA-Z0-9%.-]+',\n  TITLE_RE: '[-.0-9A-Za-z\\u00AA\\u00B2\\u00B3\\u00B5\\u00B9\\u00BA\\u00BC-\\u00BE\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u0660-\\u0669\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07C0-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0966-\\u096F\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09E6-\\u09F1\\u09F4-\\u09F9\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A6F\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AE6-\\u0AEF\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B66-\\u0B6F\\u0B71-\\u0B77\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0BE6-\\u0BF2\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C66-\\u0C6F\\u0C78-\\u0C7E\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D58-\\u0D61\\u0D66-\\u0D78\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DE6-\\u0DEF\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F20-\\u0F33\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F-\\u1049\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u1090-\\u1099\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1369-\\u137C\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u17E0-\\u17E9\\u17F0-\\u17F9\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B50-\\u1B59\\u1B83-\\u1BA0\\u1BAE-\\u1BE5\\u1C00-\\u1C23\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2070\\u2071\\u2074-\\u2079\\u207F-\\u2089\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2150-\\u2189\\u2460-\\u249B\\u24EA-\\u24FF\\u2776-\\u2793\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2CFD\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u3192-\\u3195\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3220-\\u3229\\u3248-\\u324F\\u3251-\\u325F\\u3280-\\u3289\\u32B1-\\u32BF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA830-\\uA835\\uA840-\\uA873\\uA882-\\uA8B3\\uA8D0-\\uA8D9\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF-\\uA9D9\\uA9E0-\\uA9E4\\uA9E6-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]+',  // eslint-disable-line\n\n  // where to store Web access logs; relative to project root\n  logDirectory: './log',\n  // morgan format for access log lines, default is 'combined'\n  logFormat: ':remote-addr :invite :remote-user [:date[clf]] \":method :url HTTP/:http-version\" :status :res[content-length] \":referrer\" \":user-agent\" :response-time[0] ms',   // eslint-disable-line\n\n  // this is a delay for demonstration purposes so the server seems slow\n  demoApiDelay: 0,\n\n  // google-specific settings - commented out because appengine doesn't need that\n  // gcloudProject: {\n  //   projectId: 'uop-soc-lima',\n  //   keyFilename: 'lima-google-key.json',\n  // },\n\n  gcloudDatastoreNamespace: 'living-meta-analysis-v2-prod',\n  googleClientID: '186190585645-38o2mpd18bd53km7rbpnp1rb9gg9d5sg.apps.googleusercontent.com',\n  port: 8080,\n\n  // comment out, or delete, the following lines, to have LiMA running on HTTP only\n  // or start lima with the environment variable DISABLE_HTTPS=1\n  // httpsPort: 8443,\n  // httpsCert: '/etc/letsencrypt/live/lima.soc.port.ac.uk/fullchain.pem',\n  // httpsKey: '/etc/letsencrypt/live/lima.soc.port.ac.uk/privkey.pem',\n\n  // we hit the default of 100kb with one-click metaanalysis.\n  // recursive formulaParams are the largest offender (75% of total) but for now\n  // simply increase this until we understand any performance reason not to\n  jsonParserOptions: {\n    limit: '1024kb',\n  },\n};\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/errors/ForbiddenError.js","messages":[{"ruleId":"strict","severity":2,"message":"'use strict' is unnecessary inside of modules.","line":1,"column":1,"nodeType":"ExpressionStatement","messageId":"module","endLine":1,"endColumn":14,"fix":{"range":[0,13],"text":""}},{"ruleId":"func-names","severity":1,"message":"Unexpected unnamed function.","line":3,"column":24,"nodeType":"FunctionExpression","messageId":"unnamed","endLine":3,"endColumn":33}],"errorCount":1,"warningCount":1,"fixableErrorCount":1,"fixableWarningCount":0,"source":"'use strict';\n\nconst ForbiddenError = function (message, error) {\n  Error.call(this, message);\n  Error.captureStackTrace(this, this.constructor);\n  this.name = 'ForbiddenError';\n  this.message = message;\n  this.status = 403;\n  if (error) this.inner = error;\n};\n\nForbiddenError.prototype = Object.create(Error.prototype);\nForbiddenError.prototype.constructor = ForbiddenError;\n\nmodule.exports = ForbiddenError;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/errors/InternalError.js","messages":[{"ruleId":"strict","severity":2,"message":"'use strict' is unnecessary inside of modules.","line":1,"column":1,"nodeType":"ExpressionStatement","messageId":"module","endLine":1,"endColumn":14,"fix":{"range":[0,13],"text":""}},{"ruleId":"func-names","severity":1,"message":"Unexpected unnamed function.","line":3,"column":23,"nodeType":"FunctionExpression","messageId":"unnamed","endLine":3,"endColumn":32}],"errorCount":1,"warningCount":1,"fixableErrorCount":1,"fixableWarningCount":0,"source":"'use strict';\n\nconst InternalError = function (message, error) {\n  Error.call(this, message);\n  Error.captureStackTrace(this, this.constructor);\n  this.name = 'InternalError';\n  this.message = message;\n  this.status = 500;\n  if (error) this.inner = error;\n};\n\nInternalError.prototype = Object.create(Error.prototype);\nInternalError.prototype.constructor = InternalError;\n\nmodule.exports = InternalError;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/errors/NotFoundError.js","messages":[{"ruleId":"strict","severity":2,"message":"'use strict' is unnecessary inside of modules.","line":1,"column":1,"nodeType":"ExpressionStatement","messageId":"module","endLine":1,"endColumn":14,"fix":{"range":[0,13],"text":""}},{"ruleId":"func-names","severity":1,"message":"Unexpected unnamed function.","line":3,"column":23,"nodeType":"FunctionExpression","messageId":"unnamed","endLine":3,"endColumn":32}],"errorCount":1,"warningCount":1,"fixableErrorCount":1,"fixableWarningCount":0,"source":"'use strict';\n\nconst NotFoundError = function (message, error) {\n  Error.call(this, message);\n  Error.captureStackTrace(this, this.constructor);\n  this.name = 'NotFoundError';\n  this.message = message;\n  this.status = 404;\n  if (error) this.inner = error;\n};\n\nNotFoundError.prototype = Object.create(Error.prototype);\nNotFoundError.prototype.constructor = NotFoundError;\n\nmodule.exports = NotFoundError;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/errors/NotImplementedError.js","messages":[{"ruleId":"strict","severity":2,"message":"'use strict' is unnecessary inside of modules.","line":1,"column":1,"nodeType":"ExpressionStatement","messageId":"module","endLine":1,"endColumn":14,"fix":{"range":[0,13],"text":""}},{"ruleId":"func-names","severity":1,"message":"Unexpected unnamed function.","line":3,"column":29,"nodeType":"FunctionExpression","messageId":"unnamed","endLine":3,"endColumn":38}],"errorCount":1,"warningCount":1,"fixableErrorCount":1,"fixableWarningCount":0,"source":"'use strict';\n\nconst NotImplementedError = function (message, error) {\n  Error.call(this, message);\n  Error.captureStackTrace(this, this.constructor);\n  this.name = 'NotImplementedError';\n  this.message = message;\n  this.status = 501;\n  if (error) this.inner = error;\n};\n\nNotImplementedError.prototype = Object.create(Error.prototype);\nNotImplementedError.prototype.constructor = NotImplementedError;\n\nmodule.exports = NotImplementedError;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/errors/UnauthorizedError.js","messages":[{"ruleId":"strict","severity":2,"message":"'use strict' is unnecessary inside of modules.","line":1,"column":1,"nodeType":"ExpressionStatement","messageId":"module","endLine":1,"endColumn":14,"fix":{"range":[0,13],"text":""}},{"ruleId":"func-names","severity":1,"message":"Unexpected unnamed function.","line":3,"column":27,"nodeType":"FunctionExpression","messageId":"unnamed","endLine":3,"endColumn":36}],"errorCount":1,"warningCount":1,"fixableErrorCount":1,"fixableWarningCount":0,"source":"'use strict';\n\nconst UnauthorizedError = function (message, error) {\n  Error.call(this, message);\n  Error.captureStackTrace(this, this.constructor);\n  this.name = 'UnauthorizedError';\n  this.message = message;\n  this.status = 401;\n  if (error) this.inner = error;\n};\n\nUnauthorizedError.prototype = Object.create(Error.prototype);\nUnauthorizedError.prototype.constructor = UnauthorizedError;\n\nmodule.exports = UnauthorizedError;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/errors/ValidationError.js","messages":[{"ruleId":"strict","severity":2,"message":"'use strict' is unnecessary inside of modules.","line":1,"column":1,"nodeType":"ExpressionStatement","messageId":"module","endLine":1,"endColumn":14,"fix":{"range":[0,13],"text":""}},{"ruleId":"func-names","severity":1,"message":"Unexpected unnamed function.","line":3,"column":25,"nodeType":"FunctionExpression","messageId":"unnamed","endLine":3,"endColumn":34}],"errorCount":1,"warningCount":1,"fixableErrorCount":1,"fixableWarningCount":0,"source":"'use strict';\n\nconst ValidationError = function (message, error) {\n  Error.call(this, message);\n  Error.captureStackTrace(this, this.constructor);\n  this.name = 'ValidationError';\n  this.message = message;\n  this.status = 409;\n  if (error) this.inner = error;\n};\n\nValidationError.prototype = Object.create(Error.prototype);\nValidationError.prototype.constructor = ValidationError;\n\nmodule.exports = ValidationError;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/errors/index.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/index.js","messages":[{"ruleId":"strict","severity":2,"message":"'use strict' is unnecessary inside of modules.","line":7,"column":1,"nodeType":"ExpressionStatement","messageId":"module","endLine":7,"endColumn":14,"fix":{"range":[93,106],"text":""}},{"ruleId":"prefer-template","severity":2,"message":"Unexpected string concatenation.","line":9,"column":13,"nodeType":"BinaryExpression","messageId":"unexpectedStringConcatenation","endLine":9,"endColumn":52,"fix":{"range":[120,159],"text":"`LiMA server starting at ${  new Date()}`"}},{"ruleId":"sonarjs/no-duplicate-string","severity":2,"message":"Define a constant instead of duplicating this literal 9 times.","line":63,"column":48,"nodeType":"Literal","endLine":63,"endColumn":61},{"ruleId":"prefer-template","severity":2,"message":"Unexpected string concatenation.","line":156,"column":18,"nodeType":"BinaryExpression","messageId":"unexpectedStringConcatenation","endLine":156,"endColumn":65,"fix":{"range":[5026,5073],"text":"`${req.originalUrl.substring(0, end)  }/${  query}`"}},{"ruleId":"no-multiple-empty-lines","severity":2,"message":"More than 1 blank line not allowed.","line":160,"column":1,"nodeType":"Program","messageId":"consecutiveBlank","endLine":161,"endColumn":1,"fix":{"range":[5082,5083],"text":""}},{"ruleId":"sonarjs/no-duplicate-string","severity":2,"message":"Define a constant instead of duplicating this literal 4 times.","line":239,"column":20,"nodeType":"Literal","endLine":239,"endColumn":72},{"ruleId":"no-lonely-if","severity":2,"message":"Unexpected if as the only statement in an else block.","line":266,"column":7,"nodeType":"IfStatement","messageId":"unexpectedLonelyIf","endLine":293,"endColumn":8},{"ruleId":"sonarjs/prefer-object-literal","severity":2,"message":"Declare one or more properties of this object inside of the object literal syntax instead of using separate statements.","line":274,"column":17,"nodeType":"VariableDeclarator","endLine":274,"endColumn":33},{"ruleId":"prefer-template","severity":2,"message":"Unexpected string concatenation.","line":282,"column":61,"nodeType":"BinaryExpression","messageId":"unexpectedStringConcatenation","endLine":282,"endColumn":96,"fix":{"range":[9401,9436],"text":"`https://${  req.hostname  }${req.url}`"}}],"errorCount":9,"warningCount":0,"fixableErrorCount":5,"fixableWarningCount":0,"source":"/*\n * Living Meta-Analysis server.\n *\n * Author: Jacek Kopecky jacek.kopecky@port.ac.uk\n */\n\n'use strict';\n\nconsole.log('LiMA server starting at ' + new Date());\nconst express = require('express');\nconst googleOpenID = require('simple-google-openid');\nconst cors = require('cors');\nconst http = require('http');\nconst https = require('https');\nconst fs = require('fs');\nconst cookieParser = require('cookie-parser');\n\nconst config = require('./config');\n\nconst apiRoutes = require('./routes');\nconst redirectApi = require('./routes/redirected-api');\nconst storage = require('./storage');\nconst NotFoundError = require('./errors/NotFoundError');\n\nconst api = process.env.REDIRECT_API ? redirectApi : apiRoutes;\n\nstorage.setup();\n\nconst app = express({ caseSensitive: true });\napp.set('case sensitive routing', true);\napp.set('strict routing', true);\n\napp.use(googleOpenID(process.env.GOOGLE_CLIENT_ID || config.googleClientID));\napp.use(cookieParser());\n\n/* closed beta\n *\n *\n *    ####  #       ####   ####  ###### #####     #####  ###### #####   ##\n *   #    # #      #    # #      #      #    #    #    # #        #    #  #\n *   #      #      #    #  ####  #####  #    #    #####  #####    #   #    #\n *   #      #      #    #      # #      #    #    #    # #        #   ######\n *   #    # #      #    # #    # #      #    #    #    # #        #   #    #\n *    ####  ######  ####   ####  ###### #####     #####  ######   #   #    #\n *\n *\n */\n\n// in closed beta, restrict access to HTML pages:\n// if we don't get a valid closed-beta code in the lima-beta-code cookie,\n// we will redirect to a coming-soon page\n\nif (!process.env.TESTING) {\n  // regex for quickly checking for selected paths to be allowed: /css, /js, /img, /api, /version\n  const closedBetaAllowedURLs = /^\\/(css|js|img|api|version|\\.well-known)\\//;\n\n  app.use('/', async (req, res, next) => {\n    if (req.url.match(closedBetaAllowedURLs)) {\n      next();\n    } else if (await isValidBetaCode(req.cookies['lima-beta-code'])) {\n      next();\n    } else if (req.url === '/') {\n      res.sendFile('coming-soon.html', { root: './webpages/' });\n    } else {\n      res.redirect('/');\n    }\n  });\n}\n\nasync function isValidBetaCode(betaCodeCookies) {\n  if (betaCodeCookies) {\n    const codeKey = storage.shared.datastore.key(['BetaCode', betaCodeCookies]);\n    const codes = await storage.shared.datastore.get(codeKey);\n    if (codes[0]) return true;\n    return false;\n  } else {\n    return false;\n  }\n}\n\n/* routes\n *\n *\n *        #####   ####  #    # ##### ######  ####\n *        #    # #    # #    #   #   #      #\n *        #    # #    # #    #   #   #####   ####\n *        #####  #    # #    #   #   #           #\n *        #   #  #    # #    #   #   #      #    #\n *        #    #  ####   ####    #   ######  ####\n *\n *\n */\n\nif (config.demoApiDelay) {\n  // this is a delay for demonstration purposes so the server seems slow\n  app.use((req, res, next) => setTimeout(next, config.demoApiDelay));\n}\n\n// allow local testing of pages\napp.use(cors({ origin: 'http://localhost:8080' }));\n\napp.use('/api', api.router);\n\napp.get('/version', oneLineVersion);\napp.get('/version/', oneLineVersion);\napp.get('/version/log',\n  (req, res) => res.redirect('https://github.com/jacekkopecky/living-meta-analysis/commits/master'));\n\napp.get(['/profile', '/profile/*'],\n  (req, res) => res.sendFile('profileRedirect.html', { root: './webpages/' }));\n\napp.use('/', express.static('webpages', { extensions: ['html'] }));\n\n// the routes below would catch any of the above so need to come last\n\napp.use(`/:user(${config.USER_RE})/`, SLASH_URL);\napp.get(`/:user(${config.USER_RE})/`,\n  api.users.EXISTS_USER,\n  (req, res) => res.sendFile('profile/profile.html', { root: './webpages/' }));\n\napp.use(`/:user(${config.USER_RE})/:title(${config.URL_TITLE_RE})/`, SLASH_URL);\napp.get(`/:user(${config.USER_RE})/${config.NEW_PAPER_TITLE}/`,\n  api.users.EXISTS_USER,\n  (req, res) => res.sendFile('profile/paper.html', { root: './webpages/' }));\napp.get(`/:user(${config.USER_RE})/${config.NEW_META_TITLE}/`,\n  api.users.EXISTS_USER,\n  (req, res) => res.sendFile('react-dist/metaanalysis.html', { root: './webpages/' }));\napp.get(`/:user(${config.USER_RE})/:title(${config.URL_TITLE_RE})/`,\n  api.users.EXISTS_USER,\n  async (req, res, next) => {\n    try {\n      const kind = req.query.type || await api.getKindForTitle(req.params.user, req.params.title);\n      if (kind === 'paper') {\n        res.sendFile('profile/paper.html', { root: './webpages/' });\n      } else if (kind === 'metaanalysis') {\n        res.sendFile('react-dist/metaanalysis.html', { root: './webpages/' });\n      } else {\n        next(new NotFoundError());\n      }\n    } catch (error) {\n      next(new NotFoundError());\n    }\n  });\n\nfunction SLASH_URL(req, res, next) {\n  let end = req.originalUrl.indexOf('?');\n  let query = '';\n  if (end === -1) {\n    end = req.originalUrl.length;\n  } else {\n    query = req.originalUrl.substring(end);\n  }\n  if (req.originalUrl[end - 1] === '/') {\n    next();\n  } else {\n    res.redirect(req.originalUrl.substring(0, end) + '/' + query);\n  }\n}\n\n\n/* version\n *\n *\n *         #    # ###### #####   ####  #  ####  #    #\n *         #    # #      #    # #      # #    # ##   #\n *         #    # #####  #    #  ####  # #    # # #  #\n *         #    # #      #####       # # #    # #  # #\n *          #  #  #      #   #  #    # # #    # #   ##\n *           ##   ###### #    #  ####  #  ####  #    #\n *\n *\n */\n\nfunction oneLineVersion(req, res) {\n  res.sendFile('version.txt', { root: '.' });\n}\n\n/* error handling\n *\n *\n *  ###### #####  #####   ####  #####     #    #   ##   #    # #####  #      # #    #  ####\n *  #      #    # #    # #    # #    #    #    #  #  #  ##   # #    # #      # ##   # #    #\n *  #####  #    # #    # #    # #    #    ###### #    # # #  # #    # #      # # #  # #\n *  #      #####  #####  #    # #####     #    # ###### #  # # #    # #      # #  # # #  ###\n *  #      #   #  #   #  #    # #   #     #    # #    # #   ## #    # #      # #   ## #    #\n *  ###### #    # #    #  ####  #    #    #    # #    # #    # #####  ###### # #    #  ####\n *\n *\n */\n\napp.use(() => { throw new NotFoundError(); });\n\n// eslint-disable-next-line no-unused-vars\napp.use((err, req, res, next) => {\n  // eslint-disable-line no-unused-vars\n  if (err.status === 404) {\n    res.status(404).sendFile('404.html', { root: './webpages/' });\n  } else if (err.status === 401) {\n    res.set('WWW-Authenticate', 'Bearer realm=\"accounts.google.com\"');\n    res.status(401).sendFile('401.html', { root: './webpages/' });\n  } else if (err && err.status) {\n    res.status(err.status).send(err.message);\n  } else {\n    console.error('internal error');\n    console.error(err);\n    if (err && err.stack) console.error(err.stack);\n    res.status(500).send('internal server error');\n  }\n});\n\nprocess.on('unhandledRejection', (err) => {\n  console.error('unhandled promise, logging the error (if any)');\n  if (err) {\n    console.error(err.stack || err);\n  }\n});\n\n/* start server\n *\n *\n *    ####  #####   ##   #####  #####     ####  ###### #####  #    # ###### #####\n *   #        #    #  #  #    #   #      #      #      #    # #    # #      #    #\n *    ####    #   #    # #    #   #       ####  #####  #    # #    # #####  #    #\n *        #   #   ###### #####    #           # #      #####  #    # #      #####\n *   #    #   #   #    # #   #    #      #    # #      #   #   #  #  #      #   #\n *    ####    #   #    # #    #   #       ####  ###### #    #   ##   ###### #    #\n *\n *\n */\n\nconst port = process.env.PORT || config.port;\nlet httpsPort = process.env.PORT || config.httpsPort;\n\nconst serverReady = startServer();\n\nfunction startServer() {\n  return new Promise((resolve, reject) => {\n    if (process.env.TESTING) {\n      console.info('**************************************************');\n      console.info('');\n      console.info('RUNNING IN TESTING MODE');\n      console.info('');\n      console.info('**************************************************');\n    }\n\n    if (process.env.DISABLE_HTTPS || process.env.TESTING) {\n      if (!process.env.TESTING) {\n        console.warn('**************************************************');\n        console.warn('');\n        console.warn('WARNING: DISABLING HTTPS, THIS SERVER IS INSECURE');\n        console.warn('');\n        console.warn('**************************************************');\n      }\n      httpsPort = null;\n    }\n\n    if (!httpsPort) {\n      // only HTTP\n      http.createServer(app)\n        .listen(port, () => {\n          console.log(`LiMA server listening on insecure port ${port}`);\n          resolve();\n        });\n    } else {\n      // HTTPS; with HTTP redirecting to that\n      if (process.env.GAE_APPLICATION) {\n        http.createServer(app)\n          .listen(port, () => {\n            console.log(`LiMA server running on App Engine, Port: ${port}`);\n            resolve();\n          });\n      } else {\n        try {\n          const credentials = {};\n          credentials.key = fs.readFileSync(config.httpsKey, 'utf8');\n          credentials.cert = fs.readFileSync(config.httpsCert, 'utf8');\n          https.createServer(credentials, app).listen(httpsPort, () => {\n            console.log(`LiMA server listening on HTTPS port ${httpsPort}`);\n\n            // HTTP app will just redirect to HTTPS\n            const redirectApp = express();\n            redirectApp.get('*', (req, res) => res.redirect('https://' + req.hostname + req.url));\n\n            http.createServer(redirectApp).listen(port, () => {\n              console.log(`LiMA redirect server listening on port ${port}`);\n              resolve();\n            });\n          });\n        } catch (error) {\n          console.log(error);\n          reject(error);\n        }\n      }\n    }\n  });\n}\n\nmodule.exports = { serverReady };\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/lib/tools.js","messages":[{"ruleId":"strict","severity":2,"message":"'use strict' is unnecessary inside of modules.","line":1,"column":1,"nodeType":"ExpressionStatement","messageId":"module","endLine":1,"endColumn":14,"fix":{"range":[0,13],"text":""}},{"ruleId":"prefer-template","severity":2,"message":"Unexpected string concatenation.","line":34,"column":10,"nodeType":"BinaryExpression","messageId":"unexpectedStringConcatenation","endLine":34,"endColumn":18,"fix":{"range":[1270,1278],"text":"`${  val}`"}},{"ruleId":"no-restricted-globals","severity":2,"message":"Unexpected use of 'isNaN'.","line":40,"column":77,"nodeType":"Identifier","messageId":"defaultMessage","endLine":40,"endColumn":82}],"errorCount":3,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"'use strict';\n\nlet lastTime = 0;\n/*\n * Return a unique-enough timestamp.\n * We ensure uniqueness in these ways:\n * 1) at first, return the current Date.now()\n * 2) if Date.now() returns the same value as the last timestamp we created, return that value + 1;\n * 3) if the above has happened, Date.now() can actually return a lower value than the last time,\n *    in which case we simply return the next greater number;\n * 4) the above only works while the app is running, so if many timestamps are needed quickly,\n *    the timestamps get into the future, then if the app restarts quickly enough, it can start\n *    generating non-unique times, but generating timestamps is unlikely to happen a lot in a\n *    short time, and a quick restart followed by further generating of timestamps is very unlikely.\n */\nmodule.exports.uniqueNow = function uniqueNow() {\n  let currTime = Date.now();\n  if (lastTime >= currTime) {\n    currTime = lastTime + 1;\n  }\n  lastTime = currTime;\n  return currTime;\n};\n\nmodule.exports.string = function string(val) {\n  if (val === undefined || val === null) return val;\n\n  if (typeof val === 'object' || typeof val === 'function') {\n    console.error(`not a string: ${val}`);\n    console.error(new Error());\n    return undefined;\n  }\n\n  return '' + val;\n};\n\nmodule.exports.number = function number(val) {\n  if (val === undefined || val === null) return val;\n\n  if (val === '' || typeof val === 'object' || typeof val === 'function' || isNaN(val)) {\n    console.error(`not a number: ${val}`);\n    console.error(new Error());\n    return undefined;\n  }\n\n  return +val;\n};\n\nmodule.exports.bool = function bool(val) {\n  if (val === undefined || val === null) return val;\n\n  if (typeof val === 'object' || typeof val === 'function') {\n    console.error(`not a boolean: ${val}`);\n    console.error(new Error());\n    return undefined;\n  }\n\n  return !!val;\n};\n\nmodule.exports.array = function array(val, f) {\n  if (val === undefined || val === null) return val;\n\n  if (Array.isArray(val)) {\n    return val.map(f).filter(defined);\n  }\n\n  console.error(`not an array: ${val}`);\n  console.error(new Error());\n  return undefined;\n};\n\nmodule.exports.assoc = function assoc(val, f) {\n  if (val === undefined || val === null) return val;\n\n  if (typeof val === 'object') {\n    const retval = {};\n    for (const k of Object.keys(val)) {\n      retval[k] = f(val[k]);\n    }\n    return retval;\n  }\n\n  console.error(`not an object: ${val}`);\n  console.error(new Error());\n  return undefined;\n};\n\nfunction defined(x) { return x !== undefined; }\n\nmodule.exports.deleteCHECKvalues = function deleteCHECKvalues(obj) {\n  if (obj !== null && (typeof obj === 'object' || typeof obj === 'function')) {\n    for (const key of Object.keys(obj)) {\n      if (key.startsWith('CHECK')) delete obj[key];\n      else deleteCHECKvalues(obj[key]);\n    }\n  }\n};\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/routes/fake-auth.js","messages":[{"ruleId":"no-multiple-empty-lines","severity":2,"message":"More than 1 blank line not allowed.","line":24,"column":1,"nodeType":"Program","messageId":"consecutiveBlank","endLine":25,"endColumn":1,"fix":{"range":[565,566],"text":""}},{"ruleId":"sonarjs/prefer-object-literal","severity":2,"message":"Declare one or more properties of this object inside of the object literal syntax instead of using separate statements.","line":32,"column":11,"nodeType":"VariableDeclarator","endLine":32,"endColumn":23}],"errorCount":2,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"module.exports = (req, res, next) => {\n  if (req.user) {\n    next();\n    return;\n  }\n\n  let token;\n\n  // adapted from\n  // https://github.com/auth0/express-jwt/blob/4861bbb9d906f8fbd8c494fe2dbc4fda0d7865c6/lib/index.js#L62-70\n  // uses \"Fake\" rather than \"Bearer\" for the auth token\n  if (req.headers && req.headers.authorization) {\n    const parts = req.headers.authorization.split(' ');\n    if (parts.length === 2) {\n      const scheme = parts[0];\n      const credentials = parts[1];\n\n      if (scheme === 'Fake') {\n        token = credentials;\n      }\n    }\n  }\n\n\n  if (token) {\n    // remove @ signs\n    token = token.split('@').join('');\n  }\n\n  // check again in case the token was only composed of '@' signs\n  if (token) {\n    const profile = {};\n    profile.displayName = `Fake user ${token}`;\n    profile.name = {\n      familyName: 'Fake user',\n      givenName: token,\n    };\n\n    profile.emails = [{ value: `${token}@fake.example.org` }];\n\n    profile.id = token;\n    profile.provider = 'fake authentication module';\n\n    req.user = profile;\n    next();\n  } else {\n    next();\n  }\n};\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/routes/index.js","messages":[{"ruleId":"strict","severity":2,"message":"'use strict' is unnecessary inside of modules.","line":1,"column":1,"nodeType":"ExpressionStatement","messageId":"module","endLine":1,"endColumn":14,"fix":{"range":[0,13],"text":""}},{"ruleId":"import/order","severity":2,"message":"`simple-google-openid` import should occur before import of `../config`","line":7,"column":19,"nodeType":"CallExpression","endLine":7,"endColumn":50}],"errorCount":2,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"'use strict';\n\nconst express = require('express');\nconst config = require('../config');\n\n// guard middleware enforcing that a user is logged in\nlet GOOGLE_USER = require('simple-google-openid').guardMiddleware({ realm: 'accounts.google.com' });\nconst fakeAuthMiddleware = require('./fake-auth');\n\nconst api = express.Router({ caseSensitive: true });\nconst jsonBodyParser = express.json(config.jsonParserOptions);\n\nconst metaanalyses = require('./metaanalyses');\nconst papers = require('./papers');\nconst users = require('./users');\n\nconst storage = require('../storage');\n\nif (process.env.TESTING) {\n  // Fake middleware while in testing mode to allow all requests\n  GOOGLE_USER = (req, res, next) => next();\n  /*\n  * allows fake bearer tokens for authentication\n  * something like:\n  *\n  * Authorization: Fake jack\n  *\n  * this will be interpreted as user jack@fake.example.org\n  *\n  */\n  api.use(fakeAuthMiddleware);\n}\n\n/* -------------------------------------------------------------------------- */\n/*                                   Routes                                   */\n/* -------------------------------------------------------------------------- */\n\n// todo top users/papers/metaanalyses would currently return all of them, which is a privacy issue\n// we may need editorial control, tags like 'public' or absence of tags like 'private'\n// api.get('/topusers', listTopUsers);\n// api.get('/toppapers', listTopPapers);\n\napi.get('/', (req, res) => res.redirect('/docs/api'));\n\n/* ---------------------------------- Users --------------------------------- */\n\napi.get('/user', GOOGLE_USER, users.checkUser);\napi.post('/user', GOOGLE_USER, jsonBodyParser, users.saveUser);\n\napi.get(`/profile/:user(${config.USER_RE})`, users.returnUserProfile);\n\n/* --------------------------------- Papers --------------------------------- */\n\n// todo include /titles to return all titles\napi.get('/titles', listTitles);\napi.get(`/papers/:user(${config.USER_RE})/`, papers.listPapersForUser);\n\napi.get(`/papers/:user(${config.USER_RE})/:title(${config.URL_TITLE_RE})/`, papers.getPaperVersion);\napi.get(`/papers/:user(${config.USER_RE})/:title(${config.URL_TITLE_RE})/:time([0-9]+)/`, papers.getPaperVersion);\napi.post(`/papers/:user(${config.USER_RE})/:title(${config.URL_TITLE_RE})/`, GOOGLE_USER, users.SAME_USER, jsonBodyParser, papers.savePaper);\n// todo above, a user that isn't SAME_USER should be able to submit new comments\n\n/* ------------------------------ Metaanalyses ------------------------------ */\n\napi.get('/topmetaanalyses', metaanalyses.listTopMetaanalyses);\napi.get(`/metaanalyses/:user(${config.USER_RE})`, metaanalyses.listMetaanalysesForUser);\napi.get(`/metaanalyses/:user(${config.USER_RE})/:title(${config.URL_TITLE_RE})/`, metaanalyses.getMetaanalysisVersion);\napi.get(`/metaanalyses/:user(${config.USER_RE})/:title(${config.URL_TITLE_RE})/:time([0-9]+)/`, metaanalyses.getMetaanalysisVersion);\napi.post(`/metaanalyses/:user(${config.USER_RE})/:title(${config.URL_TITLE_RE})/`, GOOGLE_USER, users.SAME_USER, jsonBodyParser, metaanalyses.saveMetaanalysis);\n\n/* -------------------------------------------------------------------------- */\n/*                                   Shared                                   */\n/* -------------------------------------------------------------------------- */\n\n// TODO: Test/Review function\nasync function getKindForTitle(user, title) {\n  const metaanalyses = await storage.metaanalyses.getMetaanalysisByTitle(\n    user,\n    title,\n  );\n\n  if (metaanalyses) return 'metaanalysis';\n  const paper = await storage.papers.getPaperByTitle(user, title);\n  if (paper) return 'paper';\n  throw new Error('Nothing found');\n}\n\n// todo: implement using a query\nfunction listTitles(req, res) {\n  res.send([]);\n}\n\nmodule.exports = {\n  router: api,\n  metaanalyses,\n  papers,\n  users,\n  getKindForTitle,\n};\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/routes/metaanalyses.js","messages":[{"ruleId":"object-curly-newline","severity":2,"message":"Expected a line break after this opening brace.","line":1,"column":7,"nodeType":"ObjectPattern","messageId":"expectedLinebreakAfterOpeningBrace","endLine":1,"endColumn":8,"fix":{"range":[7,7],"text":"\n"}},{"ruleId":"object-curly-newline","severity":2,"message":"Expected a line break before this closing brace.","line":1,"column":76,"nodeType":"ObjectPattern","messageId":"expectedLinebreakBeforeClosingBrace","endLine":1,"endColumn":77,"fix":{"range":[75,75],"text":"\n"}},{"ruleId":"max-len","severity":2,"message":"This line has a length of 123. Maximum allowed is 100.","line":28,"column":1,"nodeType":"Program","messageId":"max","endLine":28,"endColumn":124},{"ruleId":"max-len","severity":2,"message":"This line has a length of 142. Maximum allowed is 100.","line":39,"column":1,"nodeType":"Program","messageId":"max","endLine":39,"endColumn":143},{"ruleId":"implicit-arrow-linebreak","severity":2,"message":"Expected no linebreak before this expression.","line":102,"column":7,"nodeType":"Identifier","messageId":"unexpected","endLine":102,"endColumn":13,"fix":{"range":[3734,3741],"text":" "}},{"ruleId":"function-paren-newline","severity":2,"message":"Unexpected newline before ')'.","line":103,"column":5,"nodeType":"Punctuator","messageId":"unexpectedBefore","endLine":103,"endColumn":6,"fix":{"range":[3799,3804],"text":""}},{"ruleId":"max-len","severity":2,"message":"This line has a length of 107. Maximum allowed is 100.","line":114,"column":1,"nodeType":"Program","messageId":"max","endLine":114,"endColumn":108},{"ruleId":"max-len","severity":2,"message":"This line has a length of 103. Maximum allowed is 100.","line":127,"column":1,"nodeType":"Program","messageId":"max","endLine":127,"endColumn":104}],"errorCount":8,"warningCount":0,"fixableErrorCount":4,"fixableWarningCount":0,"source":"const { NotFoundError, ValidationError, NotImplementedError, InternalError } = require('../errors');\nconst storage = require('../storage');\nconst config = require('../config');\nconst tools = require('../lib/tools');\nconst { extractPaperForSending, extractReceivedComment, extractReceivedColumnEntry } = require('./papers');\n\n/* -------------------------------------------------------------------------- */\n/*                               Route Handlers                               */\n/* -------------------------------------------------------------------------- */\n\nasync function listMetaanalysesForUser(req, res, next) {\n  try {\n    const mas = await storage.metaanalyses.getMetaanalysesEnteredBy(req.params.user);\n    if (mas.length === 0) throw new Error('no metaanalyses found');\n\n    const retval = [];\n    mas.forEach((m) => {\n      retval.push(extractMetaanalysisForSending(m, false, req.params.user));\n    });\n    res.json(retval);\n  } catch (error) {\n    next(new NotFoundError());\n  }\n}\n\nasync function getMetaanalysisVersion(req, res, next) {\n  try {\n    const ma = await storage.metaanalyses.getMetaanalysisByTitle(req.params.user, req.params.title, req.params.time, true);\n    const username = await storage.users.getUsernameOfUser(ma.enteredBy);\n    res.json(extractMetaanalysisForSending(ma, true, req.params.user, username));\n  } catch (e) {\n    next(e && e.status ? e : new NotFoundError());\n  }\n}\n\nasync function saveMetaanalysis(req, res, next) {\n  // extract from incoming data stuff that is allowed\n  try {\n    const ma = await storage.metaanalyses.saveMetaanalysis(extractReceivedMetaanalysis(req.body), req.user.emails[0].value, req.params.title);\n    res.json(extractMetaanalysisForSending(ma, false, req.params.user));\n  } catch (e) {\n    console.log(e);\n    if (e instanceof ValidationError || e instanceof NotImplementedError) {\n      next(e);\n    } else {\n      next(new InternalError(e));\n    }\n  }\n}\n\nasync function listTopMetaanalyses(req, res, next) {\n  try {\n    const mas = await storage.metaanalyses.listMetaanalyses();\n\n    const retval = [];\n    for (const ma of mas) {\n      retval.push({\n        title: ma.title,\n        enteredBy: ma.enteredBy,\n      });\n    }\n    res.json(retval);\n  } catch (error) {\n    console.log(error);\n\n    next(new InternalError());\n  }\n}\n\n/* -------------------------------------------------------------------------- */\n/*                                   Helpers                                  */\n/* -------------------------------------------------------------------------- */\n\nfunction extractMetaanalysisForSending(storageMetaanalysis, includePapers, user, username) {\n  const retval = {\n    id: storageMetaanalysis.id,\n    title: storageMetaanalysis.title,\n    enteredBy: storageMetaanalysis.enteredBy,\n    enteredByUsername: username,\n    ctime: storageMetaanalysis.ctime,\n    mtime: storageMetaanalysis.mtime,\n    published: storageMetaanalysis.published,\n    description: storageMetaanalysis.description,\n    tags: storageMetaanalysis.tags,\n    columns: storageMetaanalysis.columns,\n    paperOrder: storageMetaanalysis.paperOrder,\n    hiddenCols: storageMetaanalysis.hiddenCols,\n    hiddenExperiments: storageMetaanalysis.hiddenExperiments,\n    excludedExperiments: storageMetaanalysis.excludedExperiments,\n    aggregates: storageMetaanalysis.aggregates,\n    groupingColumn: storageMetaanalysis.groupingColumn,\n    groupingAggregates: storageMetaanalysis.groupingAggregates,\n    graphs: storageMetaanalysis.graphs,\n    // todo comments in various places?\n  };\n\n  if (user) retval.apiurl = apiMetaanalysisURL(user, retval.title);\n\n  if (includePapers && storageMetaanalysis.papers) {\n    retval.papers = [];\n    storageMetaanalysis.papers.forEach((p) =>\n      retval.papers.push(extractPaperForSending(p, true, user)),\n    );\n  }\n\n  return retval;\n}\n\nfunction extractReceivedMetaanalysis(receivedMetaanalysis) {\n  // expecting receivedMetaanalysis to come from JSON.parse()\n  const retval = {\n    id: tools.string(receivedMetaanalysis.id), // identifies the MA to be changed\n    title: tools.string(receivedMetaanalysis.title),\n    CHECKenteredBy: tools.string(receivedMetaanalysis.enteredBy), // can't be changed but should be checked\n    CHECKctime: tools.number(receivedMetaanalysis.ctime), // can't be changed but should be checked\n    // mtime: tools.number(receivedMetaanalysis.mtime),              // will be updated\n    published: tools.string(receivedMetaanalysis.published),\n    description: tools.string(receivedMetaanalysis.description),\n    tags: tools.array(receivedMetaanalysis.tags, tools.string),\n    columns: tools.array(receivedMetaanalysis.columns, extractReceivedMetaanalysisColumnEntry),\n    paperOrder: tools.array(receivedMetaanalysis.paperOrder, tools.string),\n    hiddenCols: tools.array(receivedMetaanalysis.hiddenCols, tools.string),\n    hiddenExperiments: tools.array(receivedMetaanalysis.hiddenExperiments, tools.string),\n    excludedExperiments: tools.array(receivedMetaanalysis.excludedExperiments, tools.string),\n    aggregates: tools.array(receivedMetaanalysis.aggregates, extractReceivedAggregate),\n    groupingColumn: tools.string(receivedMetaanalysis.groupingColumn),\n    groupingAggregates: tools.array(receivedMetaanalysis.groupingAggregates, extractReceivedAggregate),\n    graphs: tools.array(receivedMetaanalysis.graphs, extractReceivedGraph),\n  };\n\n  return retval;\n}\n\nfunction extractReceivedMetaanalysisColumnEntry(recCol) {\n  const col = extractReceivedColumnEntry(recCol);\n  if (col) {\n    col.sourceColumnMap = tools.assoc(recCol.sourceColumnMap, tools.string);\n    delete col.obsoleteIDForMigration;\n  }\n\n  return col;\n}\n\nfunction extractReceivedAggregate(recAggr) {\n  // expecting receivedAggregate to come from JSON.parse()\n  return {\n    formula: tools.string(recAggr.formula),\n    comments: tools.array(recAggr.comments, extractReceivedComment),\n    title: tools.string(recAggr.title),\n  };\n}\n\nfunction extractReceivedGraph(recGraph) {\n  // uses a formula string just like computed columns and aggregates\n  return {\n    formula: tools.string(recGraph.formula),\n    comments: tools.array(recGraph.comments, extractReceivedComment),\n    title: tools.string(recGraph.title),\n  };\n}\n\nfunction apiMetaanalysisURL(user, title) {\n  return `/api/metaanalyses/${user}/${title || config.NEW_META_TITLE}`;\n}\n\nmodule.exports = {\n  listMetaanalysesForUser,\n  getMetaanalysisVersion,\n  saveMetaanalysis,\n  listTopMetaanalyses,\n};\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/routes/papers.js","messages":[{"ruleId":"object-curly-newline","severity":2,"message":"Expected a line break after this opening brace.","line":1,"column":7,"nodeType":"ObjectPattern","messageId":"expectedLinebreakAfterOpeningBrace","endLine":1,"endColumn":8,"fix":{"range":[7,7],"text":"\n"}},{"ruleId":"object-curly-newline","severity":2,"message":"Expected a line break before this closing brace.","line":1,"column":76,"nodeType":"ObjectPattern","messageId":"expectedLinebreakBeforeClosingBrace","endLine":1,"endColumn":77,"fix":{"range":[75,75],"text":"\n"}},{"ruleId":"arrow-parens","severity":2,"message":"Expected parentheses around arrow function argument.","line":16,"column":20,"nodeType":"ArrowFunctionExpression","messageId":"expectedParens","endLine":16,"endColumn":21,"fix":{"range":[705,706],"text":"(p)"}},{"ruleId":"function-paren-newline","severity":2,"message":"Expected newline before ')'.","line":41,"column":23,"nodeType":"Punctuator","messageId":"expectedBefore","endLine":41,"endColumn":24,"fix":{"range":[1485,1485],"text":"\n"}}],"errorCount":4,"warningCount":0,"fixableErrorCount":4,"fixableWarningCount":0,"source":"const { NotFoundError, ValidationError, NotImplementedError, InternalError } = require('../errors');\nconst storage = require('../storage');\nconst config = require('../config');\nconst tools = require('../lib/tools');\n\n/* -------------------------------------------------------------------------- */\n/*                               Route Handlers                               */\n/* -------------------------------------------------------------------------- */\n\nasync function listPapersForUser(req, res, next) {\n  try {\n    const papers = await storage.papers.getPapersEnteredBy(req.params.user);\n    if (papers.length === 0) throw new Error('no papers found');\n\n    const retval = [];\n    papers.forEach(p => {\n      retval.push(extractPaperForSending(p, false, req.params.user));\n    });\n    res.json(retval);\n  } catch (error) {\n    next(new NotFoundError());\n  }\n}\n\nasync function getPaperVersion(req, res, next) {\n  try {\n    const paper = await storage.papers.getPaperByTitle(req.params.user, req.params.title);\n    const username = await storage.users.getUsernameOfUser(paper.enteredBy);\n    res.json(extractPaperForSending(paper, true, req.params.user, username));\n  } catch (e) {\n    next(e.status ? e : new NotFoundError());\n  }\n}\n\nasync function savePaper(req, res, next) {\n  // extract from incoming data stuff that is allowed\n  try {\n    const p = await storage.papers.savePaper(\n      extractReceivedPaper(req.body),\n      req.user.emails[0].value,\n      req.params.title);\n    res.json(extractPaperForSending(p, true, req.params.user));\n  } catch (e) {\n    if (e instanceof ValidationError || e instanceof NotImplementedError) {\n      next(e);\n    } else {\n      next(new InternalError(e));\n    }\n  }\n}\n\n/* -------------------------------------------------------------------------- */\n/*                                   Helpers                                  */\n/* -------------------------------------------------------------------------- */\n\nfunction extractPaperForSending(storagePaper, includeDataValues, user, username) {\n  const retval = {\n    id: storagePaper.id,\n    title: storagePaper.title,\n    enteredBy: storagePaper.enteredBy,\n    enteredByUsername: username,\n    ctime: storagePaper.ctime,\n    mtime: storagePaper.mtime,\n    reference: storagePaper.reference,\n    description: storagePaper.description,\n    link: storagePaper.link,\n    doi: storagePaper.doi,\n    tags: storagePaper.tags,\n    // todo comments in various places?\n  };\n\n  if (user) retval.apiurl = apiPaperURL(user, retval.title);\n\n  if (includeDataValues) {\n    retval.experiments = storagePaper.experiments;\n    retval.columns = storagePaper.columns;\n    retval.hiddenCols = storagePaper.hiddenCols;\n  }\n\n  return retval;\n}\n\nfunction extractReceivedPaper(receivedPaper) {\n  // expecting receivedPaper to come from JSON.parse()\n  const retval = {\n    id: tools.string(receivedPaper.id), // identifies the paper to be changed\n    title: tools.string(receivedPaper.title),\n    CHECKenteredBy: tools.string(receivedPaper.enteredBy), // can't be changed but should be checked\n    CHECKctime: tools.number(receivedPaper.ctime), // can't be changed but should be checked\n    // mtime: tools.number(receivedPaper.mtime),           // will be updated\n    reference: tools.string(receivedPaper.reference),\n    description: tools.string(receivedPaper.description),\n    link: tools.string(receivedPaper.link),\n    doi: tools.string(receivedPaper.doi),\n    tags: tools.array(receivedPaper.tags, tools.string),\n    experiments: tools.array(receivedPaper.experiments, extractReceivedExperiment),\n    columns: tools.array(receivedPaper.columns, extractReceivedColumnEntry),\n    hiddenCols: tools.array(receivedPaper.hiddenCols, tools.string),\n  };\n\n  // todo anything else recently added to the data\n\n  return retval;\n}\n\nfunction extractReceivedExperiment(receivedExperiment) {\n  const retval = {\n    title: tools.string(receivedExperiment.title),\n    CHECKenteredBy: tools.string(receivedExperiment.enteredBy),\n    CHECKctime: tools.number(receivedExperiment.ctime),\n    description: tools.string(receivedExperiment.description),\n    data: tools.assoc(receivedExperiment.data, extractReceivedExperimentDatum),\n    comments: tools.array(receivedExperiment.comments, extractReceivedComment),\n  };\n  return retval;\n}\n\nfunction extractReceivedExperimentDatum(receivedDatum) {\n  const retval = {\n    value: tools.string(receivedDatum.value),\n    CHECKenteredBy: tools.string(receivedDatum.enteredBy),\n    CHECKctime: tools.number(receivedDatum.ctime),\n    comments: tools.array(receivedDatum.comments, extractReceivedComment),\n  };\n  return retval;\n}\n\nfunction extractReceivedComment(receivedComment) {\n  const retval = {\n    CHECKby: tools.string(receivedComment.by),\n    CHECKctime: tools.number(receivedComment.ctime),\n    onVersionBy: tools.string(receivedComment.onVersionBy),\n    text: tools.string(receivedComment.text),\n    hidden: tools.bool(receivedComment.hidden),\n  };\n  return retval;\n}\n\nfunction extractReceivedColumnEntry(recCol) {\n  if (typeof recCol === 'object') {\n    return {\n      id: tools.string(recCol.id),\n      title: tools.string(recCol.title),\n      description: tools.string(recCol.description),\n      type: tools.string(recCol.type),\n      formula: tools.string(recCol.formula),\n      comments: tools.array(recCol.comments, extractReceivedComment),\n      obsoleteIDForMigration: tools.string(recCol.obsoleteIDForMigration),\n    };\n  }\n\n  return undefined;\n}\n\nfunction apiPaperURL(user, title) {\n  return `/api/papers/${user}/${title || config.NEW_PAPER_TITLE}`;\n}\n\nmodule.exports = {\n  listPapersForUser,\n  getPaperVersion,\n  savePaper,\n  extractPaperForSending,\n  extractReceivedColumnEntry,\n  extractReceivedComment,\n};\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/routes/redirected-api.js","messages":[{"ruleId":"strict","severity":2,"message":"'use strict' is unnecessary inside of modules.","line":12,"column":1,"nodeType":"ExpressionStatement","messageId":"module","endLine":12,"endColumn":14,"fix":{"range":[352,365],"text":""}}],"errorCount":1,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/*\n * For some testing, we don't need to run the API locally,\n * so we don't need to have access to the datastore.\n *\n * This file is a redirecting version of the API: it redirects all calls\n * to the site in process.env.REDIRECT_API (in the format\n * https://lima.soc.port.ac.uk - no trailing slash).\n *\n * It also fakes several local functions.\n */\n\n'use strict';\n\nconst express = require('express');\n\nconst URL = process.env.REDIRECT_API;\n\nconst api = express.Router({ caseSensitive: true });\napi.use((req, res) => {\n  res.redirect(307, URL + req.originalUrl);\n});\n\n// in testing we expect every user to exist\nfunction EXISTS_USER(req, res, next) {\n  next();\n}\n\n// in testing we expect every request to /user/thing either to have ?type or be a metaanalysis\nfunction getKindForTitle() {\n  return 'metaanalysis';\n}\n\n// mirror the exports of index.js\nmodule.exports = {\n  router: api,\n  metaanalyses: {},\n  papers: {},\n  users: { EXISTS_USER },\n  getKindForTitle,\n};\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/routes/users.js","messages":[{"ruleId":"max-len","severity":2,"message":"This line has a length of 104. Maximum allowed is 100.","line":11,"column":1,"nodeType":"Program","messageId":"max","endLine":11,"endColumn":105},{"ruleId":"max-len","severity":2,"message":"This line has a length of 103. Maximum allowed is 100.","line":21,"column":1,"nodeType":"Program","messageId":"max","endLine":21,"endColumn":104},{"ruleId":"operator-linebreak","severity":2,"message":"'||' should be placed at the beginning of the line.","line":28,"column":68,"nodeType":"LogicalExpression","messageId":"operatorAtBeginning","endLine":28,"endColumn":70,"fix":{"range":[1316,1326],"text":"\n      || "}},{"ruleId":"operator-linebreak","severity":2,"message":"'||' should be placed at the beginning of the line.","line":29,"column":54,"nodeType":"LogicalExpression","messageId":"operatorAtBeginning","endLine":29,"endColumn":56,"fix":{"range":[1372,1382],"text":"\n      || "}}],"errorCount":4,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"const { UnauthorizedError, NotFoundError, InternalError } = require('../errors');\nconst storage = require('../storage');\nconst tools = require('../lib/tools');\n\n/* -------------------------------------------------------------------------- */\n/*                               Route Handlers                               */\n/* -------------------------------------------------------------------------- */\n\nasync function saveUser(req, res, next) {\n  const user = extractReceivedUser(req.user);\n  user.mtime = Date.now(); // update modification time - this is the last time the user agreed to T&C&PP\n  user.username = tools.string(req.body.username);\n  try {\n    const storageUser = await storage.users.saveUser(user.email, user);\n    res.json(extractUserForSending(storageUser));\n  } catch (err) {\n    next(err instanceof Error ? err : new InternalError(err));\n  }\n}\n\n// Check that the user is known to LiMA and that LiMA has up-to-date values from the identity provider.\nasync function checkUser(req, res, next) {\n  const email = req.user.emails[0].value;\n  try {\n    const storageUser = await storage.users.getUser(email);\n    // Check whether there are any changes to the Google Object\n    const strippedGoogleUser = extractReceivedUser(req.user);\n    if (strippedGoogleUser.displayName !== storageUser.displayName ||\n      strippedGoogleUser.email !== storageUser.email ||\n      JSON.stringify(strippedGoogleUser.photos) !== JSON.stringify(storageUser.photos)) {\n      Object.assign(storageUser, strippedGoogleUser);\n      try {\n        const savedUser = await storage.users.saveUser(storageUser.email, storageUser);\n        res.json(extractUserForSending(savedUser));\n      } catch (err) {\n        next(new InternalError(err));\n      }\n    } else {\n      res.json(extractUserForSending(storageUser));\n    }\n  } catch (error) {\n    // User is not known to LiMA, return 401 to be caught by caller\n    next(new UnauthorizedError('Please register with LiMA at /register'));\n  }\n}\n\nasync function returnUserProfile(req, res, next) {\n  try {\n    const user = await storage.users.getUser(req.params.user);\n    res.json(extractUserForSending(user));\n  } catch (err) {\n    if (err && err.status) {\n      next(err);\n    } else {\n      next(new NotFoundError());\n    }\n  }\n}\n\n/* -------------------------------------------------------------------------- */\n/*                                 Middleware                                 */\n/* -------------------------------------------------------------------------- */\n\nasync function SAME_USER(req, res, next) {\n  const email = req.user.emails[0].value;\n  try {\n    const user = await storage.users.getUser(email);\n    if (user.email === req.params.user || user.username === req.params.user) {\n      next();\n    } else {\n      throw new Error();\n    }\n  } catch (error) {\n    next(new UnauthorizedError('Please register with LiMA at /register'));\n  }\n}\n\nasync function EXISTS_USER(req, res, next) {\n  try {\n    await storage.users.getUser(req.params.user);\n    next();\n  } catch (error) {\n    next(new NotFoundError());\n  }\n}\n\n/* -------------------------------------------------------------------------- */\n/*                                   Helpers                                  */\n/* -------------------------------------------------------------------------- */\n\nfunction extractReceivedUser(receivedUser) {\n  // expecting receivedUser to be a Javascript object\n  const retval = {\n    displayName: tools.string(receivedUser.displayName),\n    email: tools.string(receivedUser.emails[0].value),\n    photos: tools.array(receivedUser.photos, extractReceivedPhoto),\n  };\n\n  return retval;\n}\n\nfunction extractReceivedPhoto(recPhoto) {\n  const retval = {\n    value: tools.string(recPhoto.value),\n  };\n  return retval;\n}\n\n/**\n * @param {User} user\n */\nfunction extractUserForSending(user) {\n  const retval = {\n    displayName: user.displayName,\n    name: user.name,\n    email: user.email,\n    photos: user.photos,\n    joined: user.ctime,\n    username: user.username,\n  };\n  return retval;\n}\n\nmodule.exports = {\n  SAME_USER,\n  EXISTS_USER,\n  saveUser,\n  checkUser,\n  returnUserProfile,\n};\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/storage/index.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/storage/metaanalyses.js","messages":[{"ruleId":"no-multiple-empty-lines","severity":2,"message":"More than 1 blank line not allowed.","line":7,"column":1,"nodeType":"Program","messageId":"consecutiveBlank","endLine":8,"endColumn":1,"fix":{"range":[283,284],"text":""}},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 19 to the 15 allowed.","line":92,"column":16,"nodeType":null,"endLine":92,"endColumn":32},{"ruleId":"no-multiple-empty-lines","severity":2,"message":"More than 1 blank line not allowed.","line":107,"column":1,"nodeType":"Program","messageId":"consecutiveBlank","endLine":108,"endColumn":1,"fix":{"range":[3406,3407],"text":""}},{"ruleId":"prefer-template","severity":2,"message":"Unexpected string concatenation.","line":112,"column":23,"nodeType":"BinaryExpression","messageId":"unexpectedStringConcatenation","endLine":112,"endColumn":40,"fix":{"range":[3555,3572],"text":"`/id/ma/${  ctime}`"}},{"ruleId":"no-multi-assign","severity":2,"message":"Unexpected chained assignment.","line":114,"column":26,"nodeType":"AssignmentExpression","messageId":"unexpectedChain","endLine":114,"endColumn":52},{"ruleId":"prefer-template","severity":2,"message":"Unexpected string concatenation.","line":156,"column":24,"nodeType":"BinaryExpression","messageId":"unexpectedStringConcatenation","endLine":156,"endColumn":66,"fix":{"range":[5400,5442],"text":"`${metaanalysis.id  }/${  metaanalysis.mtime}`"}}],"errorCount":6,"warningCount":0,"fixableErrorCount":4,"fixableWarningCount":0,"source":"const { datastore, checkForDisallowedChanges, fillByAndCtimes } = require('./shared');\nconst users = require('./users');\nconst tools = require('../lib/tools');\nconst config = require('../config');\nconst { ValidationError, NotImplementedError, InternalError } = require('../errors');\n\n\nasync function getMetaanalysesEnteredBy(user) {\n  // todo also return metaanalyses contributed to by `email`\n  if (!user) {\n    throw new Error('user parameter required');\n  }\n\n  const email = await users.getEmailAddressOfUser(user);\n  const query = datastore.createQuery('Metaanalysis').filter('enteredBy', '=', email);\n\n  try {\n    const [metaanalyses] = await datastore.runQuery(query);\n    return metaanalyses;\n  } catch (error) {\n    throw new InternalError();\n  }\n}\n\nasync function getMetaanalysisByTitle(user, title, time, includePapers) {\n  // todo if time is specified, compute a version as of that time\n  if (time) {\n    throw new NotImplementedError('getMetaanalysisByTitle with time not implemented');\n  }\n\n  // todo different users can use different titles for the same thing\n\n  if (title === config.NEW_META_TITLE) {\n    const email = await users.getEmailAddressOfUser(user);\n    return newMetaanalysis(email);\n  }\n\n  const query = datastore.createQuery('Metaanalysis').filter('title', '=', title);\n\n  const [[metaanalyses]] = await datastore.runQuery(query);\n  if (metaanalyses) {\n    let ma = metaanalyses;\n    if (includePapers) {\n      ma = await getMetaanalysisWithPapers(ma, time);\n    }\n    return ma;\n  }\n\n  throw new Error('No metaanalysis found');\n}\n\nasync function getMetaanalysisWithPapers(ma, time) {\n  if (time) {\n    throw new NotImplementedError('getMetaanalysisWithPapers with time not implemented');\n  }\n\n  if (!ma.paperOrder || ma.paperOrder.length === 0) return ma;\n\n  // use a shallow copy of ma\n  ma = { ...ma };\n\n  const createDatastoreKey = (id) => datastore.key(['Paper', id]);\n  const keys = ma.paperOrder.map(createDatastoreKey);\n\n  const [papers] = await datastore.get(keys);\n\n  ma.papers = [];\n  // populate the papers array in the order of ma.paperOrder\n  papers.forEach((p) => {\n    const index = ma.paperOrder.indexOf(p.id);\n    if (index !== -1) ma.papers[index] = p;\n  });\n\n  return ma;\n}\n\nasync function listMetaanalyses() {\n  const query = datastore.createQuery('Metaanalysis');\n  const [retval] = await datastore.runQuery(query);\n  return retval;\n}\n\nfunction newMetaanalysis(email) {\n  const time = tools.uniqueNow();\n  return {\n    enteredBy: email,\n    ctime: time,\n    mtime: time,\n  };\n}\n\nasync function saveMetaanalysis(metaanalysis, email, origTitle, options) {\n  options = options || {};\n  // todo multiple users' views on one metaanalysis\n  // compute this user's version of this metaanalysis, as it is in the database\n  // compute a diff between what's submitted and the user's version of this metaanalysis\n  // detect any update conflicts (how?)\n  // add the diff to the metaanalysis as a changeset\n  // update the metaanalysis data only if the user is the one who it's enteredBy\n  // only allow editing a comment if it's the last one by this user\n  //   (must allow editing the last comment by this user in case in the meantime another user\n  //    has added another comment)\n\n  // the following serializes this save after the previous one, whether it fails or succeeds\n  // this way we can't have two concurrent saves create metaanalyses with the same title\n\n\n  // prepare the metaanalysis for saving\n  const ctime = tools.uniqueNow();\n  let original = null;\n  if (!metaanalysis.id) {\n    metaanalysis.id = '/id/ma/' + ctime;\n    metaanalysis.enteredBy = email;\n    metaanalysis.ctime = metaanalysis.mtime = ctime;\n  } else {\n    const query = datastore.createQuery('Metaanalysis').filter('id', '=', metaanalysis.id);\n    const [[retval]] = await datastore.runQuery(query);\n    original = retval || null;\n\n    if (options.restoring) {\n      // metaanalysis is a metaanalysis we're restoring from some other datastore\n      // reject the save if we already have it\n      if (original) throw new Error(`metaanalysis ${metaanalysis.id} already exists`);\n      // otherwise save unchanged\n    } else {\n      // metaanalysis overwrites an existing metaanalysis\n      if (!original || origTitle !== original.title) {\n        throw new ValidationError(\n          `failed saveMetaanalysis: did not find id ${metaanalysis.id} with title ${origTitle}`,\n        );\n      }\n      if (email !== original.enteredBy) {\n        throw new NotImplementedError('not implemented saving someone else\\'s metaanalysis');\n      }\n\n      metaanalysis.enteredBy = original.enteredBy;\n      metaanalysis.ctime = original.ctime;\n      metaanalysis.mtime = tools.uniqueNow();\n    }\n  }\n\n  // validate incoming data\n  await checkForDisallowedChanges(metaanalysis, original);\n\n  // put ctime and enteredBy on every experiment, datum, and comment that doesn't have them\n  fillByAndCtimes(metaanalysis, original, email);\n\n  // for now, we choose to ignore if the incoming metaanalysis specifies\n  // the wrong immutable values here do not save any of the validation values\n  tools.deleteCHECKvalues(metaanalysis);\n\n  // save the metaanalysis in the data store\n  const key = datastore.key(['Metaanalysis', metaanalysis.id]);\n  // this is here until we add versioning on the metaanalyses themselves\n  const logKey = datastore.key(['Metaanalysis', metaanalysis.id,\n    'MetaanalysisLog', metaanalysis.id + '/' + metaanalysis.mtime]);\n  if (!options.restoring) console.log('saveMetaanalysis saving (into Metaanalysis and MetaanalysisLog)');\n\n  try {\n    await datastore.save([\n      { key, data: metaanalysis },\n      {\n        key: logKey,\n        data: [\n          {\n            name: 'mtime',\n            value: metaanalysis.mtime,\n          },\n          {\n            name: 'enteredBy',\n            value: email,\n          },\n          {\n            name: 'metaanalysis',\n            value: metaanalysis,\n            excludeFromIndexes: true,\n          },\n        ],\n      },\n    ]);\n    return metaanalysis;\n  } catch (error) {\n    console.error('error saving metaanalysis', error);\n    throw error;\n  }\n}\n\nmodule.exports = {\n  saveMetaanalysis,\n  getMetaanalysisByTitle,\n  getMetaanalysesEnteredBy,\n  listMetaanalyses,\n};\n\n/* -------------------------------------------------------------------------- */\n/*                                    Types                                   */\n/* -------------------------------------------------------------------------- */\n\n/**\n * @typedef {Object} Metaanalysis\n * @property {string} title\n * @property {string} enteredBy\n * @property {number} ctime\n * @property {number} mtime\n * @property {string} published\n * @property {string} description\n * @property {string[]} tags\n */\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/storage/papers.js","messages":[{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 24 to the 15 allowed.","line":62,"column":16,"nodeType":null,"endLine":62,"endColumn":25},{"ruleId":"consistent-return","severity":2,"message":"Expected to return a value at the end of async function 'savePaper'.","line":62,"column":16,"nodeType":"FunctionDeclaration","messageId":"missingReturn"},{"ruleId":"prefer-template","severity":2,"message":"Unexpected string concatenation.","line":83,"column":16,"nodeType":"BinaryExpression","messageId":"unexpectedStringConcatenation","endLine":83,"endColumn":32,"fix":{"range":[2667,2683],"text":"`/id/p/${  ctime}`"}},{"ruleId":"no-multi-assign","severity":2,"message":"Unexpected chained assignment.","line":85,"column":19,"nodeType":"AssignmentExpression","messageId":"unexpectedChain","endLine":85,"endColumn":38},{"ruleId":"prefer-template","severity":2,"message":"Unexpected string concatenation.","line":129,"column":17,"nodeType":"BinaryExpression","messageId":"unexpectedStringConcatenation","endLine":129,"endColumn":45,"fix":{"range":[4387,4415],"text":"`${paper.id  }/${  paper.mtime}`"}}],"errorCount":5,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"const { datastore, checkForDisallowedChanges, fillByAndCtimes } = require('./shared');\nconst { ValidationError, NotImplementedError } = require('../errors');\nconst tools = require('../lib/tools');\nconst users = require('./users');\nconst config = require('../config');\n\nasync function getPapersEnteredBy(user) {\n  if (!user) {\n    throw new Error('user parameter required');\n  }\n  const email = await users.getEmailAddressOfUser(user);\n  const query = datastore.createQuery('Paper').filter('enteredBy', '=', email);\n  const [papers] = await datastore.runQuery(query);\n  return papers;\n}\n\nasync function getPaperByTitle(user, title, time) {\n  // todo if time is specified, compute a version as of that time\n  if (time) throw new NotImplementedError('getPaperByTitle with time not implemented');\n\n  if (!user || !title) {\n    throw new Error('user and title parameters required');\n  }\n\n  // todo different users can use different titles for the same thing\n\n  if (title === config.NEW_PAPER_TITLE) {\n    const email = await users.getEmailAddressOfUser(user);\n    return newPaper(email);\n  }\n  const validUser = await users.getUser(user);\n  if (!validUser) return false;\n\n  const query = datastore.createQuery('Paper').filter('title', '=', title);\n  const [[paper]] = await datastore.runQuery(query);\n\n  if (paper) {\n    return paper;\n  }\n\n  throw new Error('No paper found');\n}\n\nfunction newPaper(email) {\n  const time = tools.uniqueNow();\n  return {\n    enteredBy: email,\n    ctime: time,\n    mtime: time,\n  };\n}\n\nconst currentPaperSave = Promise.resolve();\n\n/**\n * @param {Paper} paper\n * @param {string} email\n * @param {string} origTitle\n * @param {} options\n * @return {Promise<Paper>}\n */\nasync function savePaper(paper, email, origTitle, options) {\n  options = options || {};\n  // todo multiple users' views on one paper\n  // compute this user's version of this paper, as it is in the database\n  // compute a diff between what's submitted and the user's version of this paper\n  // detect any update conflicts (how?)\n  // add the diff to the paper as a changeset\n  // update the paper data only if the user is the one who it's enteredBy\n  // only allow editing a comment if it's the last one by this user\n  //   (must allow editing the last comment by this user in case in the meantime another user\n  //    has added another comment)\n\n  // the following serializes this save after the previous one, whether it fails or succeeds\n  // this way we can't have two concurrent saves create papers with the same title\n  await currentPaperSave;\n\n  // prepare the paper for saving\n  const ctime = tools.uniqueNow();\n  let original = null;\n\n  if (!paper.id) {\n    paper.id = '/id/p/' + ctime;\n    paper.enteredBy = email;\n    paper.ctime = paper.mtime = ctime;\n  } else {\n    const query = datastore.createQuery('Paper').filter('id', '=', paper.id);\n    const [[paperSearch]] = await datastore.runQuery(query);\n    if (paperSearch) {\n      original = paperSearch;\n\n      if (options.restoring) {\n        // paper is a paper we're restoring from some other datastore\n        // reject the save if we already have it\n        if (original) throw new Error(`paper ${paper.id} already exists`);\n        // otherwise save unchanged\n      } else {\n        // paper overwrites an existing paper\n        if (!original || origTitle !== original.title) {\n          throw new ValidationError(\n            `failed savePaper: did not find id ${paper.id} with title ${origTitle}`,\n          );\n        }\n        if (email !== original.enteredBy) {\n          throw new NotImplementedError('not implemented saving someone else\\'s paper');\n        }\n\n        paper.enteredBy = original.enteredBy;\n        paper.ctime = original.ctime;\n        paper.mtime = tools.uniqueNow();\n      }\n    }\n  }\n\n  // validate incoming data\n  await checkForDisallowedChanges(paper, original);\n\n  // put ctime and enteredBy on every experiment, datum, and comment that doesn't have them\n  fillByAndCtimes(paper, original, email);\n\n  // for now, we choose to ignore if the incoming paper specifies the wrong immutable values here\n  // do not save any of the validation values\n  tools.deleteCHECKvalues(paper);\n\n  // save the paper in the data store\n  const key = datastore.key(['Paper', paper.id]);\n  // this is here until we add versioning on the papers themselves\n  const logKey = datastore.key(['Paper', paper.id,\n    'PaperLog', paper.id + '/' + paper.mtime]);\n  if (!options.restoring) console.log('savePaper saving (into Paper and PaperLog)');\n  try {\n    await datastore.save(\n      [\n        { key, data: paper },\n        {\n          key: logKey,\n          data:\n            [\n              {\n                name: 'mtime',\n                value: paper.mtime,\n              },\n              {\n                name: 'enteredBy',\n                value: email,\n              },\n              {\n                name: 'paper',\n                value: paper,\n                excludeFromIndexes: true,\n              },\n            ],\n        },\n      ],\n    );\n    return paper;\n  } catch (error) {\n    console.error('error saving paper');\n    console.error(error);\n  }\n}\n\nmodule.exports = {\n  getPapersEnteredBy,\n  savePaper,\n  getPaperByTitle,\n};\n\n/* -------------------------------------------------------------------------- */\n/*                                    Types                                   */\n/* -------------------------------------------------------------------------- */\n\n/**\n * @typedef {Object} Comment\n * @property {string} by\n * @property {string} onVersionBy\n * @property {string} text\n * @property {number} ctime\n * @property {boolean} hidden\n */\n\n/**\n * @typedef {Object} Experiment\n * @property {string} title\n * @property {string} description\n * @property {string} enteredBy\n * @property {number} ctime\n * @property {Object.<string, ExperimentData[]>} data\n * @property {Comment[]} comments\n */\n\n/**\n * @typedef {Object} ExperimentData\n * @property {string} value\n * @property {number} ctime\n * @property {string} enteredBy\n * @property {Comment[]} comments\n */\n\n/**\n * @typedef {Object} Paper\n * @property {string} id\n * @property {string} title\n * @property {string} enteredBy\n * @property {number} ctime\n * @property {number} mtime\n * @property {string} reference\n * @property {string} description\n * @property {string} link\n * @property {string} doi\n * @property {string[]} tags\n * @property {string} modifiedBy\n * @property {Comment[]} comments\n * @property {string[]} columns\n * @property {Experiment[]} experiments\n */\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/storage/scripts/betacodes.js","messages":[{"ruleId":"no-plusplus","severity":2,"message":"Unary operator '++' used.","line":15,"column":35,"nodeType":"UpdateExpression","messageId":"unexpectedUnaryOp","endLine":15,"endColumn":38},{"ruleId":"object-shorthand","severity":2,"message":"Expected property shorthand.","line":19,"column":9,"nodeType":"Property","messageId":"expectedPropertyShorthand","endLine":19,"endColumn":19,"fix":{"range":[564,574],"text":"code"}},{"ruleId":"object-shorthand","severity":2,"message":"Expected property shorthand.","line":21,"column":9,"nodeType":"Property","messageId":"expectedPropertyShorthand","endLine":21,"endColumn":25,"fix":{"range":[622,638],"text":"comment"}},{"ruleId":"arrow-parens","severity":2,"message":"Expected parentheses around arrow function argument.","line":27,"column":43,"nodeType":"ArrowFunctionExpression","messageId":"expectedParens","endLine":27,"endColumn":46,"fix":{"range":[828,831],"text":"(err)"}},{"ruleId":"arrow-parens","severity":2,"message":"Expected parentheses around arrow function argument.","line":44,"column":17,"nodeType":"ArrowFunctionExpression","messageId":"expectedParens","endLine":44,"endColumn":24,"fix":{"range":[1273,1280],"text":"(element)"}}],"errorCount":5,"warningCount":0,"fixableErrorCount":4,"fixableWarningCount":0,"source":"const uid = require('uid');\nconst readline = require('readline');\nconst fs = require('fs');\nconst { datastore } = require('../shared');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.question('Enter the number of codes you want: ', (numCodes) => {\n  rl.question('Enter a comment for the codes: ', async (comment) => {\n    let betaCodes = '';\n    const codes = [];\n    for (let i = 0; i < numCodes; i++) {\n      const code = uid(12);\n      const dateGenerated = new Date().toISOString();\n      codes.push({\n        code: code,\n        timeGenerated: dateGenerated,\n        comment: comment,\n      });\n      betaCodes += `${code} # ${dateGenerated} ${comment}\\n`;\n    }\n    console.log('Saving in datastore');\n    await saveCodes(codes);\n    fs.appendFile('codes.txt', betaCodes, err => {\n      if (err) {\n        console.error(err);\n      } else {\n        console.log('Successfully generated beta codes and saved in codes.txt');\n        console.log();\n        console.log(betaCodes);\n        console.log('to print, paste these in https://lima.soc.port.ac.uk/admin/print-invites');\n      }\n    });\n    rl.close();\n  });\n});\n\nasync function saveCodes(codes) {\n  const kind = 'BetaCode';\n  const entities = [];\n  codes.forEach(element => {\n    const codeKey = datastore.key([kind, element.code]);\n    entities.push({\n      key: codeKey,\n      data: element,\n    });\n  });\n  await datastore.upsert(entities);\n}\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/storage/scripts/migrate.js","messages":[{"ruleId":"strict","severity":2,"message":"'use strict' is unnecessary inside of modules.","line":1,"column":1,"nodeType":"ExpressionStatement","messageId":"module","endLine":1,"endColumn":14,"fix":{"range":[0,13],"text":""}},{"ruleId":"lines-around-directive","severity":2,"message":"Expected newline after \"use strict\" directive.","line":1,"column":1,"nodeType":"ExpressionStatement","messageId":"expected","endLine":1,"endColumn":14,"fix":{"range":[13,13],"text":"\n"}},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 78 to the 15 allowed.","line":7,"column":16,"nodeType":null,"endLine":7,"endColumn":35},{"ruleId":"prefer-template","severity":2,"message":"Unexpected string concatenation.","line":66,"column":13,"nodeType":"BinaryExpression","messageId":"unexpectedStringConcatenation","endLine":66,"endColumn":30,"fix":{"range":[2721,2738],"text":"`${  maxId += 1}`"}},{"ruleId":"max-len","severity":2,"message":"This line has a length of 105. Maximum allowed is 100.","line":76,"column":1,"nodeType":"Program","messageId":"max","endLine":76,"endColumn":106},{"ruleId":"max-len","severity":2,"message":"This line has a length of 111. Maximum allowed is 100.","line":77,"column":1,"nodeType":"Program","messageId":"max","endLine":77,"endColumn":112},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 53 to the 15 allowed.","line":151,"column":10,"nodeType":null,"endLine":151,"endColumn":22},{"ruleId":"prefer-template","severity":2,"message":"Unexpected string concatenation.","line":189,"column":13,"nodeType":"BinaryExpression","messageId":"unexpectedStringConcatenation","endLine":189,"endColumn":30,"fix":{"range":[7490,7507],"text":"`${  maxId += 1}`"}},{"ruleId":"sonarjs/no-identical-functions","severity":2,"message":"Update this function so that its implementation is not identical to the one on line 96.","line":213,"column":40,"nodeType":null,"endLine":213,"endColumn":42},{"ruleId":"arrow-parens","severity":2,"message":"Expected parentheses around arrow function argument.","line":301,"column":18,"nodeType":"ArrowFunctionExpression","messageId":"expectedParens","endLine":301,"endColumn":22,"fix":{"range":[11024,11028],"text":"(user)"}},{"ruleId":"arrow-parens","severity":2,"message":"Expected parentheses around arrow function argument.","line":317,"column":18,"nodeType":"ArrowFunctionExpression","messageId":"expectedParens","endLine":317,"endColumn":25,"fix":{"range":[11434,11441],"text":"(element)"}},{"ruleId":"no-await-in-loop","severity":2,"message":"Unexpected `await` inside a loop.","line":334,"column":19,"nodeType":"AwaitExpression","messageId":"unexpectedAwait","endLine":334,"endColumn":53}],"errorCount":12,"warningCount":0,"fixableErrorCount":6,"fixableWarningCount":0,"source":"'use strict';\nconst { datastore } = require('../shared');\n\n/*\n * change metaanalysis from an old format to the new one on load from datastore, if need be\n */\nasync function migrateMetaanalysis(metaanalysis) {\n  // 2017-02-23: move columnOrder to columns\n  //     when all is migrated: just remove this code\n  if (metaanalysis.columnOrder) {\n    metaanalysis.columns = metaanalysis.columnOrder;\n    delete metaanalysis.columnOrder;\n    metaanalysis.migrated = true;\n  }\n\n  // 2017-05-02: move graph aggregates to graphs\n  //     when all is migrated: just remove this code\n  // migrate aggregate graphs to graphs\n  if (metaanalysis.aggregates) {\n    const oldGraphs = ['forestPlotNumberAggr', 'forestPlotPercentAggr',\n      'grapeChartNumberAggr', 'grapeChartPercentAggr'];\n    // going backwards so we can safely delete array elements\n    for (let i = metaanalysis.aggregates.length - 1; i >= 0; i -= 1) {\n      const formulaName = metaanalysis.aggregates[i].formula.split('(')[0];\n      if (oldGraphs.indexOf(formulaName) !== -1) {\n        const graph = metaanalysis.aggregates[i];\n        metaanalysis.aggregates.splice(i, 1);\n        graph.formula = graph.formula.replace('Aggr', 'Graph');\n        if (!metaanalysis.graphs) {\n          metaanalysis.graphs = [];\n        }\n        metaanalysis.graphs.unshift(graph);\n        metaanalysis.migrated = true;\n      }\n    }\n  }\n\n  // 2017-06-28: migrate global columns to private columns\n  //     when all is migrated:\n  //       remove this code,\n  //       update tests to check migration no longer does this\n  //       remove all remaining mentions of global columns\n  //       remove columns from datastore\n  // prepare the papers this metaanalysis depends on\n  const maPapers = await Promise.all(metaanalysis.paperOrder.map(async (paperId) => {\n    // find the paper with the matching ID\n    const query = datastore.createQuery('Paper').filter('id', '=', paperId);\n    const [retval] = await datastore.runQuery(query);\n    if (retval.length === 0) {\n      throw new Error(`metaanalysis ${metaanalysis.title} has a paper ${paperId} that isn't in the datastore`);\n    }\n    return retval[0];\n  }));\n\n  // convert columns from string to object\n  if (!metaanalysis.columns) metaanalysis.columns = [];\n  let maxId = 0;\n  metaanalysis.columns.forEach(async (col, colIndex) => {\n    if (typeof col === 'string') {\n      // migrate the string into an object\n      const query = datastore.createQuery('Column').filter('id', '=', col);\n      const [retval] = await datastore.runQuery(query);\n      if (retval.length === 0) throw new Error(`metaanalysis ${metaanalysis.title} uses nonexistent column ${col}`);\n      const column = retval[0];\n      const colObject = {\n        id: '' + (maxId += 1),\n        title: column.title,\n        description: column.description,\n        type: column.type,\n      };\n\n      // add sourceColumnMap { paperId: columnId }\n      colObject.sourceColumnMap = {};\n\n      maPapers.forEach((paper) => {\n        // go through paper's columns, find the one whose obsolete id matches col, use its ID in this map\n        const paperCol = paper.columns.find((paperColObject) => paperColObject.obsoleteIDForMigration === col);\n        if (paperCol) colObject.sourceColumnMap[paper.id] = paperCol.id;\n        // if the paper doesn't have such a column, just don't have a mapping;\n        // the column in the paper, and the mapping here, will get added when\n        // the metaanalysis is being edited and the user puts in a datum in this column\n      });\n      metaanalysis.columns[colIndex] = colObject;\n      // migrate hidden columns so it uses the right column ID\n      if (metaanalysis.hiddenCols) {\n        const colPos = metaanalysis.hiddenCols.indexOf(col);\n        if (colPos !== -1) {\n          metaanalysis.hiddenCols[colPos] = colObject.id;\n        }\n      }\n      // convert grouping column to new ID\n      if (metaanalysis.groupingColumn === col) metaanalysis.groupingColumn = colObject.id;\n      // migrate every parameter in computed anything into the right ID\n      for (const fieldName of ['columns', 'aggregates', 'groupingAggregates', 'graphs']) {\n        if (metaanalysis[fieldName]) {\n          metaanalysis[fieldName].forEach((computed) => {\n            if (!computed.formula) return; // not computed\n            // replace all occurrences of col in the formula with colObject.id\n            computed.formula = computed.formula.split(col).join(colObject.id);\n          });\n        }\n      }\n      metaanalysis.migrated = true;\n    }\n  });\n  // check that every computed thing's formula doesn't contain '/id/col/',\n  // remove offending ones because they don't have data in the metaanalysis anyway so no loss\n  // also migrate customName to title and add type: result\n  for (const fieldName of ['columns', 'aggregates', 'groupingAggregates', 'graphs']) {\n    if (metaanalysis[fieldName]) {\n      let computedIndex = metaanalysis[fieldName].length - 1;\n      while (computedIndex >= 0) {\n        const computed = metaanalysis[fieldName][computedIndex];\n        if (computed.formula) {\n          if (computed.formula.indexOf('/id/col/') !== -1) {\n            metaanalysis[fieldName].splice(computedIndex, 1);\n            metaanalysis.migrated = true;\n          }\n          if (computed.customName) {\n            computed.title = computed.customName;\n            delete computed.customName;\n            metaanalysis.migrated = true;\n          }\n          if (!computed.type && fieldName === 'columns') {\n            computed.type = 'result';\n            metaanalysis.migrated = true;\n          }\n        }\n        computedIndex -= 1;\n      }\n    }\n  }\n  // if we have a hiddenColumn that's not migrated, drop it\n  if (metaanalysis.hiddenCols) {\n    let hiddenIndex = metaanalysis.hiddenCols.length - 1;\n    while (hiddenIndex >= 0) {\n      if (metaanalysis.hiddenCols[hiddenIndex].startsWith('/id/col/')) {\n        metaanalysis.hiddenCols.splice(hiddenIndex, 1);\n        metaanalysis.migrated = true;\n      }\n      hiddenIndex -= 1;\n    }\n  }\n\n  return metaanalysis;\n}\n\n/*\n * change paper from an old format to the new one on load from datastore, if need be\n */\nfunction migratePaper(paper, columns) {\n  // 2017-02-23: move columnOrder to columns\n  //     when all is migrated: just remove this code\n  if (paper.columnOrder) {\n    paper.columns = paper.columnOrder;\n    delete paper.columnOrder;\n    paper.migrated = true;\n  }\n\n  // 2017-06-27: migrate global columns to private columns\n  //     when all is migrated:\n  //       remove this code,\n  //       remove obsoleteIDForMigration from api.js\n  //       update tests to check migration no longer does this\n  //       remove all remaining mentions of global columns\n  //       remove columns from datastore\n\n  // if we have a datum whose column ID isn't in paper.columns then add it there\n  if (!paper.columns) paper.columns = [];\n  if (paper.experiments) {\n    paper.experiments.forEach((exp) => {\n      if (exp.data) {\n        Object.keys(exp.data).forEach((colId) => {\n          if (colId.startsWith('/id/col/') && paper.columns.indexOf(colId) === -1) {\n            paper.columns.push(colId);\n            paper.migrated = true;\n          }\n        });\n      }\n    });\n  }\n\n  let maxId = 0;\n  paper.columns.forEach((col, colIndex) => {\n    if (typeof col === 'string') {\n      // migrate the string into an object\n      if (!columns[col]) throw new Error(`paper ${paper.title} uses nonexistent column ${col}`);\n      const colObject = {\n        id: '' + (maxId += 1),\n        title: columns[col].title,\n        description: columns[col].description,\n        type: columns[col].type,\n        obsoleteIDForMigration: col,\n      };\n      paper.columns[colIndex] = colObject;\n      // migrate experiment data so it uses the column ID\n      if (paper.experiments) {\n        paper.experiments.forEach((exp) => {\n          if (exp.data && col in exp.data) {\n            exp.data[colObject.id] = exp.data[col];\n            delete exp.data[col];\n          }\n        });\n      }\n      // migrate hidden columns so it uses the right column ID\n      if (paper.hiddenCols) {\n        const colPos = paper.hiddenCols.indexOf(col);\n        if (colPos !== -1) {\n          paper.hiddenCols[colPos] = colObject.id;\n        }\n      }\n      // migrate every parameter in computed anything into the right ID\n      paper.columns.forEach((computed) => {\n        if (!computed.formula) return; // not computed\n        // replace all occurrences of col in the formula with colObject.id\n        computed.formula = computed.formula.split(col).join(colObject.id);\n      });\n      paper.migrated = true;\n    }\n  });\n  // check that every computed column's formula doesn't contain '/id/col/',\n  // remove offending ones because they don't have data in the paper anyway so no loss\n  // also migrate customName to title and add type: result\n  let computedIndex = paper.columns.length - 1;\n  while (computedIndex >= 0) {\n    const computed = paper.columns[computedIndex];\n    if (computed.formula) {\n      if (computed.formula.indexOf('/id/col/') !== -1) {\n        paper.columns.splice(computedIndex, 1);\n        paper.migrated = true;\n      }\n      if (computed.customName || !computed.type) {\n        computed.title = computed.customName;\n        delete computed.customName;\n        computed.type = 'result';\n        paper.migrated = true;\n      }\n    }\n    computedIndex -= 1;\n  }\n  // if we have a hiddenColumn that's not migrated, drop it\n  if (paper.hiddenCols) {\n    let hiddenIndex = paper.hiddenCols.length - 1;\n    while (hiddenIndex >= 0) {\n      if (paper.hiddenCols[hiddenIndex].startsWith('/id/col/')) {\n        paper.hiddenCols.splice(hiddenIndex, 1);\n        paper.migrated = true;\n      }\n      hiddenIndex -= 1;\n    }\n  }\n\n  return paper;\n}\n\n/*\n * change user from an old format to the new one on load from datastore, if need be\n */\nfunction migrateUser(user) {\n  // 2017-06-08: Only store limited user information\n  //     when all is migrated: just remove this code\n  if (user.emails) {\n    user.email = user.emails[0].value;\n    delete user.emails;\n    delete user.CHECKid;\n    delete user.id;\n    delete user.name;\n    delete user.provider;\n    user.migrated = true;\n  }\n  return user;\n}\n\nasync function getAllColumns() {\n  try {\n    console.log('getAllColumns: making a datastore request');\n    const retval = {};\n    const [results] = await datastore.createQuery('Column').run();\n\n    results.forEach((result) => {\n      try {\n        retval[result.id] = result;\n      } catch (error) {\n        console.error('error in a column entity (ignoring)', error);\n      }\n    });\n\n    console.log(`getAllColumns: ${Object.keys(retval).length} done`);\n    return retval;\n  } catch (error) {\n    console.error('error retrieving columns', error);\n    setTimeout(getAllColumns, 60 * 1000); // try loading again in a minute\n    throw error;\n  }\n}\n\nasync function migrateAllUsers() {\n  const kind = 'User';\n  const [retval] = await datastore.createQuery(kind).run();\n  const entities = [];\n  retval.forEach(user => {\n    const val = migrateUser(user);\n    const userKey = datastore.key([kind, val.email]);\n    entities.push({\n      key: userKey,\n      data: val,\n    });\n  });\n  await datastore.upsert(entities);\n}\n\nasync function migrateAllPapers() {\n  const columns = await getAllColumns();\n  const kind = 'Paper';\n  const [retval] = await datastore.createQuery(kind).run();\n  const entities = [];\n  retval.forEach(element => {\n    const val = migratePaper(element, columns);\n    const paperKey = datastore.key([kind, element.id]);\n    entities.push({\n      key: paperKey,\n      data: val,\n    });\n  });\n  await datastore.upsert(entities);\n}\n\nasync function migrateAllMetaanalysis() {\n  const kind = 'Metaanalysis';\n  const [retval] = await datastore.createQuery(kind).run();\n  const entities = [];\n  for (const element of retval) {\n    try {\n      const val = await migrateMetaanalysis(element);\n      const metaanalysisKey = datastore.key([kind, val.id]);\n      entities.push({\n        key: metaanalysisKey,\n        data: val,\n      });\n    } catch (error) {\n      console.log(error);\n    }\n  }\n  await datastore.upsert(entities);\n}\n\nasync function migrate() {\n  await migrateAllUsers();\n  await migrateAllPapers();\n  await migrateAllMetaanalysis();\n  console.log('Migration complete');\n}\n\nmigrate();\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/storage/shared.js","messages":[{"ruleId":"import/order","severity":2,"message":"`@google-cloud/datastore` import should occur before import of `../config`","line":4,"column":23,"nodeType":"CallExpression","endLine":4,"endColumn":57,"fix":{"range":[0,184],"text":"const { Datastore } = require('@google-cloud/datastore');\nconst config = require('../config');\nconst { ValidationError } = require('../errors');\nconst tools = require('../lib/tools');\n"}},{"ruleId":"import/order","severity":2,"message":"`fs` import should occur before import of `../config`","line":5,"column":12,"nodeType":"CallExpression","endLine":5,"endColumn":25,"fix":{"range":[0,210],"text":"const fs = require('fs');\nconst config = require('../config');\nconst { ValidationError } = require('../errors');\nconst tools = require('../lib/tools');\nconst { Datastore } = require('@google-cloud/datastore');\n"}},{"ruleId":"import/order","severity":2,"message":"`path` import should occur before import of `../config`","line":6,"column":14,"nodeType":"CallExpression","endLine":6,"endColumn":29,"fix":{"range":[0,240],"text":"const path = require('path');\nconst config = require('../config');\nconst { ValidationError } = require('../errors');\nconst tools = require('../lib/tools');\nconst { Datastore } = require('@google-cloud/datastore');\nconst fs = require('fs');\n"}},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 51 to the 15 allowed.","line":23,"column":10,"nodeType":null,"endLine":23,"endColumn":25},{"ruleId":"no-plusplus","severity":2,"message":"Unary operator '++' used.","line":30,"column":67,"nodeType":"UpdateExpression","messageId":"unexpectedUnaryOp","endLine":30,"endColumn":77},{"ruleId":"no-plusplus","severity":2,"message":"Unary operator '++' used.","line":50,"column":63,"nodeType":"UpdateExpression","messageId":"unexpectedUnaryOp","endLine":50,"endColumn":73},{"ruleId":"no-plusplus","severity":2,"message":"Unary operator '++' used.","line":60,"column":68,"nodeType":"UpdateExpression","messageId":"unexpectedUnaryOp","endLine":60,"endColumn":79},{"ruleId":"no-plusplus","severity":2,"message":"Unary operator '++' used.","line":71,"column":40,"nodeType":"UpdateExpression","messageId":"unexpectedUnaryOp","endLine":71,"endColumn":43},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 108 to the 15 allowed.","line":80,"column":16,"nodeType":null,"endLine":80,"endColumn":41},{"ruleId":"no-use-before-define","severity":2,"message":"'forbiddenUsernames' was used before it was defined.","line":120,"column":26,"nodeType":"Identifier","messageId":"usedBeforeDefined","endLine":120,"endColumn":44},{"ruleId":"no-multiple-empty-lines","severity":2,"message":"More than 1 blank line not allowed.","line":144,"column":1,"nodeType":"Program","messageId":"consecutiveBlank","endLine":145,"endColumn":1,"fix":{"range":[6558,6559],"text":""}},{"ruleId":"no-plusplus","severity":2,"message":"Unary operator '++' used.","line":148,"column":67,"nodeType":"UpdateExpression","messageId":"unexpectedUnaryOp","endLine":148,"endColumn":77},{"ruleId":"no-plusplus","severity":2,"message":"Unary operator '++' used.","line":174,"column":54,"nodeType":"UpdateExpression","messageId":"unexpectedUnaryOp","endLine":174,"endColumn":57},{"ruleId":"prefer-template","severity":2,"message":"Unexpected string concatenation.","line":193,"column":39,"nodeType":"BinaryExpression","messageId":"unexpectedStringConcatenation","endLine":193,"endColumn":94,"fix":{"range":[8630,8685],"text":"`cannot include data with unknown column ID ${  dataKey}`"}},{"ruleId":"max-len","severity":2,"message":"This line has a length of 110. Maximum allowed is 100.","line":201,"column":1,"nodeType":"Program","messageId":"max","endLine":201,"endColumn":111}],"errorCount":15,"warningCount":0,"fixableErrorCount":5,"fixableWarningCount":0,"source":"const config = require('../config');\nconst { ValidationError } = require('../errors');\nconst tools = require('../lib/tools');\nconst { Datastore } = require('@google-cloud/datastore');\nconst fs = require('fs');\nconst path = require('path');\n\nconst TITLE_REXP = new RegExp(`^${config.TITLE_RE}$`);\nconst USERNAME_REXP = new RegExp(`^${config.USERNAME_RE}$`);\n\nconst datastoreConfig = {\n  namespace: config.gcloudDatastoreNamespace,\n};\n\nif (!process.env.GAE_APPLICATION && config.gcloudProject) {\n  datastoreConfig.projectId = config.gcloudProject.projectId;\n  datastoreConfig.keyFilename = config.gcloudProject.keyFilename;\n}\n\nconst datastore = new Datastore(datastoreConfig);\n\n// in papers, metaanalyses, and comments fill in enteredBy and ctime\nfunction fillByAndCtimes(current, original, email) {\n  const orig = original || {};\n  if (!current.enteredBy) current.enteredBy = orig.enteredBy || email;\n  if (!current.ctime) current.ctime = orig.ctime || tools.uniqueNow();\n  fillByAndCtimeInComments(current.comments, orig.comments, email);\n\n  if (current.experiments) {\n    for (let expIndex = 0; expIndex < current.experiments.length; expIndex++) {\n      const exp = current.experiments[expIndex];\n      const origExp = (orig.experiments || [])[expIndex] || {};\n      // todo these values should allow us to construct better patches\n      // (e.g. removal of the first experiment)\n      if (!exp.enteredBy) exp.enteredBy = origExp.enteredBy || email;\n      if (!exp.ctime) exp.ctime = origExp.ctime || tools.uniqueNow();\n      fillByAndCtimeInComments(exp.comments, origExp.comments, email);\n      for (const col of Object.keys(exp.data || {})) {\n        const expCol = exp.data[col];\n        const origCol = (origExp.data || {})[col] || {};\n        const origColIfSameVal = expCol.value === origCol.value ? origCol : {};\n        if (!expCol.enteredBy) expCol.enteredBy = origColIfSameVal.enteredBy || email;\n        if (!expCol.ctime) expCol.ctime = origColIfSameVal.ctime || tools.uniqueNow();\n        fillByAndCtimeInComments(expCol.comments, origCol.comments, email);\n      }\n    }\n  }\n\n  if (current.columns) {\n    for (let colIndex = 0; colIndex < current.columns.length; colIndex++) {\n      if (typeof current.columns[colIndex] === 'object') {\n        const col = current.columns[colIndex];\n        const origCol = (orig.columns || [])[colIndex] || {};\n        fillByAndCtimeInComments(col.comments, origCol.comments, email);\n      }\n    }\n  }\n\n  if (current.aggregates) {\n    for (let aggrIndex = 0; aggrIndex < current.aggregates.length; aggrIndex++) {\n      const aggr = current.aggregates[aggrIndex];\n      const origAggr = (orig.aggregates || [])[aggrIndex] || {};\n      fillByAndCtimeInComments(aggr.comments, origAggr.comments, email);\n    }\n  }\n}\n\nfunction fillByAndCtimeInComments(comments, origComments, email) {\n  origComments = origComments || [];\n  if (!Array.isArray(comments)) return;\n  for (let i = 0; i < comments.length; i++) {\n    const com = comments[i];\n    const origCom = origComments[i] || {};\n    const origComIfSameText = origCom.text === com.text ? origCom : {};\n    if (!com.by) com.by = origComIfSameText.by || email;\n    if (!com.ctime) com.ctime = origComIfSameText.ctime || tools.uniqueNow();\n  }\n}\n\nasync function checkForDisallowedChanges(current, original) {\n  // todo really, this should use a diff format and check that all diffs are allowed\n  //   this will be a diff from the user's last version to the incoming version,\n  //   not from the existing version to the incoming version,\n  //   so that collaborative concurrent updates are allowed\n  //   so for example adding a comment number 9 will become adding a comment\n  //   and if comments 9 and 10 were already added by other users, we will add comment 11\n  // but for now we don't have the diffs, so\n  //   do the checks we can think of for changes that wouldn't be allowed\n  // for example, we can't really allow removing values because we don't allow removing comments\n  // todo comment mtimes\n  // todo check that columns and groupingColumn and aggregates references existing columns\n  // todo check that paperOrder references existing papers\n  // this might end up being different for papers and for metaanalyses\n  // todo refuse to save if all the experiments of a paper are hidden in the metaanalysis\n  //    - the paper should be gone from this metaanalysis\n\n  original = original || {};\n\n  // check that title hasn't changed or if it has, that it is unique\n  if (current.title !== original.title) {\n    if (!TITLE_REXP.test(current.title)) {\n      throw new ValidationError('title cannot contain spaces or special characters');\n    }\n    const [[metaanalysesCheck]] = await datastore.createQuery('Metaanalysis').filter('title', '=', current.title).run();\n    const [[paperCheck]] = await datastore.createQuery('Metaanalysis').filter('title', '=', current.title).run();\n    if (metaanalysesCheck || paperCheck) {\n      throw new ValidationError('title must be unique');\n    }\n    if (current.title === config.NEW_PAPER_TITLE || current.title === config.NEW_META_TITLE) {\n      throw new ValidationError('cannot use a reserved name');\n    }\n  }\n\n  // check that username hasn't changed or if it has, that it is empty or unique\n  if (current.username != null && current.username !== original.username) {\n    if (!USERNAME_REXP.test(current.username)) {\n      throw new ValidationError('username cannot contain spaces or special characters');\n    }\n    const [[usernameCheck]] = await datastore.createQuery('User').filter('username', '=', current.username).run();\n    if (usernameCheck || forbiddenUsernames.includes(current.username)) {\n      throw new ValidationError('username must be unique, must not be from the forbidden list');\n    }\n    // todo: do we need extra checks here? I.e. length of username? encodings? emojis?\n  }\n\n  // check that no two columns have the same ID\n  // check that computed columns don't have IDs and that the others do\n  // also prepare a hash of known column IDs for use later\n  const knownColumnIDs = {};\n  if (current.columns) {\n    current.columns.forEach((colObject) => {\n      if (colObject.formula && colObject.id) throw new ValidationError('computed column must not have ID');\n      if (!colObject.formula && !colObject.id) throw new ValidationError('column without ID must have formula');\n\n      if (colObject.id) {\n        if (knownColumnIDs[colObject.id]) {\n          throw new ValidationError('two columns cannot have the same ID');\n        }\n        knownColumnIDs[colObject.id] = true;\n      }\n    });\n  }\n\n\n  // check that every experiment has at least the data values that were there originally\n  // check that only last comment by a given user has changed, if any\n  if (current.experiments) {\n    for (let expIndex = 0; expIndex < current.experiments.length; expIndex++) {\n      const exp = current.experiments[expIndex];\n      const origExp = (original.experiments || [])[expIndex] || {};\n\n      // check experiment titles are there (but need not be unique)\n      if (!TITLE_REXP.test(exp.title)) {\n        throw new ValidationError('experiment title cannot contain spaces or special characters');\n      }\n\n      if (origExp.data) {\n        if (!exp.data) throw new ValidationError('cannot remove experiment data array');\n\n        for (const origDataKey of Object.keys(origExp.data)) {\n          if (!(origDataKey in exp.data)) {\n            throw new ValidationError('cannot remove experiment data');\n          }\n\n          const { comments } = exp.data[origDataKey];\n          const origComments = origExp.data[origDataKey].comments;\n\n          if (origComments) {\n            if (!comments || comments.length < origComments.length) {\n              throw new ValidationError('cannot remove comments');\n            }\n\n            const changedCommentByOwner = {};\n            for (let i = 0; i < origComments.length; i++) {\n              const comment = comments[i];\n              const origComment = origComments[i];\n              if (comment.CHECKby !== origComment.by) {\n                throw new ValidationError('cannot change comment owner');\n              }\n              if (comment.CHECKby in changedCommentByOwner) {\n                throw new ValidationError('cannot edit comment before the last by a given owner');\n              }\n              if (comment.text !== origComment.text) {\n                changedCommentByOwner[comment.CHECKby] = 1;\n              }\n            }\n          }\n        }\n      }\n      if (exp.data) {\n        for (const dataKey of Object.keys(exp.data)) {\n          if (!knownColumnIDs[dataKey]) {\n            throw new ValidationError('cannot include data with unknown column ID ' + dataKey);\n          }\n        }\n      }\n    }\n  }\n}\n\n// on start of web server put all file names in /webpages into this list, with and without filename extensions\nconst forbiddenUsernames = [];\n\nfunction getForbiddenUsernames() {\n  // start initially with those defined in config\n  const retval = [...config.FORBIDDEN_USERNAMES];\n\n  // then populate the rest by taking a look at /webpages\n  const files = fs.readdirSync(path.join(__dirname, '..', '..', 'webpages'));\n\n  files.forEach((name) => {\n    addUsernameIfNotThere(retval, name);\n    addUsernameIfNotThere(retval, name.replace(/\\..*$/, ''));\n  });\n\n  function addUsernameIfNotThere(arr, name) {\n    // don't add usernames that wouldn't be allowed anyway\n    if (!name) return;\n    if (!name.match(USERNAME_REXP)) return;\n\n    if (arr.indexOf(name) === -1) arr.push(name.toLowerCase());\n  }\n\n  // push all the found forbidden usernames into the global array\n  forbiddenUsernames.push(...retval);\n}\n\nmodule.exports = {\n  datastore,\n  fillByAndCtimes,\n  checkForDisallowedChanges,\n  forbiddenUsernames,\n  getForbiddenUsernames,\n};\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/server/storage/users.js","messages":[{"ruleId":"import/newline-after-import","severity":2,"message":"Expected 1 empty line after require statement not followed by another require.","line":3,"column":1,"nodeType":null,"fix":{"range":[177,177],"text":"\n"}},{"ruleId":"prefer-template","severity":2,"message":"Unexpected string concatenation.","line":48,"column":21,"nodeType":"BinaryExpression","messageId":"unexpectedStringConcatenation","endLine":48,"endColumn":74,"fix":{"range":[1235,1288],"text":"`must not add the user ${  LOCAL_STORAGE_SPECIAL_USER}`"}},{"ruleId":"max-len","severity":2,"message":"This line has a length of 104. Maximum allowed is 100.","line":124,"column":1,"nodeType":"Program","messageId":"max","endLine":124,"endColumn":105}],"errorCount":3,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"const { datastore, checkForDisallowedChanges, forbiddenUsernames } = require('./shared');\nconst { ForbiddenError } = require('../errors');\nconst tools = require('../lib/tools');\nconst LOCAL_STORAGE_SPECIAL_USER = 'lima@local';\n\n/**\n * @param {string} user\n * @return {Promise<User>}\n */\nasync function getUser(user) {\n  if (!user) {\n    throw new Error('user parameter required');\n  }\n\n  if (forbiddenUsernames.indexOf(user) !== -1) {\n    throw new ForbiddenError('provided username is a reserved word');\n  }\n\n  let query;\n\n  if (user.includes('@')) {\n    // user is an email\n    query = datastore.createQuery('User').filter('email', '=', user);\n  } else {\n    query = datastore.createQuery('User').filter('username', '=', user);\n  }\n\n  try {\n    const [[retval]] = await datastore.runQuery(query);\n    if (retval) {\n      return retval;\n    } else {\n      throw new Error('User not found');\n    }\n  } catch (error) {\n    throw new Error('User not found');\n  }\n}\n\nasync function saveUser(email, user, options) {\n  options = options || {};\n  // todo do we want to keep a Log of users?\n  if (!email || !user) {\n    throw new Error('email/user parameters required');\n  }\n\n  if (email === LOCAL_STORAGE_SPECIAL_USER) {\n    throw new Error('must not add the user ' + LOCAL_STORAGE_SPECIAL_USER);\n  }\n\n  if (!user.ctime) { // new user\n    user.ctime = tools.uniqueNow();\n  }\n\n  let original = null;\n\n  try {\n    original = await getUser(email);\n  } catch (error) {\n    // original user does't exist\n  }\n\n  // reject the save if we're restoring from another datastore and we already have this user\n  if (options.restoring && original) {\n    throw new Error(`user ${user.email} already exists`);\n  }\n  checkForDisallowedChanges(user, original);\n  const key = datastore.key(['User', email]);\n  console.log('saveUser making a datastore request');\n  try {\n    await datastore.save({\n      key,\n      data: user,\n    });\n    // then return the user\n    return user;\n  } catch (err) {\n    console.error('error saving user', err);\n    throw err;\n  }\n}\n\n// Take either the email address, or username and return the email address\nasync function getEmailAddressOfUser(username) {\n  if (username.indexOf('@') !== -1) return username;\n\n  const query = datastore.createQuery('User').filter('username', '=', username);\n\n  try {\n    const [[user]] = await datastore.runQuery(query);\n\n    if (user) {\n      return user.email;\n    } else {\n      throw new Error('No email found');\n    }\n  } catch (error) {\n    return null;\n  }\n}\n\n// Take either the email address, or username and return the username (or null if there is none)\nasync function getUsernameOfUser(user) {\n  if (user.indexOf('@') === -1) return user;\n  const retval = await getUser(user);\n  return retval.username;\n}\n\nmodule.exports = {\n  getUser,\n  saveUser,\n  getEmailAddressOfUser,\n  getUsernameOfUser,\n  forbiddenUsernames,\n};\n\n/* -------------------------------------------------------------------------- */\n/*                                    Types                                   */\n/* -------------------------------------------------------------------------- */\n\n/**\n  * @typedef {Object} User\n  * @property {number} ctime\n  * @property {number} mtime The user last 'registered' i.e. agreed to t&c's (may have changed username)\n  * @property {string} email\n  * @property {string} displayName\n  * @property {string} username See regex for exact allowed names\n  * @property {[{value: string}]} photos\n  * @todo add favourites\n*/\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/MetaanalysisApp.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/layout/Footer.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/layout/Header.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/layout/OnTabChange.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/layout/Tabs.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/AddColumn.js","messages":[{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 98 to the 15 allowed.","line":6,"column":10,"nodeType":null,"endLine":6,"endColumn":24},{"ruleId":"indent","severity":2,"message":"Expected indentation of 2 spaces but found 10.","line":206,"column":1,"nodeType":"Identifier","messageId":"wrongIndentation","endLine":206,"endColumn":11,"fix":{"range":[6914,6924],"text":"  "}},{"ruleId":"no-unused-vars","severity":2,"message":"'foo' is assigned a value but never used.","line":209,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":209,"endColumn":12},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 2.","line":210,"column":1,"nodeType":"Punctuator","messageId":"wrongIndentation","endLine":210,"endColumn":3,"fix":{"range":[6981,6983],"text":"    "}},{"ruleId":"quotes","severity":2,"message":"Strings must use singlequote.","line":210,"column":5,"nodeType":"Literal","messageId":"wrongQuotes","endLine":210,"endColumn":10,"fix":{"range":[6985,6990],"text":"'bar'"}},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 2.","line":211,"column":1,"nodeType":"Punctuator","messageId":"wrongIndentation","endLine":211,"endColumn":3,"fix":{"range":[6991,6993],"text":"    "}},{"ruleId":"quotes","severity":2,"message":"Strings must use singlequote.","line":211,"column":23,"nodeType":"Literal","messageId":"wrongQuotes","endLine":211,"endColumn":28,"fix":{"range":[7013,7018],"text":"'baz'"}}],"errorCount":7,"warningCount":0,"fixableErrorCount":5,"fixableWarningCount":0,"source":"import React, { useContext, useState } from 'react';\nimport EditContext from './EditContext';\nimport formulas from './aggregates/Formulas';\nimport Popup from './Popup';\n\nfunction AddColumnPopup(props) {\n  const { flag, columnState } = props;\n  const [columns, setColumns] = columnState;\n  const [popupStatus, setPopupStatus] = flag;\n  const [selectedType, setSelectedType] = useState('moderator');\n  const simpleFormulas = formulas().simpleFormulas;\n  const [selectedFormula, setSelectedFormula] = useState(simpleFormulas[0]);\n  const calculators = columns.filter((col) => col.subType === 'calculator' || col.subType === 'calculatorN');\n\n  const closeHandler = () => {\n    setPopupStatus(!popupStatus);\n    setSelectedType('moderator');\n  };\n\n  function handleTypeChange(e) {\n    setSelectedType(e.currentTarget.value);\n  }\n\n  function handleFormulaChange(e) {\n    let newFormula = simpleFormulas[0];\n    for (const simpleFormula of simpleFormulas) {\n      if (simpleFormula.id === e.currentTarget.value) {\n        newFormula = simpleFormula;\n      }\n    }\n    setSelectedFormula(newFormula);\n  }\n\n  function handleSubmit(e) {\n    e.preventDefault();\n    let title;\n    let type;\n    let formulaTitle;\n    const params = [];\n\n    function reorderColumnsBySubtype(cols) {\n      const colsClone = [...cols];\n      const modCols = [];\n      const calcCols = [];\n      const dataCols = [];\n      colsClone.forEach((column) => {\n        if (column.subType === 'moderator') {\n          modCols.push(column);\n        } else if (column.subType === 'calculator' || column.subType === 'calculatorN') {\n          calcCols.push(column);\n        } else if (column.subType === 'result') {\n          dataCols.push(column);\n        }\n      });\n      const orderedCols = modCols.concat(calcCols.concat(dataCols));\n      return orderedCols;\n    }\n\n    function createModeratorObject() {\n      let columnsClone = [...columns];\n      const newId = String(columns.filter((col) => col.subType !== 'result').length + 1);\n      const newInputType = type === 'moderator' ? 'string' : 'number';\n      const newModeratorColumnObject = {\n        id: newId,\n        inputType: newInputType,\n        sourceColumnMap: {},\n        subType: 'moderator',\n        title,\n        type: 'characteristic',\n      };\n      if (newModeratorColumnObject !== {} && title !== '') {\n        columnsClone.push(newModeratorColumnObject);\n        columnsClone = reorderColumnsBySubtype(columnsClone);\n        closeHandler();\n      }\n      return columnsClone;\n    }\n\n    function createCalculatorObject() {\n      let columnsClone = [...columns];\n      const newId = columns.filter((col) => col.subType !== 'result').length + 1;\n      const newInputType = type === 'moderator' ? 'string' : 'number';\n      const newCalculatorColumnObject = {\n        id: String(newId),\n        inputType: newInputType,\n        sourceColumnMap: {},\n        subType: 'calculator',\n        title,\n        type: 'characteristic',\n        linkedN: String(newId + 1),\n      };\n      const newCalculatorNColumnObject = {\n        id: String(newId + 1),\n        inputType: newInputType,\n        sourceColumnMap: {},\n        subType: 'calculatorN',\n        title: `N (${title})`,\n        type: 'characteristic',\n      };\n      if (newCalculatorColumnObject !== {} && title !== '') {\n        columnsClone.push(newCalculatorColumnObject);\n        columnsClone.push(newCalculatorNColumnObject);\n        columnsClone = reorderColumnsBySubtype(columnsClone);\n        closeHandler();\n      }\n      return columnsClone;\n    }\n\n    function createResultObject() {\n      let columnsClone = [...columns];\n      const f = simpleFormulas.filter((formula) => formula.id === formulaTitle)[0];\n      const formulaClone = { ...f };\n      formulaClone.type = window.lima.FORMULA_TYPE;\n      const newNumber = String(columns.filter((col) => col.subType === 'result').length + 1);\n      let newFormula = '';\n      const newFormulaParams = [];\n      let newFullLabel = '';\n      console.log(f, params);\n      if (f.parameters.length !== 4) {\n        for (let i = 0; i < params.length; i += 1) {\n          newFormulaParams[i] = calculators.filter((col) => col.id === String(params[i]))[0];\n          newFullLabel = newFullLabel.concat(newFormulaParams[i].title);\n          newFormula = newFormula.concat(params[i]);\n          if (params[i + 1]) {\n            newFormula = newFormula.concat(',');\n            newFullLabel = newFullLabel.concat(', ');\n          }\n        }\n      } else {\n        for (let i = 0; i < f.parameters.length; i += 2) {\n          newFormulaParams[i] = calculators.filter((col) => col.id === String(params[i / 2]))[0];\n          newFormulaParams[i + 1] = calculators.filter(\n            (col) => col.id === newFormulaParams[i].linkedN,\n          )[0];\n          newFullLabel = `${newFullLabel}${newFormulaParams[i].title}, ${newFormulaParams[i + 1].title}`;\n          newFormula = `${newFormula}${newFormulaParams[i].id},${newFormulaParams[i + 1].id}`;\n          if (f.parameters[i + 2]) {\n            newFormula = newFormula.concat(',');\n            newFullLabel = newFullLabel.concat(', ');\n          }\n        }\n      }\n      console.log(newFormula, newFullLabel);\n      const newResultColumnObject = {\n        formula: `${formulaClone.id}(${newFormula})`,\n        formulaName: formulaClone.id,\n        formulaObj: formulaClone,\n        formulaParams: newFormulaParams,\n        fullLabel: `${formulaClone.label}(${newFullLabel})`,\n        metaanalysis: window.currentMa,\n        number: newNumber,\n        subType: 'result',\n        title,\n        type: 'result',\n      };\n      if (newResultColumnObject !== {} && title !== '') {\n        columnsClone.push(newResultColumnObject);\n        columnsClone = reorderColumnsBySubtype(columnsClone);\n        closeHandler();\n      }\n      return columnsClone;\n    }\n\n    for (const current of e.currentTarget) {\n      if (current.children.nodeName === 'LABEL' || current.nodeName === 'DIV') {\n        const input = current.children;\n        switch (input.id) {\n        case 'columnTitleInput':\n          title = input.children[0].value;\n          break;\n        case 'columnTypeSelect':\n          type = input.children[0].value;\n          break;\n        case 'columnFormulaSelect':\n          formulaTitle = input.children[0].value;\n          break;\n        case 'formulaParamInput':\n          console.log(input);\n          for (const inp of input) {\n            params.push(inp.children.children[0].value);\n          }\n          break;\n        default:\n        }\n      }\n    }\n\n    let columnsToSet;\n    switch (type) {\n    case 'moderator':\n      columnsToSet = createModeratorObject();\n      break;\n    case 'calculator':\n      columnsToSet = createCalculatorObject();\n      break;\n    case 'result':\n      columnsToSet = createResultObject();\n      break;\n    default:\n    }\n    setColumns(columnsToSet);\n  }\n\n  let maybe1;\n  let maybe2;\n          let value1;\n  let value2;\n\n  const foo = maybe1 > maybe2\n  ? \"bar\"\n  : value1 > value2 ? \"baz\" : null;\n\n  const content = (\n    <div className=\"AddColumnPopup\">\n      <h1>Add a new column</h1>\n      <form className=\"addColumnForm\" onSubmit={handleSubmit}>\n        <label htmlFor=\"columnTitleInput\" id=\"columnTitleInput\">\n          Title:\n          <input\n            type=\"text\"\n            name=\"columnTitleInput\"\n            placeholder=\"Enter a title for the column (required)\"\n          />\n        </label>\n        <label htmlFor=\"columnTypeSelect\" id=\"columnTypeSelect\">\n          <select name=\"columnTypeSelect\" onChange={handleTypeChange}>Column type:\n            <option value=\"moderator\">Moderator</option>\n            <option value=\"calculator\">Calculator</option>\n            <option value=\"result\">Result</option>\n          </select>\n        </label>\n        { selectedType === 'result'\n          ? (\n            <>\n              <label htmlFor=\"columnFormulaSelect\" id=\"columnFormulaSelect\">\n                <select name=\"columnFormulaSelect\" onChange={handleFormulaChange}>\n                  { simpleFormulas.map((formula) => (\n                    <option key={`column${formula.id}`} value={formula.id} selected={selectedFormula.id === formula.id ? 'selected' : null}>\n                      { formula.label }\n                    </option>\n                  )) }\n                </select>\n              </label>\n              <div id=\"formulaParamInput\">\n                { selectedFormula.parameters.length === 2\n                  ? (\n                    <>\n                      { selectedFormula.parameters.map((param) => (\n                        <label htmlFor={`param${param}`} key={`param${param}`} className=\"formulaParamInput\">{ param }:\n                          <select name={`param${param}`}>\n                            { calculators.map((col) => (\n                              <>\n                                { col.subType === 'calculator'\n                                  ? (\n                                    <option value={col.id} key={`param${param}${col.id}`}>\n                                      { col.title }\n                                    </option>\n                                  )\n                                  : null }\n                              </>\n                            )) }\n                          </select>\n                        </label>\n                      )) }\n                    </>\n                  )\n                  : (\n                    <>\n                      { selectedFormula.parameters.map((param, i) => (\n                        <>\n                          { i === 0 || i === 2\n                            ? (\n                              <label htmlFor={`param${param}`} key={`param${param}`} className=\"formulaParamInput\">{ param }:\n                                <select name={`param${param}`}>\n                                  { calculators.map((col) => (\n                                    <>\n                                      { col.subType === 'calculator'\n                                        ? (\n                                          <option value={col.id} key={`param${param}${col.id}`}>\n                                            { col.title }\n                                          </option>\n                                        )\n                                        : null }\n                                    </>\n                                  )) }\n                                </select>\n                              </label>\n                            )\n                            : null }\n                        </>\n                      )) }\n                    </>\n                  ) }\n              </div>\n            </>\n          )\n          : null }\n        { selectedType === 'calculator'\n          ? (\n            <p>This will also add the corresponding N column</p>\n          )\n          : null }\n        <input type=\"submit\" className=\"submitButton\" />\n      </form>\n    </div>\n  );\n\n  if (popupStatus) {\n    return (\n      <Popup content={content} closingFunc={closeHandler} />\n    );\n  } else {\n    return null;\n  }\n}\n\nfunction AddColumn(props) {\n  const { columnState, aggregates } = props;\n  const edit = useContext(EditContext);\n  const [popupStatus, setPopupStatus] = useState(false);\n\n  function popupToggle() {\n    setPopupStatus(!popupStatus);\n  }\n\n  if (edit.flag) {\n    return (\n      <>\n        <div id=\"addColumnButtonContainer\">\n          <button type=\"submit\" id=\"addColumnButton\" onClick={popupToggle}>\n            Add new column\n          </button>\n          <AddColumnPopup\n            flag={[popupStatus, setPopupStatus]}\n            columnState={columnState}\n            aggregates={aggregates}\n          />\n        </div>\n      </>\n    );\n  } else {\n    return null;\n  }\n}\n\nexport default AddColumn;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/AddExperiment.js","messages":[{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 51 to the 15 allowed.","line":6,"column":10,"nodeType":null,"endLine":6,"endColumn":28},{"ruleId":"sonarjs/no-collapsible-if","severity":2,"message":"Merge this if statement with the nested one.","line":65,"column":11,"nodeType":null,"endLine":65,"endColumn":13}],"errorCount":2,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useContext, useState } from 'react';\nimport EditContext from './EditContext';\nimport UserContext from './UserContext';\nimport Popup from './Popup';\n\nfunction AddExperimentPopup(props) {\n  const {\n    flag, paper, columns, paperState,\n  } = props;\n  const [popupStatus, setPopupStatus] = flag;\n  const [papers, setPapers] = paperState;\n  const currentUser = useContext(UserContext);\n  let correctInputTypes = true;\n\n  const closeHandler = () => {\n    setPopupStatus(!popupStatus);\n  };\n\n  const createNewExperiment = (experimentDetails) => {\n    const newTime = new Date().getTime();\n    const data = {};\n    for (const pap of paper) {\n      for (const experimentDetail of experimentDetails) {\n        if (experimentDetail[1] === pap.columns.id) {\n          data[pap.columns.id] = {\n            ctime: newTime,\n            enteredBy: currentUser.displayName,\n            value: experimentDetail[0],\n          };\n        }\n      }\n    }\n    for (const pap of paper) {\n      if (!data[pap.columns.id]) {\n        data[paper.columns.id] = null;\n      }\n    }\n    let index;\n    if (paper.experiments.length === 1 && paper.experiments[0].title === null) {\n      index = 0;\n    } else {\n      index = paper.experiments.length;\n    }\n    const expObj = {\n      ctime: newTime,\n      data,\n      enteredBy: currentUser.displayName,\n      index,\n      paper,\n      title: experimentDetails[0][0],\n    };\n    return expObj;\n  };\n\n  const handleSubmit = (e) => {\n    const experimentDetails = [];\n    const children = e.target.children;\n    for (let i = 0; i < children.length; i += 1) {\n      const inputElem = children[i].children[0];\n      if (inputElem) {\n        const colID = inputElem.getAttribute('columnid');\n        const inputType = inputElem.getAttribute('inputtype');\n        if (inputElem.value) {\n          experimentDetails[i] = [inputElem.value, colID];\n          if (inputType === 'number') {\n            if (!parseInt(inputElem.value, 10)) {\n              correctInputTypes = false;\n            }\n          }\n        } else {\n          experimentDetails[i] = [null, colID];\n        }\n      }\n    }\n    const tempPapers = [...papers];\n    if (correctInputTypes) {\n      const newExperiment = createNewExperiment(experimentDetails);\n      if (newExperiment.title) {\n        const paperIndex = tempPapers.indexOf(paper);\n        tempPapers[paperIndex].experiments[newExperiment.index] = newExperiment;\n        closeHandler();\n      }\n    } else {\n      e.target.nextSibling.textContent = 'Ensure correct input types';\n    }\n    setPapers(tempPapers);\n  };\n\n  const content = (\n    <div className=\"addExperimentPopup\">\n      <h1> Add an Experiment to { paper.title } </h1>\n      <form className=\"addExperimentForm\" onSubmit={handleSubmit}>\n        <label htmlFor=\"ExperimentInput\" key=\"experiment\">\n          Experiment type (string) (required):\n          <input type=\"text\" id=\"ExperimentInput\" columnid=\"experiment\" />\n        </label>\n        { columns && columns.map((col) => (\n          (col.type === 'characteristic' && col.sourceColumnMap[paper.id])\n            ? (\n              <label htmlFor={`${col.title.replace(/\\s/g, '')}Input`} key={`labelFor${col.id}`}>\n                { col.title } ({ col.inputType }):\n                <input\n                  type=\"text\"\n                  id={`${col.title.replace(/\\s/g, '')}Input`}\n                  columnid={col.sourceColumnMap[paper.id]}\n                  inputtype={col.inputType}\n                />\n              </label>\n            )\n            : null\n        )) }\n        <input type=\"submit\" value=\"Submit\" className=\"submitButton\" />\n      </form>\n      <p className=\"popupWarn\" />\n    </div>\n  );\n\n  if (popupStatus) {\n    return (\n      <Popup content={content} closingFunc={closeHandler} />\n    );\n  } else {\n    return null;\n  }\n}\n\nfunction AddExperiment(props) {\n  const { paper, columns, paperState } = props;\n  const edit = useContext(EditContext);\n  const [popupStatus, setPopupStatus] = useState(false);\n\n  function popupToggle() {\n    setPopupStatus(!popupStatus);\n  }\n\n  if (edit.flag) {\n    return (\n      <>\n        <button type=\"submit\" className=\"addExperimentButton\" onClick={popupToggle}> + </button>\n        <AddExperimentPopup\n          flag={[popupStatus, setPopupStatus]}\n          paper={paper}\n          columns={columns}\n          paperState={paperState}\n        />\n      </>\n    );\n  } else {\n    return null;\n  }\n}\n\nexport default AddExperiment;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/AddPaper.js","messages":[{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 20 to the 15 allowed.","line":6,"column":10,"nodeType":null,"endLine":6,"endColumn":23}],"errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useContext, useState } from 'react';\nimport EditContext from './EditContext';\nimport UserContext from './UserContext';\nimport Popup from './Popup';\n\nfunction AddPaperPopup(props) {\n  const {\n    flag, paperState, paperOrderValue, metaanalysis,\n  } = props;\n  const [popupStatus, setPopupStatus] = flag;\n  const [papers, setPapers] = paperState;\n  const [paperOrder, setPaperOrder] = paperOrderValue;\n  const currentUser = useContext(UserContext);\n\n  const closeHandler = () => {\n    setPopupStatus(!popupStatus);\n  };\n\n  const createDefaultExperiment = (paperDetails, newTime) => {\n    const expObj = {\n      ctime: newTime,\n      data: {},\n      enteredBy: currentUser.displayName,\n      index: 0,\n      paper: null,\n      title: null,\n    };\n    return expObj;\n  };\n\n  const createNewPaper = (paperDetails) => {\n    const newTime = new Date().getTime();\n    const newId = `id/p/${String(Math.floor(Math.random() * 1000000000000))}`;\n    const newTitle = paperDetails.paperInput;\n    const newRef = paperDetails.referenceInput;\n    let newDesc;\n    if (paperDetails.descriptionInput) {\n      newDesc = paperDetails.descriptionInput;\n    } else {\n      newDesc = null;\n    }\n    let newLink;\n    if (paperDetails.linkInput) {\n      newLink = paperDetails.linkInput;\n    } else {\n      newLink = null;\n    }\n    let newDoi;\n    if (paperDetails.doiInput) {\n      newDoi = paperDetails.doiInput;\n    } else {\n      newDoi = null;\n    }\n    const experiment = createDefaultExperiment(paperDetails, newTime);\n\n    const paperObj = {\n      apiurl: '',\n      columns: [],\n      ctime: newTime,\n      enteredBy: currentUser.displayName,\n      experiments: [experiment],\n      hiddenCols: [],\n      id: newId,\n      metaanalysis,\n      mtime: newTime,\n      tags: [],\n      title: newTitle,\n      reference: newRef,\n      description: newDesc,\n      link: newLink,\n      doi: newDoi,\n    };\n    return paperObj;\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    const paperDetails = {\n      paperInput: null,\n      referenceInput: null,\n      descriptionInput: null,\n      linkInput: null,\n      doiInput: null,\n    };\n    const children = e.target.children;\n    for (const child of children) {\n      const inputElem = child.children[0];\n      if (inputElem && inputElem.value) {\n        paperDetails[inputElem.id] = inputElem.value;\n      }\n    }\n    if (paperDetails.paperInput && paperDetails.referenceInput) {\n      const newPaper = createNewPaper(paperDetails);\n      newPaper.experiments[0].paper = newPaper;\n      setPaperOrder([newPaper.id, ...paperOrder]);\n      setPapers([newPaper, ...papers]);\n      closeHandler();\n    }\n  };\n\n  const content = (\n    <div className=\"addPaperPopup\">\n      <h1> Add a new paper </h1>\n      <form className=\"addPaperForm\" onSubmit={handleSubmit}>\n        <label htmlFor=\"paperInput\">\n          Paper*:\n          <input\n            type=\"text\"\n            id=\"paperInput\"\n            placeholder=\"Enter a shortname for the paper\"\n          />\n        </label>\n        <label htmlFor=\"referenceInput\">\n          Reference*:\n          <input\n            type=\"text\"\n            id=\"referenceInput\"\n            placeholder=\"Author, year, title, journal etc\"\n          />\n        </label>\n        <label htmlFor=\"descriptionInput\">\n          Description:\n          <input\n            type=\"textarea\"\n            id=\"descriptionInput\"\n            placeholder=\"Enter a description of the paper\"\n          />\n        </label>\n        <label htmlFor=\"linkInput\">\n          Link:\n          <input\n            type=\"text\"\n            id=\"linkInput\"\n            placeholder=\"Enter a URL for the paper\"\n          />\n        </label>\n        <label htmlFor=\"doiInput\">\n          DOI:\n          <input\n            type=\"text\"\n            id=\"doiInput\"\n            placeholder=\"Enter a DOI for the paper\"\n          />\n        </label>\n        <input type=\"submit\" value=\"Submit\" className=\"submitButton\" />\n      </form>\n    </div>\n  );\n\n  if (popupStatus) {\n    return (\n      <Popup content={content} closingFunc={closeHandler} />\n    );\n  } else {\n    return null;\n  }\n}\n\nfunction AddPaper(props) {\n  const { paperState, paperOrderValue, metaanalysis } = props;\n  const [papers, setPapers] = paperState;\n  const [paperOrder, setPaperOrder] = paperOrderValue;\n  const edit = useContext(EditContext);\n  const [popupStatus, setPopupStatus] = useState(false);\n\n  function popupToggle() {\n    setPopupStatus(!popupStatus);\n  }\n\n  if (edit.flag) {\n    return (\n      <>\n        <div id=\"addPaperButtonContainer\">\n          <button type=\"submit\" id=\"addPaperButton\" onClick={popupToggle}>\n            Add new paper\n          </button>\n          <AddPaperPopup\n            flag={[popupStatus, setPopupStatus]}\n            paperState={[papers, setPapers]}\n            paperOrderValue={[paperOrder, setPaperOrder]}\n            metaanalysis={metaanalysis}\n          />\n        </div>\n      </>\n    );\n  } else {\n    return ('Paper');\n  }\n}\n\nexport default AddPaper;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/ColumnRearranger.js","messages":[{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 46 to the 15 allowed.","line":23,"column":10,"nodeType":null,"endLine":23,"endColumn":25}],"errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"let xCoord;\nlet originalColumn;\n\nfunction dragOverListener(event) {\n  const hoveredColumn = event.currentTarget;\n  if (xCoord > event.pageX && hoveredColumn !== originalColumn && !hoveredColumn.classList.contains('colRearrangeLeft')) {\n    hoveredColumn.classList.add('colRearrangeLeft');\n  }\n  if (xCoord < event.pageX && hoveredColumn !== originalColumn && !hoveredColumn.classList.contains('colRearrangeRight')) {\n    hoveredColumn.classList.add('colRearrangeRight');\n  }\n}\n\nfunction dragLeaveListener(event) {\n  if (event.currentTarget.classList.contains('colRearrangeLeft')) {\n    event.currentTarget.classList.remove('colRearrangeLeft');\n  }\n  if (event.currentTarget.classList.contains('colRearrangeRight')) {\n    event.currentTarget.classList.remove('colRearrangeRight');\n  }\n}\n\nfunction RearrangeColumn(e, columns, setColumns, moveCols, setMoveCols) {\n  xCoord = e.pageX;\n\n  function clearUp(nodeList) {\n    for (const node of nodeList) {\n      node.removeEventListener('dragleave', dragLeaveListener);\n      node.removeEventListener('dragover', dragOverListener);\n      if (node.classList.contains('colRearrangeLeft')) {\n        node.classList.remove('colRearrangeLeft');\n      }\n      if (node.classList.contains('colRearrangeRight')) {\n        node.classList.remove('colRearrangeRight');\n      }\n    }\n  }\n\n  function handleDragStart() {\n    let columnDomElem;\n    if (e.target.nodeName === 'BUTTON') {\n      columnDomElem = e.target.parentNode;\n    } else {\n      columnDomElem = e.target.parentNode.parentNode;\n    }\n    originalColumn = columnDomElem;\n    const columnType = columnDomElem.getAttribute('columntype');\n    const columnId = columnDomElem.getAttribute('columnid');\n    const columnTypeGroup = columns.filter((col) => col.subType === columnType);\n    let columnBeingMoved;\n    if (columnType !== 'result') {\n      columnBeingMoved = columns.filter((col) => col.id === columnId)[0];\n    } else {\n      columnBeingMoved = columns.filter((col) => col.number === columnId)[0];\n    }\n\n    const allColumnDomElems = columnDomElem.parentNode.children;\n    const columnDomElemTypeGroup = [];\n    for (const column of allColumnDomElems) {\n      const type = column.getAttribute('columntype');\n      if (type && type === columnType) {\n        columnDomElemTypeGroup.push(column);\n      }\n    }\n\n    for (const column of columnDomElemTypeGroup) {\n      column.addEventListener('dragleave', dragLeaveListener);\n      column.addEventListener('dragover', dragOverListener);\n    }\n\n    return {\n      col: [columnBeingMoved, columnDomElem],\n      colGroup: [columnTypeGroup, columnDomElemTypeGroup],\n    };\n  }\n\n  function handleDragEnd() {\n    const [x, y] = [e.clientX, e.clientY];\n\n    const dropElem = document.elementFromPoint(x, y);\n\n    const columnElems = moveCols.colGroup[1];\n\n    clearUp(columnElems);\n\n    if (moveCols.colGroup[1].includes(dropElem) && dropElem !== moveCols.col[1]) {\n      const dropIndex = moveCols.colGroup[1].indexOf(dropElem);\n      const elemIndex = moveCols.colGroup[1].indexOf(moveCols.col[1]);\n      const modGroup = columns.filter((col) => col.subType === 'moderator');\n      const calcGroup = columns.filter((col) => col.subType === 'calculator');\n      const resGroup = columns.filter((col) => col.subType === 'result');\n\n      if (elemIndex !== undefined && dropIndex !== undefined) {\n        let retVal;\n        const tempColGroup = [...moveCols.colGroup[0]];\n\n        if (elemIndex > dropIndex) {\n          tempColGroup.splice(elemIndex, 1);\n          tempColGroup.splice(dropIndex, 0, moveCols.col[0]);\n          switch (moveCols.col[0].subType) {\n          case 'moderator':\n            retVal = tempColGroup.concat(calcGroup.concat(resGroup));\n            break;\n          case 'calculator':\n            retVal = modGroup.concat(tempColGroup.concat(resGroup));\n            break;\n          case 'result':\n            retVal = modGroup.concat(calcGroup.concat(tempColGroup));\n            break;\n          default:\n            retVal = columns;\n          }\n        } else if (elemIndex < dropIndex) {\n          tempColGroup.splice(elemIndex, 1);\n          tempColGroup.splice(dropIndex + 1, 0, moveCols.col[0]);\n          switch (moveCols.col[0].subType) {\n          case 'moderator':\n            retVal = tempColGroup.concat(calcGroup.concat(resGroup));\n            break;\n          case 'calculator':\n            retVal = modGroup.concat(tempColGroup.concat(resGroup));\n            break;\n          case 'result':\n            retVal = modGroup.concat(calcGroup.concat(tempColGroup));\n            break;\n          default:\n            retVal = columns;\n          }\n        }\n        return retVal;\n      }\n    }\n    return columns;\n  }\n\n  if (e.type === 'dragstart') { setMoveCols(handleDragStart()); }\n  if (e.type === 'dragend') {\n    setColumns(handleDragEnd());\n  }\n}\n\nexport default RearrangeColumn;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/Comments.js","messages":[{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 18 to the 15 allowed.","line":11,"column":10,"nodeType":null,"endLine":11,"endColumn":24}],"errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useContext } from 'react';\nimport { formatDateTimeSplit } from '../../tools/datatools';\nimport UserContext from './UserContext';\n\nfunction getComments(comments, cellId) {\n  if (comments[cellId]) {\n    return comments[cellId];\n  } else { return null; }\n}\n\nfunction CommentDisplay(props) {\n  const { cellComments, activeCommentState } = props;\n  const [activeComment, setActiveComment] = activeCommentState;\n  let index = 0;\n  if (cellComments) {\n    for (let i = 0; i < Object.keys(cellComments).length; i += 1) {\n      if (cellComments[i] === activeComment) {\n        index = i;\n      }\n    }\n  }\n  setActiveComment(cellComments[index]);\n\n  function scrollLeft() {\n    if (cellComments[index - 1]) {\n      index -= 1;\n    }\n    setActiveComment(cellComments[index]);\n  }\n  function scrollRight() {\n    if (cellComments[index + 1]) {\n      index += 1;\n    }\n    setActiveComment(cellComments[index]);\n  }\n\n  return (\n    <>\n      <div\n        role=\"button\"\n        tabIndex=\"0\"\n        onClick={cellComments[index - 1] ? scrollLeft : null}\n        onKeyDown={cellComments[index - 1] ? scrollLeft : null}\n        className={cellComments[index - 1] ? 'activeCommentScroller leftCommentScroller' : 'inactiveCommentScroller leftCommentScroller'}\n      >\n        <img\n          src=\"/img/left-arrow-icon.png\"\n          alt=\"scroll left\"\n          className={cellComments[index - 1] ? 'activeCommentScroller' : 'inactiveCommentScroller'}\n        />\n      </div>\n      <div className=\"commentContent\">\n        <p>\n          Posted by\n          { ' ' }\n          { activeComment.user }\n          { ' ' }\n          at\n          { ' ' }\n          { formatDateTimeSplit(activeComment.ctime).time }\n          { ' ' }\n          on\n          { ' ' }\n          { formatDateTimeSplit(activeComment.ctime).date }\n          { ' ' }\n        </p>\n        <p>{ activeComment.text }</p>\n      </div>\n      <div\n        role=\"button\"\n        tabIndex=\"0\"\n        onClick={cellComments[index + 1] ? scrollRight : null}\n        onKeyDown={cellComments[index + 1] ? scrollRight : null}\n        className={cellComments[index + 1] ? 'activeCommentScroller rightCommentScroller' : 'inactiveCommentScroller rightCommentScroller'}\n      >\n        <img\n          src=\"/img/right-arrow-icon.png\"\n          alt=\"scroll left\"\n          className={cellComments[index + 1] ? 'activeCommentScroller' : 'inactiveCommentScroller'}\n        />\n      </div>\n    </>\n  );\n}\n\nfunction PostComment(props) {\n  const {\n    cellDetails,\n    cellComments,\n    commentState,\n    commentFlag,\n  } = props;\n  const [flag, setFlag] = commentFlag;\n  const [comments, setComments] = commentState;\n  const currentUser = useContext(UserContext);\n  let inputValue;\n\n  function toggleFlag() {\n    setFlag(!flag);\n  }\n\n  function handleChange(e) {\n    inputValue = e.target.value;\n  }\n\n  function handleSubmit() {\n    let index;\n    const newTime = new Date().getTime();\n\n    const newComment = {\n      user: currentUser.displayName,\n      ctime: newTime,\n      cellId: cellDetails.cellId,\n      text: inputValue,\n    };\n    toggleFlag();\n\n    function handleComments() {\n      if (!cellComments) {\n        return { 0: newComment };\n      } else {\n        index = Object.keys(cellComments).length;\n        cellComments[index] = newComment;\n        return cellComments;\n      }\n    }\n    const tempComments = { ...comments };\n    if (inputValue.replace(/\\s/g, '')) tempComments[cellDetails.cellId] = handleComments();\n    setComments(tempComments);\n  }\n\n  if (flag) {\n    return (\n      <>\n        <div className=\"postCommentActive\">\n          <div\n            role=\"button\"\n            tabIndex=\"0\"\n            onClick={toggleFlag}\n            onKeyDown={toggleFlag}\n            className=\"postCommentClose\"\n          >\n            x\n          </div>\n          <form onSubmit={handleSubmit}>\n            <textarea\n              rows=\"4\"\n              placeholder=\"Type your comment\"\n              value={inputValue}\n              onChange={handleChange}\n              className=\"postCommentInput\"\n            />\n            <input\n              type=\"submit\"\n              value=\"Post Comment\"\n              className=\"postCommentSubmit\"\n            />\n          </form>\n        </div>\n      </>\n    );\n  } else {\n    return (\n      <>\n        <div\n          role=\"button\"\n          tabIndex=\"0\"\n          onClick={toggleFlag}\n          onKeyDown={toggleFlag}\n          className=\"postCommentInactive\"\n        >\n          Post a comment\n        </div>\n      </>\n    );\n  }\n}\n\nfunction Comments(props) {\n  const { cellDetails, commentFlag, commentState } = props;\n  const [comments] = commentState;\n  const cellComments = getComments(comments, cellDetails.cellId);\n  const [activeComment, setActiveComment] = useState([]);\n  const currentUser = useContext(UserContext);\n  const [flag] = commentFlag;\n  return (\n    <div className=\"commentContainer\">\n      <div className=\"commentHolderOuter\">\n        Comments\n        <div className=\"commentHolderInner\">\n          <div className=\"commentText\">\n            { !flag && cellComments\n              ? (\n                <CommentDisplay\n                  cellComments={cellComments}\n                  activeCommentState={[activeComment, setActiveComment]}\n                />\n              )\n              : null }\n            { !cellComments\n              ? (\n                <p>\n                  No comments to display\n                </p>\n              )\n              : null }\n          </div>\n          <div className=\"postComment\">\n            { currentUser\n              ? (\n                <PostComment\n                  cellDetails={cellDetails}\n                  cellComments={cellComments}\n                  commentState={commentState}\n                  commentFlag={commentFlag}\n                />\n              )\n              : null }\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default Comments;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/Details.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/EditContext.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/Editable.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/Info.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/Metaanalysis.js","messages":[{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 44 to the 15 allowed.","line":18,"column":10,"nodeType":null,"endLine":18,"endColumn":22}],"errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useContext } from 'react';\nimport Tabs from '../layout/Tabs';\nimport Info from './Info';\nimport DataTable from './datatable/DataTable';\nimport Aggregates from './aggregates/Aggregates';\nimport PlotSelector from './plots/PlotSelector';\nimport Metadata from './Metadata';\nimport Details from './Details';\nimport EditContext from './EditContext';\nimport UserContext from './UserContext';\n\nimport { populateCircularMa, getDatumValue } from '../../tools/datatools';\nimport replaceCell from '../../tools/editTools';\nimport modifyColumns from '../../tools/modifyColumns';\n\nimport './Metaanalysis.css';\n\nfunction Metaanalysis(props) {\n  const { metaanalysis } = props;\n  populateCircularMa(metaanalysis);\n  window.currentMa = metaanalysis;\n\n  const [title] = useState(metaanalysis.title);\n  const [description, setDescription] = useState(metaanalysis.description);\n  const [published, setPublished] = useState(metaanalysis.published);\n  const [columns, setColumns] = useState(metaanalysis.columns);\n  const [papers, setPapers] = useState(metaanalysis.papers);\n  const [paperOrder, setPaperOrder] = useState(metaanalysis.paperOrder);\n  const [aggregates, setAggregates] = useState(metaanalysis.aggregates);\n  const [groupingAggregates, setGroupingAggregates] = useState(metaanalysis.groupingAggregates);\n  const [graphs, setGraphs] = useState(metaanalysis.graphs);\n  const [metadata] = useState({\n    enteredByUsername: metaanalysis.enteredByUsername,\n    ctime: metaanalysis.ctime,\n    mtime: metaanalysis.mtime,\n  });\n  const [displayedCell, setDisplayedCell] = useState({\n    cellId: null,\n    text: null,\n  });\n  const edit = useContext(EditContext);\n  const currentUser = useContext(UserContext);\n\n  const columnsClone = modifyColumns(columns);\n  const moderators = columns.filter((col) => col.subType === 'moderator');\n  const moderatorsWithGroups = [];\n  for (let i = 0; i < moderators.length; i += 1) {\n    const groups = [];\n    for (const paper of papers) {\n      for (const exp of paper.experiments) {\n        if (!exp.excluded) {\n          const group = getDatumValue(moderators[i], exp);\n          if (group != null && group !== '' && groups.indexOf(group) === -1) {\n            groups.push(group);\n          }\n        }\n      }\n    }\n    const groupsWithIncluded = [];\n    for (let j = 0; j < groups.length; j += 1) {\n      groupsWithIncluded[j] = {\n        group: groups[j],\n        included: true,\n      };\n    }\n    moderatorsWithGroups[i] = {\n      moderatorObj: moderators[i],\n      groups: groupsWithIncluded,\n      included: true,\n    };\n  }\n  moderatorsWithGroups.sort((a, b) => {\n    if (a.groups.length < b.groups.length) {\n      return -1;\n    }\n    if (a.groups.length > b.groups.length) {\n      return 1;\n    }\n    return 0;\n  });\n\n  const assignGraphId = (graphObjs) => {\n    for (let i = 0; i < graphObjs.length; i += 1) {\n      graphs[i].id = i;\n    }\n  };\n  assignGraphId(graphs);\n\n  const makeClickable = (cellId, details, cellType, defaultClass) => {\n    let className = defaultClass || '';\n    if (displayedCell && cellId === displayedCell.cellId) className += ' active ';\n    if (cellType === 'computed') {\n      className += `computed ${edit.flag ? 'editMode cell' : ''}`;\n    } else if (cellType === 'paper') {\n      className += `paper ${edit.flag ? 'editMode cell' : ''}`;\n    }\n\n    return {\n      onClick: () => {\n        setDisplayedCell({ text: details, cellId });\n      },\n      className,\n    };\n  };\n\n  const editCell = (value, cellId) => {\n    setPapers(replaceCell(papers, columnsClone, value, cellId, currentUser));\n  };\n  return (\n    <main className=\"metaanalysis\">\n      <div className={`titlebar ${edit.flag ? 'editMode primary' : ''}`}>\n        <div className=\"title\">\n          <p type=\"input\">{ title }</p>\n        </div>\n        <div className=\"titleBarButtons\">\n          { /* <TagList tags={tags} setTags={setTags} /> */ }\n          { currentUser\n            ? (\n              <span\n                id=\"toggle-editing\"\n                role=\"menuitem\"\n                tabIndex=\"0\"\n                onMouseDown={edit.toggle}\n                onKeyPress={edit.toggle}\n                className={`${edit.flag ? 'editMode' : ''}`}\n              >\n                { edit.flag ? 'Stop editing' : 'Edit' }\n              </span>\n            )\n            : (\n              <span\n                id=\"toggle-editing-inactive\"\n                role=\"menuitem\"\n                tabIndex=\"0\"\n              >\n                Sign in to edit\n              </span>\n            ) }\n        </div>\n      </div>\n      <Tabs displayedCell={displayedCell} setDisplayedCell={setDisplayedCell}>\n        <Info\n          path=\"/info\"\n          tabName=\"Info\"\n          description={description}\n          setDescription={setDescription}\n          published={published}\n          setPublished={setPublished}\n        />\n        <DataTable\n          path=\"/table\"\n          tabName=\"Table\"\n          columnState={[columnsClone, setColumns]}\n          papers={[papers, setPapers]}\n          paperOrderValue={[paperOrder, setPaperOrder]}\n          makeClickable={makeClickable}\n          editCell={editCell}\n          metaanalysis={metaanalysis}\n          aggregates={aggregates}\n        />\n        <Aggregates\n          path=\"/aggregates\"\n          tabName=\"Analyses\"\n          aggregatesState={[aggregates, setAggregates]}\n          groupingAggregatesState={[groupingAggregates, setGroupingAggregates]}\n          groupingColumn={\n            metaanalysis.groupingColumnObj ? metaanalysis.groupingColumnObj.title : undefined\n          }\n          groups={metaanalysis.groups}\n          makeClickable={makeClickable}\n          moderatorsWithGroups={moderatorsWithGroups}\n          columns={columnsClone}\n          metaanalysis={metaanalysis}\n        />\n        <PlotSelector\n          path=\"/plots\"\n          tabName=\"Plots\"\n          graphState={[graphs, setGraphs]}\n          columns={columnsClone}\n          metaanalysis={metaanalysis}\n        />\n      </Tabs>\n      <Details displayedCell={displayedCell} setDisplayedCell={setDisplayedCell} />\n      <Metadata metadata={metadata} />\n    </main>\n  );\n}\n\nexport default Metaanalysis;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/Metadata.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/PlotsDefinitions.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/Popup.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/RowRearranger.js","messages":[{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 33 to the 15 allowed.","line":37,"column":10,"nodeType":null,"endLine":37,"endColumn":22}],"errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Function fires when user drags/drops a grabber icon in edit mode\nlet yCoord;\nlet originalRow;\n\nfunction dragOverListener(event) {\n  let topElem = event.target;\n  let bottomElem = event.target;\n  while (topElem.nodeName !== 'TR') {\n    topElem = topElem.parentNode;\n  }\n  while (bottomElem.nodeName !== 'TR') {\n    bottomElem = bottomElem.parentNode;\n  }\n  while (!topElem.classList.contains('paperstart')) {\n    topElem = topElem.previousSibling;\n  }\n  while (!bottomElem.nextSibling.classList.contains('paperstart')) {\n    bottomElem = bottomElem.nextSibling;\n  }\n  if (yCoord > event.pageY && topElem !== originalRow) {\n    topElem.classList.add('rowRearrangeAbove');\n  } else if (yCoord < event.pageY && topElem !== originalRow) {\n    bottomElem.classList.add('rowRearrangeBelow');\n  }\n}\nfunction dragLeaveListener() {\n  const rowsWithClass1 = document.querySelectorAll('.rowRearrangeAbove');\n  const rowsWithClass2 = document.querySelectorAll('.rowRearrangeBelow');\n  for (const row of rowsWithClass1) {\n    row.classList.remove('rowRearrangeAbove');\n  }\n  for (const row of rowsWithClass2) {\n    row.classList.remove('rowRearrangeBelow');\n  }\n}\n\nfunction RearrangeRow(rowEvent, setRowEvent, parentOfRows, e, papers, paperOrderValue) {\n  const [paperState, setPaperState] = papers;\n  const [paperOrder, setPaperOrder] = paperOrderValue;\n  /* Accepts the top row of all rows associated with a specific paper in the datatabble\n  Returns all rows associated with the specific paper that the accepted row belongs to */\n  function getRelatedRows(currentRow) {\n    const relatedRows = [currentRow];\n    while (!currentRow.nextSibling.classList.contains('paperstart')) {\n      relatedRows.push(currentRow.nextSibling);\n      currentRow = currentRow.nextSibling;\n    }\n    return relatedRows;\n  }\n\n  /* Fires on dragstart browser event\n  Returns all rows associated with dragged row, index of top row */\n  function handleDragStart() {\n    yCoord = e.pageY;\n    for (const row of parentOfRows) {\n      const elem = row.current.children;\n      elem.addEventListener('dragover', dragOverListener);\n      elem.addEventListener('dragleave', dragLeaveListener);\n    }\n\n    let thisElement;\n    if (e.target.nodeName === 'BUTTON') {\n      thisElement = e.target;\n    } else {\n      thisElement = e.target.parentNode;\n    }\n\n    const relatedRow = thisElement.parentNode.parentNode;\n    originalRow = relatedRow;\n    const rowsToMove = getRelatedRows(relatedRow);\n    rowsToMove.forEach((element) => {\n      element.classList.add('beingRearranged');\n    });\n\n    let k = 0;\n    let currentElement = parentOfRows.current.children[0];\n    while (currentElement !== relatedRow) {\n      if (currentElement.classList.contains('paperstart')) {\n        k += 1;\n      }\n      currentElement = currentElement.nextSibling;\n    }\n\n    return { rows: rowsToMove, topRowIndex: k };\n  }\n\n  function handleDragEnd(rowsToDrop) {\n    const yDropCoord = e.pageY;\n\n    function calcOffset(y1, y2) {\n      return y2 - y1;\n    }\n\n    function getTopRow(elem, index) {\n      while (!elem.classList.contains('paperstart')) {\n        index -= 1;\n        elem = elem.parentNode.childNodes[index];\n      }\n      return elem;\n    }\n\n    let i = 0;\n    const bodyRect = document.body.getBoundingClientRect().top;\n    let offset = calcOffset(\n      bodyRect,\n      parentOfRows.current.childNodes[i].getBoundingClientRect().top,\n    );\n\n    while (offset < yDropCoord && i < 1000) {\n      offset = calcOffset(\n        bodyRect,\n        parentOfRows.current.childNodes[i].getBoundingClientRect().top,\n      );\n      i += 1;\n    }\n\n    const topRow = getTopRow(parentOfRows.current.childNodes[i], i);\n\n    let k = 0;\n    let thisElement = parentOfRows.current.children[0];\n    while (topRow !== thisElement) {\n      if (thisElement.classList.contains('paperstart')) {\n        k += 1;\n      }\n      thisElement = thisElement.nextSibling;\n    }\n\n    const tempPapers = [...paperState];\n    const tempPaperOrder = [...paperOrder];\n\n    if (yCoord < yDropCoord) {\n      tempPapers.splice(rowsToDrop.topRowIndex, 1);\n      tempPapers.splice(k, 0, paperState[rowsToDrop.topRowIndex]);\n      tempPaperOrder.splice(rowsToDrop.topRowIndex, 1);\n      tempPaperOrder.splice(k, 0, paperOrder[rowsToDrop.topRowIndex]);\n    }\n    if (yCoord > yDropCoord) {\n      tempPapers.splice(rowsToDrop.topRowIndex, 1);\n      tempPapers.splice(k - 1, 0, paperState[rowsToDrop.topRowIndex]);\n      tempPaperOrder.splice(rowsToDrop.topRowIndex, 1);\n      tempPaperOrder.splice(k - 1, 0, paperOrder[rowsToDrop.topRowIndex]);\n    }\n\n    setPaperState(tempPapers);\n    setPaperOrder(tempPaperOrder);\n\n    rowsToDrop.rows.forEach((element) => {\n      element.classList.remove('beingRearranged');\n    });\n    for (const row of parentOfRows) {\n      const elem = row.current.children;\n      elem.removeEventListener('dragover', dragOverListener);\n      elem.removeEventListener('dragleave', dragLeaveListener);\n    }\n    const finalHover = document.getElementsByClassName('tableRearrangeHover');\n    if (finalHover[0]) {\n      finalHover[0].classList.remove('tableRearrangeHover');\n    }\n  }\n\n  if (e.type === 'dragstart') { setRowEvent(handleDragStart()); }\n  if (e.type === 'dragend') { handleDragEnd(rowEvent); }\n}\n\nexport default RearrangeRow;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/UserContext.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/aggregates/AddAnalysis.js","messages":[{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 32 to the 15 allowed.","line":5,"column":10,"nodeType":null,"endLine":5,"endColumn":26}],"errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useContext } from 'react';\nimport EditContext from '../EditContext';\nimport Popup from '../Popup';\n\nfunction AddAnalysisPopup(props) {\n  const {\n    flag, formulaFunctions, columns, aggregatesState, metaanalysis, type,\n  } = props;\n  const [popupStatus, setPopupStatus] = flag;\n  const [aggregates, setAggregates] = aggregatesState;\n  const aggregatesClone = [...aggregates];\n  const [formulaState, setFormulaState] = useState(formulaFunctions[0]);\n  const numberColumns = columns.filter((col) => col.subType !== type);\n  const formulaOptions = numberColumns.concat(aggregates);\n\n  const closeHandler = () => {\n    setPopupStatus(!popupStatus);\n  };\n\n  const handleFormulaChange = (e) => {\n    const formulaId = e.currentTarget.value;\n    let currentFormula = { ...formulaState };\n    for (const formula of formulaFunctions) {\n      if (formula.id === formulaId) {\n        currentFormula = formula;\n      }\n    }\n    setFormulaState(currentFormula);\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    const params = [];\n    let title;\n    for (const target of e.currentTarget) {\n      if (target.children.classList.contains('paramSelect')) {\n        const param = target.children.children[0];\n        params.push(formulaOptions.filter((col) => col.title === param.value)[0]);\n      }\n      if (target.children.classList.contains('inputTitle')) {\n        title = target.children.children[0].value;\n      }\n    }\n    if (!title) title = `${type} analysis #${aggregates.length + 1}`;\n    let newAnalysis;\n    if (params.length === 1) {\n      newAnalysis = {\n        formula: `${formulaState.id}(${params[0].formula || params[0].id})`,\n        formulaName: formulaState.id,\n        formulaObj: formulaState,\n        formulaParams: params,\n        fullLabel: `${formulaState.label}(${params[0].formulaObj ? params[0].fullLabel : params[0].title})`,\n        metaanalysis,\n        title,\n      };\n    } else if (params.length === 2) {\n      newAnalysis = {\n        formula: `${formulaState.id}(${params[0].formula || params[0].id}, ${params[1].formula || params[1].id})`,\n        formulaName: formulaState.id,\n        formulaObj: formulaState,\n        formulaParams: params,\n        fullLabel: `${formulaState.label}(${params[0].formulaObj ? params[0].fullLabel : params[0].title}, ${params[1].formulaObj ? params[1].fullLabel : params[1].title})`,\n        metaanalysis,\n        title,\n      };\n    }\n    aggregatesClone.unshift(newAnalysis);\n    setAggregates(aggregatesClone);\n    closeHandler();\n  };\n\n  const content = (\n    <>\n      <h1>Add new { type } analysis</h1>\n      <form id=\"inputForm\" onSubmit={handleSubmit}>\n        <label htmlFor=\"inputTitle\" className=\"inputTitle\">Title:\n          <input type=\"text\" />\n        </label>\n        <label htmlFor=\"input\">Select calculation formula:\n          <select name=\"input\" onChange={handleFormulaChange}>\n            { formulaFunctions.map((formula) => (\n              <option key={`input${formula.id}`} value={formula.id}>\n                { formula.label }\n              </option>\n            )) }\n          </select>\n        </label>\n        { formulaState.parameters.map((param) => (\n          <label htmlFor={`input${formulaState.id}${param}`} key={`input${formulaState.id}${param}`} className=\"paramSelect\">{ param }:\n            <select name={`input${formulaState.id}${param}`}>\n              { formulaOptions.map((col) => (\n                <option key={`input${formulaState.id}${param}${col.title}`} value={col.title}>\n                  { col.title }\n                </option>\n              )) }\n            </select>\n          </label>\n        )) }\n        <input type=\"submit\" className=\"submitButton\" />\n      </form>\n    </>\n  );\n\n  if (popupStatus) {\n    return (\n      <Popup content={content} closingFunc={closeHandler} />\n    );\n  } else {\n    return null;\n  }\n}\n\nfunction AddAnalysis(props) {\n  const {\n    formulaFunctions, columns, aggregatesState, metaanalysis, type,\n  } = props;\n  const edit = useContext(EditContext);\n  const [popupStatus, setPopupStatus] = useState(false);\n\n  function popupToggle() {\n    setPopupStatus(!popupStatus);\n  }\n\n  if (edit.flag) {\n    return (\n      <>\n        <div role=\"button\" type=\"submit\" className=\"addAnalysisButton\" onClick={popupToggle} onKeyDown={popupToggle} tabIndex={0}>Add new { type } analysis</div>\n        <AddAnalysisPopup\n          flag={[popupStatus, setPopupStatus]}\n          formulaFunctions={formulaFunctions}\n          columns={columns}\n          aggregatesState={aggregatesState}\n          metaanalysis={metaanalysis}\n          type={type}\n        />\n      </>\n    );\n  } else {\n    return null;\n  }\n}\n\nexport default AddAnalysis;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/aggregates/Aggregates.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/aggregates/FilterModerators.js","messages":[{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 26 to the 15 allowed.","line":5,"column":10,"nodeType":null,"endLine":5,"endColumn":31}],"errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useContext, useState } from 'react';\nimport EditContext from '../EditContext';\nimport Popup from '../Popup';\n\nfunction FilterModeratorsPopup(props) {\n  const { flag, mwgState } = props;\n  const [moderatorsWithGroups, setModeratorsWithGroups] = mwgState;\n  const [popupStatus, setPopupStatus] = flag;\n  const groupFilterFlag = {};\n\n  for (const moderator of moderatorsWithGroups) {\n    groupFilterFlag[moderator.moderatorObj.title] = false;\n  }\n\n  const [groupFlagState, setGroupFlagState] = useState(groupFilterFlag);\n\n  function toggleGroupFlagState(id) {\n    const flagStateClone = { ...groupFlagState };\n    flagStateClone[id] = !flagStateClone[id];\n    setGroupFlagState(flagStateClone);\n  }\n\n  const closeHandler = () => {\n    setPopupStatus(!popupStatus);\n  };\n\n  function handleSubmit(e) {\n    e.preventDefault();\n    closeHandler();\n  }\n\n  function handleModToggle(e) {\n    const modTitle = e.currentTarget.value;\n    const mwgClone = [...moderatorsWithGroups];\n    for (const clone of mwgClone) {\n      if (clone.moderatorObj.title === modTitle) {\n        clone.included = !clone.included;\n      }\n    }\n    setModeratorsWithGroups(mwgClone);\n  }\n\n  function handleGroupToggle(e) {\n    const [modTitle, groupTitle] = e.currentTarget.value.split('+');\n    const mwgClone = [...moderatorsWithGroups];\n    for (const clone of mwgClone) {\n      if (clone.moderatorObj.title === modTitle) {\n        for (const cg of clone.groups) {\n          if (cg.group === groupTitle) {\n            cg.included = !cg.included;\n          }\n        }\n      }\n    }\n    setModeratorsWithGroups(mwgClone);\n  }\n\n  const content = (\n    <>\n      <h1>Select which moderators are to be displayed</h1>\n      <form onSubmit={handleSubmit} id=\"modFilterForm\">\n        { moderatorsWithGroups.map((mod) => (\n          <>\n            <div>\n              <label htmlFor={`modFilter${mod.moderatorObj.title}`} key={`modFilter${mod.moderatorObj.title}`}>{ mod.moderatorObj.title }\n                <input\n                  type=\"checkbox\"\n                  value={mod.moderatorObj.title}\n                  name={`modFilter${mod.moderatorObj.title}`}\n                  checked={!!mod.included}\n                  onChange={handleModToggle}\n                />\n              </label>\n              <div\n                role=\"button\"\n                tabIndex={0}\n                key={`modFilter${mod.moderatorObj.title}GroupButton`}\n                onClick={() => toggleGroupFlagState(mod.moderatorObj.title)}\n                onKeyPress={() => toggleGroupFlagState(mod.moderatorObj.title)}\n                className=\"groupToggleButton\"\n              >\n                { groupFlagState[mod.moderatorObj.title] ? 'Hide groups' : 'Show groups' }\n              </div>\n              { groupFlagState[mod.moderatorObj.title]\n                ? mod.groups.map((group) => (\n                  <label className=\"indent\" htmlFor={`${mod.moderatorObj.title}${group.group}`} key={`${mod.moderatorObj.title}${group.group}`}>{ group.group }:\n                    <input\n                      type=\"checkbox\"\n                      value={`${mod.moderatorObj.title}+${group.group}`}\n                      name={`${mod.moderatorObj.title}${group.group}`}\n                      checked={!!group.included}\n                      onChange={handleGroupToggle}\n                    />\n                  </label>\n                ))\n                : null }\n            </div>\n          </>\n        )) }\n        <input type=\"submit\" className=\"submitButton\" value=\"Done\" />\n      </form>\n    </>\n  );\n\n  if (popupStatus) {\n    return <Popup content={content} closingFunc={closeHandler} />;\n  } else {\n    return null;\n  }\n}\n\nfunction FilterModerators(props) {\n  const { mwgState } = props;\n  const edit = useContext(EditContext);\n  const [popupStatus, setPopupStatus] = useState(false);\n\n  function popupToggle() {\n    setPopupStatus(!popupStatus);\n  }\n\n  if (edit.flag) {\n    return (\n      <>\n        <div role=\"button\" tabIndex={0} type=\"submit\" id=\"filterModeratorsButton\" onClick={popupToggle} onKeyDown={popupToggle}>\n          Filter moderators\n        </div>\n        <FilterModeratorsPopup flag={[popupStatus, setPopupStatus]} mwgState={mwgState} />\n      </>\n    );\n  } else {\n    return null;\n  }\n}\n\nexport default FilterModerators;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/aggregates/Formulas.js","messages":[{"ruleId":"sonarjs/no-duplicate-string","severity":2,"message":"Define a constant instead of duplicating this literal 4 times.","line":478,"column":22,"nodeType":"Literal","endLine":478,"endColumn":39},{"ruleId":"sonarjs/no-duplicate-string","severity":2,"message":"Define a constant instead of duplicating this literal 4 times.","line":478,"column":54,"nodeType":"Literal","endLine":478,"endColumn":71},{"ruleId":"sonarjs/no-duplicate-string","severity":2,"message":"Define a constant instead of duplicating this literal 4 times.","line":484,"column":22,"nodeType":"Literal","endLine":484,"endColumn":43},{"ruleId":"sonarjs/no-duplicate-string","severity":2,"message":"Define a constant instead of duplicating this literal 4 times.","line":484,"column":58,"nodeType":"Literal","endLine":484,"endColumn":79},{"ruleId":"sonarjs/no-duplicate-string","severity":2,"message":"Define a constant instead of duplicating this literal 4 times.","line":490,"column":22,"nodeType":"Literal","endLine":490,"endColumn":50},{"ruleId":"sonarjs/no-duplicate-string","severity":2,"message":"Define a constant instead of duplicating this literal 4 times.","line":490,"column":65,"nodeType":"Literal","endLine":490,"endColumn":93}],"errorCount":6,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"function formulas() {\n  function strictToNumber(val) {\n    if (typeof val === 'number') return val;\n    if (typeof val === 'string') {\n      if (val === '') return NaN;\n      else return Number(val);\n    }\n    return NaN;\n  }\n\n  function strictToNumberOrNull(val) {\n    if (val === null) return val;\n    if (typeof val === 'number') return val;\n    if (typeof val === 'string') {\n      if (val === '') return null;\n      else return Number(val);\n    }\n    return NaN;\n  }\n\n  function valueOrArrayItem(arr, index) {\n    if (Array.isArray(arr)) return arr[index];\n\n    return arr;\n  }\n\n  // adapted from gamma.js at https://github.com/substack/gamma.js\n  function calcChisqDistR() {\n    // transliterated from the python snippet here:\n    // http://en.wikipedia.org/wiki/Lanczos_approximation\n\n    const gLn = 607 / 128;\n    const pLn = [\n      0.99999999999999709182,\n      57.156235665862923517,\n      -59.597960355475491248,\n      14.136097974741747174,\n      -0.49191381609762019978,\n      0.33994649984811888699e-4,\n      0.46523628927048575665e-4,\n      -0.98374475304879564677e-4,\n      0.15808870322491248884e-3,\n      -0.21026444172410488319e-3,\n      0.21743961811521264320e-3,\n      -0.16431810653676389022e-3,\n      0.84418223983852743293e-4,\n      -0.26190838401581408670e-4,\n      0.36899182659531622704e-5,\n    ];\n\n    // Spouge approximation (suitable for large arguments)\n    function LogGamma(z) {\n      if (z < 0) return Number('0/0');\n      let x = pLn[0];\n      for (let i = pLn.length - 1; i > 0; i -= 1) x += pLn[i] / (z + i);\n      const t = z + gLn + 0.5;\n      return 0.5 * Math.log(2 * Math.PI) + (z + 0.5) * Math.log(t) - t + Math.log(x) - Math.log(z);\n    }\n\n    // adapted from chi-squared.js at https://github.com/substack/chi-squared.js\n\n    // according to chi-squared.js: The following code liberated from\n    // http://www.math.ucla.edu/~tom/distributions/chisq.html\n\n    function Gcf(X, A) {\n      // Good for X>A+1\n      let A0 = 0;\n      let B0 = 1;\n      let A1 = 1;\n      let B1 = X;\n      let AOLD = 0;\n      let N = 0;\n      while (Math.abs((A1 - AOLD) / A1) > 0.00001) {\n        AOLD = A1;\n        N += 1;\n        A0 = A1 + (N - A) * A0;\n        B0 = B1 + (N - A) * B0;\n        A1 = X * A0 + N * A1;\n        B1 = X * B0 + N * B1;\n        A0 /= B1;\n        B0 /= B1;\n        A1 /= B1;\n        B1 = 1;\n      }\n      const Prob = Math.exp(A * Math.log(X) - X - LogGamma(A)) * A1;\n      return 1 - Prob;\n    }\n\n    function Gser(X, A) {\n      // Good for X<A+1.\n      let T9 = 1 / A;\n      let G = T9;\n      let I = 1;\n      while (T9 > G * 0.00001) {\n        T9 *= X / (A + I);\n        G += T9;\n        I += 1;\n      }\n      G *= Math.exp(A * Math.log(X) - X - LogGamma(A));\n      return G;\n    }\n\n    function Gammacdf(x, a) {\n      let GI;\n      if (x <= 0) {\n        GI = 0;\n      } else if (x < a + 1) {\n        GI = Gser(x, a);\n      } else {\n        GI = Gcf(x, a);\n      }\n      return GI;\n    }\n\n    function cdf(Z, DF) {\n      if (DF <= 0) {\n        throw new Error('Degrees of freedom must be positive');\n      }\n      return Gammacdf(Z / 2, DF / 2);\n    }\n\n    // 1-cdf gives us the CHISQ.DIST.RT Excel value, according to\n    // wikipedia https://en.wikipedia.org/wiki/Chi-squared_distribution#Table_of_.CF.872_values_vs_p-values\n    return (v, df) => 1 - cdf(v, df);\n  }\n\n  const chisqDistRt = calcChisqDistR();\n\n  /* simple formulas\n   *\n   *\n   *    ####  # #    # #####  #      ######\n   *   #      # ##  ## #    # #      #\n   *    ####  # # ## # #    # #      #####\n   *        # # #    # #####  #      #\n   *   #    # # #    # #      #      #\n   *    ####  # #    # #      ###### ######\n   *\n   *    ######  ####  #####  #    # #    # #        ##    ####\n   *    #      #    # #    # ##  ## #    # #       #  #  #\n   *    #####  #    # #    # # ## # #    # #      #    #  ####\n   *    #      #    # #####  #    # #    # #      ######      #\n   *    #      #    # #   #  #    # #    # #      #    # #    #\n   *    #       ####  #    # #    #  ####  ###### #    #  ####\n   *\n   *\n   */\n\n  function logOddsRatio(group1, group2) {\n    // validate the input\n    group1 = strictToNumber(group1);\n    group2 = strictToNumber(group2);\n\n    // perform the calculation\n    // may return NaN or infinities\n    return Math.log((group1 / (1 - group1)) / (group2 / (1 - group2)));\n  }\n\n  function logOddsRatioPercent(group1, group2) {\n    // validate the input\n    group1 = strictToNumber(group1);\n    group2 = strictToNumber(group2);\n\n    // perform the calculation\n    // may return NaN or infinities\n    return logOddsRatio(group1 / 100, group2 / 100);\n  }\n\n  function logOddsRatioNumber(group1, n1, group2, n2) {\n    // validate the input\n    group1 = strictToNumber(group1);\n    group2 = strictToNumber(group2);\n    n1 = strictToNumber(n1);\n    n2 = strictToNumber(n2);\n\n    // perform the calculation\n    // may return NaN or infinities\n    return logOddsRatio(group1 / n1, group2 / n2);\n  }\n\n  function letiance(Me, Ne, Mc, Nc) {\n    // validate the input\n    Me = strictToNumber(Me);\n    Ne = strictToNumber(Ne);\n    Mc = strictToNumber(Mc);\n    Nc = strictToNumber(Nc);\n\n    // perform the calculation\n    // may return NaN or infinities\n    return 1 / (Me * Ne) + 1 / ((1 - Me) * Ne) + 1 / (Mc * Nc) + 1 / ((1 - Mc) * Nc);\n  }\n\n  function weight(Me, Ne, Mc, Nc) {\n    return 1 / letiance(Me, Ne, Mc, Nc);\n  }\n\n  function weightPercent(Me, Ne, Mc, Nc) {\n    return weight(Me / 100, Ne, Mc / 100, Nc);\n  }\n\n  function weightNumber(Me, Ne, Mc, Nc) {\n    return weight(Me / Ne, Ne, Mc / Nc, Nc);\n  }\n\n  function standardError(Me, Ne, Mc, Nc) {\n    return Math.sqrt(letiance(Me, Ne, Mc, Nc));\n  }\n\n  function lowerConfidenceLimit(Me, Ne, Mc, Nc) {\n    return logOddsRatio(Me, Mc) - 1.96 * standardError(Me, Ne, Mc, Nc);\n  }\n\n  function upperConfidenceLimit(Me, Ne, Mc, Nc) {\n    return logOddsRatio(Me, Mc) + 1.96 * standardError(Me, Ne, Mc, Nc);\n  }\n\n  function lowerConfidenceLimitPercent(Me, Ne, Mc, Nc) {\n    return lowerConfidenceLimit(Me / 100, Ne, Mc / 100, Nc);\n  }\n\n  function upperConfidenceLimitPercent(Me, Ne, Mc, Nc) {\n    return upperConfidenceLimit(Me / 100, Ne, Mc / 100, Nc);\n  }\n\n  function lowerConfidenceLimitNumber(Me, Ne, Mc, Nc) {\n    return lowerConfidenceLimit(Me / Ne, Ne, Mc / Nc, Nc);\n  }\n\n  function upperConfidenceLimitNumber(Me, Ne, Mc, Nc) {\n    return upperConfidenceLimit(Me / Ne, Ne, Mc / Nc, Nc);\n  }\n\n  function fixedEffectError(es, wt, gwmes) {\n    es = strictToNumber(es);\n    wt = strictToNumber(wt);\n    gwmes = strictToNumber(gwmes);\n\n    return wt * ((es - gwmes) ** 2);\n  }\n\n  function randomEffectWeight(Me, Ne, Mc, Nc, tauSquared) {\n    return 1 / (letiance(Me, Ne, Mc, Nc) + tauSquared);\n  }\n\n  function randomEffectWeightPercent(Me, Ne, Mc, Nc, tauSquared) {\n    return randomEffectWeight(Me / 100, Ne, Mc / 100, Nc, tauSquared);\n  }\n\n  function randomEffectWeightNumber(Me, Ne, Mc, Nc, tauSquared) {\n    return randomEffectWeight(Me / Ne, Ne, Mc / Nc, Nc, tauSquared);\n  }\n\n  /* aggregates\n   *\n   *\n   *     ##    ####   ####  #####  ######  ####    ##   ##### ######  ####\n   *    #  #  #    # #    # #    # #      #    #  #  #    #   #      #\n   *   #    # #      #      #    # #####  #      #    #   #   #####   ####\n   *   ###### #  ### #  ### #####  #      #  ### ######   #   #           #\n   *   #    # #    # #    # #   #  #      #    # #    #   #   #      #    #\n   *   #    #  ####   ####  #    # ######  ####  #    #   #   ######  ####\n   *\n   *\n   */\n\n  function sumAggr(valueArray) {\n    if (!Array.isArray(valueArray)) return valueArray;\n\n    if (valueArray.length === 0) return null;\n\n    let total = 0;\n    valueArray.forEach((value) => {\n      total += strictToNumberOrNull(value);\n    });\n\n    return total;\n  }\n\n  function countAggr(valueArray) {\n    if (!Array.isArray(valueArray)) valueArray = [valueArray];\n\n    let retval = 0;\n    valueArray.forEach((x) => {\n      if (strictToNumberOrNull(x) != null) retval += 1;\n    });\n    return retval;\n  }\n\n  // this aggregate only takes single values as inputs\n  // (the parameters will likely be other aggregates)\n  function subtractAggr(a, b) {\n    a = strictToNumberOrNull(a);\n    b = strictToNumberOrNull(b);\n\n    return a - b;\n  }\n\n  // this is not exposed as an aggregate (hence not called *Aggr)\n  function sumProduct(valueArray1, valueArray2) {\n    let total = 0;\n\n    for (let i = 0; i < valueArray1.length; i += 1) {\n      const value1 = strictToNumberOrNull(valueOrArrayItem(valueArray1, i));\n      const value2 = strictToNumberOrNull(valueOrArrayItem(valueArray2, i));\n      total += value1 * value2;\n    }\n\n    return total;\n  }\n\n  function weightedMeanAggr(valArray, weightArray) {\n    return (sumProduct(valArray, weightArray) / sumAggr(weightArray));\n  }\n\n  function letianceAggr(weightArray) {\n    return 1 / sumAggr(weightArray);\n  }\n\n  function standardErrorAggr(weightArray) {\n    return Math.sqrt(letianceAggr(weightArray));\n  }\n\n  function lowerConfidenceLimitAggr(valArray, weightArray) {\n    return weightedMeanAggr(valArray, weightArray) - 1.96 * standardErrorAggr(weightArray);\n  }\n\n  function upperConfidenceLimitAggr(valArray, weightArray) {\n    return weightedMeanAggr(valArray, weightArray) + 1.96 * standardErrorAggr(weightArray);\n  }\n\n  function zValueAggr(valArray, weightArray) {\n    return weightedMeanAggr(valArray, weightArray) / standardErrorAggr(weightArray);\n  }\n\n  // this aggregate only takes a single value as an input\n  // (the parameter will likely be another aggregate)\n  function pValue1TailedAggr(data) {\n    data = strictToNumberOrNull(data);\n    if (data == null || Number.isNaN(data)) return null;\n\n    return cdfNormal(-(Math.abs(data)), 0, 1);\n  }\n\n  function pValue2TailedAggr(data) {\n    return 2 * pValue1TailedAggr(data);\n  }\n\n  // cdf (cumulative normal distribution function) adapted from http://stackoverflow.com/questions/5259421/cumulative-distribution-function-in-javascript\n  // this is not exposed as an aggregate (hence not called *Aggr)\n  function cdfNormal(x, mean, standardDeviation) {\n    return (1 - Math.erf((mean - x) / (Math.sqrt(2) * standardDeviation))) / 2;\n  }\n\n  function degreesOfFreedomAggr(data) {\n    return countAggr(data) - 1;\n    // todo this needs to be revisited for moderator analysis\n    // (because 1 becomes number of groups or something)\n  }\n\n  // this function computes all the statistics related to Tau-squared and returns them in a package\n  // this is for code maintainability:\n  // the block of computations from `c` to `se` all very much depend on one another\n  // parameters: array of effect sizes, array of weights\n  function tauPackage(ess, wts) {\n    if (!Array.isArray(ess) || !Array.isArray(wts)) return null;\n\n    // sum of weights, sum of weights squared\n    let sumwt = 0;\n    let sumwt2 = 0;\n    let sumwt3 = 0;\n\n    // computing both sums in a single loop rather than using sumAggr and such\n    wts.forEach((wt) => {\n      wt = strictToNumberOrNull(wt);\n      sumwt += wt;\n      sumwt2 += wt * wt;\n      sumwt3 += wt * wt * wt;\n    });\n\n    // grand weighted mean effect size\n    const gwmes = weightedMeanAggr(ess, wts);\n\n    // sum of fixed effect errors\n    let sumfee = 0;\n\n    wts.forEach((wt, index) => {\n      const es = ess[index];\n      const fee = fixedEffectError(es, wt, gwmes);\n      sumfee += fee;\n    });\n\n    // these are the interdependent computations that justify computing everything in a package\n    const c = sumwt - (sumwt2 / sumwt);\n    const df = degreesOfFreedomAggr(wts);\n    const tauSquared = (sumfee - df) / c;\n    const a = df + 2 * (sumwt - sumwt2 / sumwt) * tauSquared\n    + (sumwt2 - 2 * (sumwt3 / sumwt) + (sumwt2 * sumwt2)\n    / (sumwt * sumwt)) * (tauSquared * tauSquared);\n    const tau = Math.sqrt(tauSquared);\n    const v = 2 * (a / (c * c));\n    const se = Math.sqrt(letiance);\n\n    return {\n      tauSquared,\n      tau,\n      letiance: v,\n      se,\n    };\n  }\n\n  function tauSquaredAggr(ess, wts) {\n    const pkg = tauPackage(ess, wts);\n    if (pkg) return pkg.tauSquared;\n    else return NaN;\n  }\n\n  function tauAggr(ess, wts) {\n    const pkg = tauPackage(ess, wts);\n    if (pkg) return pkg.tau;\n    else return NaN;\n  }\n\n  function tauStandardErrorAggr(ess, wts) {\n    const pkg = tauPackage(ess, wts);\n    if (pkg) return pkg.se;\n    else return NaN;\n  }\n\n  function tauVarianceAggr(ess, wts) {\n    const pkg = tauPackage(ess, wts);\n    if (pkg) return pkg.letiance;\n    else return NaN;\n  }\n\n  // this aggregate only takes single values as inputs\n  // (the parameters will likely be other aggregates)\n  function heterogeneityPValueAggr(sumfee, df) {\n    sumfee = strictToNumberOrNull(sumfee);\n    df = strictToNumberOrNull(df);\n    if (df < 1) return NaN;\n\n    return chisqDistRt(sumfee, df);\n  }\n\n  // this aggregate only takes single values as inputs\n  // (the parameters will likely be other aggregates)\n  function iSquaredAggr(sumfee, df) {\n    sumfee = strictToNumberOrNull(sumfee);\n    df = strictToNumberOrNull(df);\n\n    return (sumfee - df) / sumfee;\n  }\n\n  const retval = {\n    simpleFormulas: [\n      {\n        id: 'logOddsRatio',\n        label: 'Log Odds Ratio (fractions)',\n        func: logOddsRatio,\n        parameters: ['group 1 (e.g. experimental)', 'group 2 (e.g. control)'],\n      },\n      {\n        id: 'logOddsRatioPercent',\n        label: 'Log Odds Ratio (percentages)',\n        func: logOddsRatioPercent,\n        parameters: ['group 1 (e.g. experimental %)', 'group 2 (e.g. control %)'],\n      },\n      {\n        id: 'logOddsRatioNumber',\n        label: 'Log Odds Ratio (numbers affected)',\n        func: logOddsRatioNumber,\n        parameters: ['group 1 (e.g. experimental affected)', 'group 1 N', 'group 2 (e.g. control affected)', 'group 2 N'],\n      },\n      {\n        id: 'weight',\n        label: 'Weight (fractions)',\n        func: weight,\n        parameters: ['group 1 outcome', 'group 1 N', 'group 2 outcome', 'group 2 N'],\n      },\n      {\n        id: 'weightPercent',\n        label: 'Weight (percentages)',\n        func: weightPercent,\n        parameters: ['group 1 outcome (%)', 'group 1 N', 'group 2 outcome (%)', 'group 2 N'],\n      },\n      {\n        id: 'weightNumber',\n        label: 'Weight (numbers affected)',\n        func: weightNumber,\n        parameters: ['group 1 outcome (affected)', 'group 1 N', 'group 2 outcome (affected)', 'group 2 N'],\n      },\n      {\n        id: 'lowerConfidenceLimit',\n        label: 'Lower Log Confidence Limit (fractions)',\n        func: lowerConfidenceLimit,\n        parameters: ['group 1 outcome', 'group 1 N', 'group 2 outcome', 'group 2 N'],\n      },\n      {\n        id: 'lowerConfidenceLimitPercent',\n        label: 'Lower Log Confidence Limit (percentages)',\n        func: lowerConfidenceLimitPercent,\n        parameters: ['group 1 outcome (%)', 'group 1 N', 'group 2 outcome (%)', 'group 2 N'],\n      },\n      {\n        id: 'lowerConfidenceLimitNumber',\n        label: 'Lower Log Confidence Limit (numbers affected)',\n        func: lowerConfidenceLimitNumber,\n        parameters: ['group 1 outcome (affected)', 'group 1 N', 'group 2 outcome (affected)', 'group 2 N'],\n      },\n      {\n        id: 'upperConfidenceLimit',\n        label: 'Upper Log Confidence Limit (fractions)',\n        func: upperConfidenceLimit,\n        parameters: ['group 1 outcome', 'group 1 N', 'group 2 outcome', 'group 2 N'],\n      },\n      {\n        id: 'upperConfidenceLimitPercent',\n        label: 'Upper Log Confidence Limit (percentages)',\n        func: upperConfidenceLimitPercent,\n        parameters: ['group 1 outcome (%)', 'group 1 N', 'group 2 outcome (%)', 'group 2 N'],\n      },\n      {\n        id: 'upperConfidenceLimitNumber',\n        label: 'Upper Log Confidence Limit (numbers affected)',\n        func: upperConfidenceLimitNumber,\n        parameters: ['group 1 outcome (affected)', 'group 1 N', 'group 2 outcome (affected)', 'group 2 N'],\n      },\n      {\n        id: 'fixedEffectError',\n        label: 'Fixed Effect Error',\n        func: fixedEffectError,\n        parameters: ['effect size', 'weight', 'grand weighted mean effect size'],\n      },\n      {\n        id: 'randomEffectWeight',\n        label: 'Random Effect Model Weight (fractions)',\n        func: randomEffectWeight,\n        parameters: ['group 1 outcome', 'group 1 N', 'group 2 outcome', 'group 2 N', 'tauSquared'],\n      },\n      {\n        id: 'randomEffectWeightPercent',\n        label: 'Random Effect Model Weight (percentages)',\n        func: randomEffectWeightPercent,\n        parameters: ['group 1 outcome (%)', 'group 1 N', 'group 2 outcome (%)', 'group 2 N', 'tauSquared'],\n      },\n      {\n        id: 'randomEffectWeightNumber',\n        label: 'Random Effect Model Weight (numbers affected)',\n        func: randomEffectWeightNumber,\n        parameters: ['group 1 outcome (affected)', 'group 1 N', 'group 2 outcome (affected)', 'group 2 N', 'tauSquared'],\n      },\n    ],\n    moderatorFormulas: [\n      {\n        id: 'weightedMeanAggr',\n        label: 'Weighted Mean',\n        func: weightedMeanAggr,\n        parameters: ['values', 'weights'],\n      },\n      {\n        id: 'lowerConfidenceLimitAggr',\n        label: 'Lower Confidence Limit',\n        func: lowerConfidenceLimitAggr,\n        parameters: ['values', 'weights'],\n      },\n      {\n        id: 'upperConfidenceLimitAggr',\n        label: 'Upper Confidence Limit',\n        func: upperConfidenceLimitAggr,\n        parameters: ['values', 'weights'],\n      },\n      {\n        id: 'letianceAggr',\n        label: 'Variance',\n        func: letianceAggr,\n        parameters: ['weights'],\n      },\n      {\n        id: 'standardErrorAggr',\n        label: 'Standard Error',\n        func: standardErrorAggr,\n        parameters: ['weights'],\n      },\n      {\n        id: 'zValueAggr',\n        label: 'Z-value',\n        func: zValueAggr,\n        parameters: ['values', 'weights'],\n      },\n      {\n        id: 'sumAggr',\n        label: 'Sum',\n        func: sumAggr,\n        parameters: ['values'],\n      },\n      {\n        id: 'countAggr',\n        label: 'Count',\n        func: countAggr,\n        parameters: ['data'],\n      },\n      {\n        id: 'subtractAggr',\n        label: 'Subtract',\n        func: subtractAggr,\n        parameters: ['a', 'b'],\n      },\n      {\n        id: 'pValue1TailedAggr',\n        label: 'P-value (one-tailed)',\n        func: pValue1TailedAggr,\n        parameters: ['data'],\n      },\n      {\n        id: 'pValue2TailedAggr',\n        label: 'P-value (two-tailed)',\n        func: pValue2TailedAggr,\n        parameters: ['data'],\n      },\n      {\n        id: 'degreesOfFreedomAggr',\n        label: 'Degrees of Freedom',\n        func: degreesOfFreedomAggr,\n        parameters: ['data'],\n      },\n      {\n        id: 'tauSquaredAggr',\n        label: 'Tau Squared',\n        func: tauSquaredAggr,\n        parameters: ['values', 'weights'],\n      },\n      {\n        id: 'tauAggr',\n        label: 'Tau',\n        func: tauAggr,\n        parameters: ['values', 'weights'],\n      },\n      {\n        id: 'tauStandardErrorAggr',\n        label: 'Tau Standard Error',\n        func: tauStandardErrorAggr,\n        parameters: ['values', 'weights'],\n      },\n      {\n        id: 'tauVarianceAggr',\n        label: 'Tau Variance',\n        func: tauVarianceAggr,\n        parameters: ['values', 'weights'],\n      },\n      {\n        id: 'heterogeneityPValueAggr',\n        label: 'Heterogeneity P-value',\n        func: heterogeneityPValueAggr,\n        parameters: ['sum of fixed effect errors', 'degrees of freedom'],\n      },\n      {\n        id: 'iSquaredAggr',\n        label: 'I-squared',\n        func: iSquaredAggr,\n        parameters: ['sum of fixed effect errors', 'degrees of freedom'],\n      },\n    ],\n  };\n\n  return retval;\n}\n\nexport default formulas;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/aggregates/GroupingAggregates.js","messages":[{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 43 to the 15 allowed.","line":28,"column":10,"nodeType":null,"endLine":28,"endColumn":28},{"ruleId":"sonarjs/no-duplicate-string","severity":2,"message":"Define a constant instead of duplicating this literal 4 times.","line":62,"column":42,"nodeType":"Literal","endLine":62,"endColumn":76}],"errorCount":2,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useContext } from 'react';\nimport { getAggregateDatumValue, formatNumber } from '../../../tools/datatools';\nimport { RemovalPopup } from '../Popup';\nimport EditContext from '../EditContext';\n\nconst aggregateDetails = (aggr) => (\n  <>\n    <p>{ aggr.title }</p>\n    <p>{ aggr.fullLabel }</p>\n  </>\n);\n\nconst aggregateValDetails = (aggr, value, group) => (\n  <>\n    <p>{ value }</p>\n    <p>\n      Calculated for the\n      { ' ' }\n      { group }\n      { ' ' }\n      group as\n      { ' ' }\n      { aggr.fullLabel }\n    </p>\n  </>\n);\n\nfunction GroupingAggregates(props) {\n  const {\n    groupingAggregatesState, makeClickable, mwgState,\n  } = props;\n  const [groupingAggregates, setGroupingAggregates] = groupingAggregatesState;\n  const [moderatorsWithGroups] = mwgState;\n  const [popupStatus, setPopupStatus] = useState(false);\n  const [selectedAnalysis, setSelectedAnalysis] = useState(null);\n  const edit = useContext(EditContext);\n\n  function popupToggle() {\n    setPopupStatus(!popupStatus);\n  }\n\n  function selectAnalysis(e) {\n    const analysisFormula = e.currentTarget.getAttribute('analysisformula');\n    const analysisToSelect = groupingAggregates.filter(\n      (aggr) => aggr.formula === analysisFormula,\n    )[0];\n    setSelectedAnalysis(analysisToSelect);\n  }\n\n  function removeModAnalysis() {\n    const analysisClone = [...groupingAggregates];\n    analysisClone.splice(analysisClone.indexOf(selectedAnalysis), 1);\n    setGroupingAggregates(analysisClone);\n  }\n\n  return (\n    <>\n      <div id=\"modAnalysisTableContainer\">\n        <table id=\"modAnalysisTable\">\n          <thead>\n            <tr>\n              <th className={edit.flag ? 'modAnalysisHead editMode primary' : 'modAnalysisHead'}>Moderator:</th>\n              { moderatorsWithGroups.map((moderator) => {\n                if (moderator.included) {\n                  let count = 0;\n                  for (const group of moderator.groups) {\n                    if (group.included) {\n                      count += 1;\n                    }\n                  }\n                  if (count !== 0) {\n                    return (\n                      <th\n                        key={moderator.moderatorObj.title}\n                        colSpan={count}\n                        className={edit.flag ? 'modAnalysisHead editMode primary' : 'modAnalysisHead'}\n                      >\n                        { moderator.moderatorObj.title }\n                      </th>\n                    );\n                  }\n                }\n                return null;\n              }) }\n            </tr>\n          </thead>\n          <thead>\n            <tr>\n              <th className={edit.flag ? 'modAnalysisHead editMode primary' : 'modAnalysisHead'}>Group:</th>\n              { moderatorsWithGroups.map((moderator) => (moderator.included\n                ? moderator.groups.map((group) => (group.included\n                  ? (\n                    <th key={group.group} className={edit.flag ? 'modAnalysisHead editMode primary' : 'modAnalysisHead'}>\n                      { group.group }\n                    </th>\n                  )\n                  : null\n                ))\n                : null)) }\n            </tr>\n          </thead>\n          <tbody>\n            { groupingAggregates.map((aggr) => (\n              <tr key={aggr.fullLabel}>\n                <td {...makeClickable(aggr.fullLabel, aggregateDetails(aggr))}>\n                  <div>\n                    { aggr.title || aggr.fullLabel }\n                  </div>\n                  { edit.flag\n                    ? (\n                      <div>\n                        <div className=\"removeModAnalysisButton\" analysisformula={aggr.formula} role=\"button\" tabIndex={0} onClick={(e) => { popupToggle(); selectAnalysis(e); }} onKeyDown={popupToggle}>Remove</div>\n                        { popupStatus\n                          ? (\n                            <RemovalPopup\n                              closingFunc={popupToggle}\n                              removalFunc={removeModAnalysis}\n                              removalText={`paper: ${selectedAnalysis.title}`}\n                            />\n                          )\n                          : null }\n                      </div>\n                    )\n                    : null }\n                </td>\n                { moderatorsWithGroups.map((moderator) => (moderator.included\n                  ? moderator.groups.map((group) => {\n                    if (group.included) {\n                      const value = getAggregateDatumValue(\n                        aggr, aggr.metaanalysis.papers, group.group, moderator.moderatorObj,\n                      );\n                      const padding = Math.trunc(value).toString().length;\n                      return (\n                        <td\n                          key={aggr.title + group.group}\n                          style={{ paddingRight: `${padding}ch` }}\n                          {...makeClickable(\n                            aggr.title + group.group,\n                            aggregateValDetails(aggr, value, group.group),\n                            true,\n                          )}\n                        >\n                          { formatNumber(value) }\n                        </td>\n                      );\n                    }\n                    return null;\n                  })\n                  : null\n                )) }\n              </tr>\n            )) }\n          </tbody>\n        </table>\n      </div>\n    </>\n  );\n}\n\nexport default GroupingAggregates;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/aggregates/SimpleAggregates.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/datatable/Cell.js","messages":[{"ruleId":"space-in-parens","severity":2,"message":"There should be no space after this paren.","line":66,"column":18,"nodeType":"Program","messageId":"rejectedOpeningSpace","endLine":66,"endColumn":19,"fix":{"range":[1489,1490],"text":""}},{"ruleId":"eol-last","severity":2,"message":"Newline required at end of file but not found.","line":105,"column":2,"nodeType":"Program","messageId":"missing","fix":{"range":[2561,2561],"text":"\n"}}],"errorCount":2,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"import React from 'react';\nimport { getDatumValue, formatNumber, formatDateTimeSplit } from '../../../tools/datatools';\nimport Editable from '../Editable';\n\nfunction addCellDetails(enteredBy, ctime, paper, cval, ...args) {\n  const fullLabel = args;\n  return (\n    <>\n      <table>\n        <tbody>\n          <tr>\n            <td>\n              Cell value:\n              { ' ' }\n            </td>\n            <td>\n              { (parseInt(cval, 10) && cval.length > 10) ? parseInt(cval, 10).toFixed(10) : cval }\n            </td>\n          </tr>\n          <tr>\n            <td>\n              Paper:\n              { ' ' }\n            </td>\n            <td>\n              { paper.title }\n            </td>\n          </tr>\n          <tr>\n            <td>\n              Entered by:\n              { ' ' }\n            </td>\n            <td>\n              { enteredBy }\n              { ' ' }\n              at\n              { ' ' }\n              { formatDateTimeSplit(ctime).time }\n              { ' ' }\n              on\n              { ' ' }\n              { formatDateTimeSplit(ctime).date }\n            </td>\n          </tr>\n          fullLabel\n          ? (\n          <tr>\n            <td>\n              Calculated as:\n              { ' ' }\n            </td>\n            <td>\n              { fullLabel }\n            </td>\n          </tr>\n          )\n          : ``\n        </tbody>\n      </table>\n    </>\n  );\n}\n\nconst dataCellDetails = ({ enteredBy, ctime, paper }, cval) => (\n  addCellDetails( enteredBy, ctime, paper, cval)\n);\nconst computedCellDetails = ({ fullLabel }, { enteredBy, ctime, paper }, cval) => (\n  addCellDetails(enteredBy, ctime, paper, cval, fullLabel)\n);\n\nexport default function Cell(props) {\n  const {\n    col, exp, cellId, makeClickable, editCell,\n  } = props;\n  const value = (getDatumValue(col, exp) || null);\n  const padding = Math.trunc(value).toString().length;\n  /* Reminder: some parts of the Cell object are initialized in 'makeClickable' function,\n  found in Metaanalysis.js */\n\n  if (col.visibility === false) {\n    return (\n      <td />\n    );\n  }\n\n  return (\n    col.id\n    // data cell\n      ? (\n        <td {...makeClickable(cellId, dataCellDetails(exp, value))}>\n          <Editable cellId={cellId} type=\"input\" onSave={editCell}>{ value }</Editable>\n        </td>\n      )\n      // computed cell\n      : (\n        <td\n          style={{ paddingRight: `${padding}ch` }}\n          {...makeClickable(cellId, computedCellDetails(col, exp, value), 'computed')}\n        >\n          { formatNumber(value) }\n        </td>\n      )\n  );\n}","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/datatable/DataTable.js","messages":[{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 49 to the 15 allowed.","line":38,"column":10,"nodeType":null,"endLine":38,"endColumn":19},{"ruleId":"sonarjs/no-duplicate-string","severity":2,"message":"Define a constant instead of duplicating this literal 3 times.","line":125,"column":91,"nodeType":"Literal","endLine":125,"endColumn":109},{"ruleId":"sonarjs/no-identical-functions","severity":2,"message":"Update this function so that its implementation is not identical to the one on line 158.","line":163,"column":37,"nodeType":null,"endLine":163,"endColumn":39}],"errorCount":3,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useContext, useRef } from 'react';\nimport Paper from './Paper';\nimport AddPaper from '../AddPaper';\nimport AddColumn from '../AddColumn';\nimport Editable from '../Editable';\nimport EditContext from '../EditContext';\nimport RearrangeColumn from '../ColumnRearranger';\nimport { RemovalPopup } from '../Popup';\n\nimport './DataTable.css';\n\nconst paperColumnDetails = (\n  <>\n    <p>Paper column</p>\n  </>\n);\nconst expColumnDetails = (\n  <>\n    <p>Study/Experiment column</p>\n  </>\n);\n\nconst dataColDetails = (col) => (\n  <>\n    <p><Editable type=\"input\" cellId={col.id}>{ col.title }</Editable></p>\n    <p><Editable type=\"input\" cellId={col.id}>{ col.description || 'no detailed description' }</Editable></p>\n  </>\n\n);\n\nconst computedColDetails = (col) => (\n  <>\n    <p>{ col.title }</p>\n    <p>{ col.fullLabel }</p>\n  </>\n);\n\nfunction DataTable(props) {\n  const {\n    columnState, papers, paperOrderValue, makeClickable, editCell, metaanalysis, aggregates,\n  } = props;\n  const [columns, setColumns] = columnState;\n  const [paperState, setPaperState] = papers;\n  const [paperOrder, setPaperOrder] = paperOrderValue;\n  const [popupStatus, setPopupStatus] = useState(false);\n  const [selectedColumn, setSelectedColumn] = useState(null);\n\n  function popupToggle() {\n    setPopupStatus(!popupStatus);\n  }\n\n  function selectColumn(e) {\n    const colTitle = e.currentTarget.getAttribute('coltitle');\n    const colId = e.currentTarget.getAttribute('colid');\n\n    const columnToRemove = columns.filter(\n      (col) => col.title === colTitle && (col.id === colId || col.number === colId),\n    )[0];\n\n    setSelectedColumn(columnToRemove);\n  }\n\n  function removeColumn() {\n    const columnsClone = [...columns];\n    columnsClone.splice(columnsClone.indexOf(selectedColumn), 1);\n    if (selectedColumn.subType === 'calculator') {\n      const nCol = columns.filter((col) => col.id === selectedColumn.linkedN)[0];\n      columnsClone.splice(columnsClone.indexOf(nCol), 1);\n    }\n    setColumns(columnsClone);\n  }\n\n  function hideColumn(col) {\n    col.visibility = false;\n  }\n\n  function showColumn(col) {\n    col.visibility = true;\n  }\n\n  const getColNums = (cols) => {\n    let numSpecs = 0;\n    let numMods = 0;\n    let numCalcs = 0;\n    let numData = 0;\n    cols.forEach((column) => {\n      if (column.subType === 'moderator') {\n        numMods += 1;\n      } else if (column.subType === 'calculator' || column.subType === 'calculatorN') {\n        numCalcs += 1;\n      } else if (column.subType === 'result') {\n        numData += 1;\n      } else if (column.subType === 'pspecific') {\n        numSpecs += 1;\n      }\n    });\n    return [numSpecs, numMods, numCalcs, numData];\n  };\n  const [pspecificNumber, moderatorNumber, calculatorNumber, dataNumber] = getColNums(columns);\n\n  const [moveCols, setMoveCols] = useState({ col: null, colGroup: [] });\n\n  const edit = useContext(EditContext);\n  const parentOfRows = useRef(null);\n\n  return (\n    <section>\n      <table className=\"datatable\">\n        <colgroup>\n          <col className=\"paperColumn\" span={2 + pspecificNumber} />\n          { (moderatorNumber > 0) ? <col className=\"moderatorColumn\" span={moderatorNumber} /> : null }\n          { (calculatorNumber > 0) ? <col className=\"calculatorColumn\" span={calculatorNumber} /> : null }\n          { (dataNumber > 0) ? <col className=\"dataColumn\" span={dataNumber} /> : null }\n        </colgroup>\n        <thead>\n          <tr className=\"columnHeadings\">\n            <th className=\"paperColumnHeader\" colSpan={2 + pspecificNumber}>Studies, experiments, conditions</th>\n            { (moderatorNumber > 0) ? <th className=\"moderatorColumnHeader\" colSpan={moderatorNumber}>Moderator variables</th> : null }\n            { (calculatorNumber > 0) ? <th className=\"calculatorColumnHeader\" colSpan={calculatorNumber}>Outcomes and Ns</th> : null }\n            { (dataNumber > 0) ? <th className=\"dataColumnHeader\" colSpan={dataNumber}>Effect sizes and weights</th> : null }\n          </tr>\n        </thead>\n        <thead>\n          <tr>\n            <th {...makeClickable('Paper', paperColumnDetails)} className={`${edit.flag ? 'editMode primary' : ''}`}>\n              <>\n                <AddPaper\n                  paperState={[paperState, setPaperState]}\n                  paperOrderValue={[paperOrder, setPaperOrder]}\n                  metaanalysis={metaanalysis}\n                />\n              </>\n            </th>\n            <th {...makeClickable('Study/Experiment', expColumnDetails)} className={`${edit.flag ? 'editMode primary' : ''}`}>\n              Study/Experiment\n            </th>\n            { columns.map((col) => (\n              <th\n                key={col.id || col.fullLabel}\n                {...makeClickable(\n                  col.id || col.fullLabel,\n                  col.id ? dataColDetails(col) : computedColDetails(col),\n                )}\n                className={`column ${edit.flag ? 'editMode primary' : ''}`}\n                columntype={col.subType}\n                columnid={col.id || col.number}\n              >\n                { col.visibility === true\n                  ? (\n                    <>\n                      { edit.flag\n                        ? (\n                          <>\n                            <button\n                              type=\"submit\"\n                              className=\"grabberButton\"\n                              onDragStart={\n                                (e) => RearrangeColumn(\n                                  e, columns, setColumns, moveCols, setMoveCols,\n                                )\n                              }\n                              onDragEnd={\n                                (e) => RearrangeColumn(\n                                  e, columns, setColumns, moveCols, setMoveCols,\n                                )\n                              }\n                            >\n                              <img src=\"/img/grab-icon.png\" alt=\"Grabber\" className=\"grabberIcon\" />\n                            </button>\n                            { col.title || col.fullLabel }\n                            <div className=\"columnButtonContainer\">\n                              <button type=\"submit\" className=\"hideShowButton\" onClick={() => hideColumn(col)}>Hide</button>\n                              { col.subType !== 'calculatorN'\n                                ? (\n                                  <div role=\"button\" tabIndex={0} className=\"removeColumnButton\" coltitle={col.title} colid={col.id || col.number} onClick={(e) => { popupToggle(); selectColumn(e); }} onKeyDown={popupToggle}>Remove</div>\n                                )\n                                : null }\n                              { popupStatus\n                                ? (\n                                  <RemovalPopup\n                                    closingFunc={popupToggle}\n                                    removalFunc={removeColumn}\n                                    removalText={`column: ${selectedColumn.title}`}\n                                  />\n                                )\n                                : null }\n                            </div>\n                          </>\n                        )\n                        : <>{ col.title || col.fullLabel }</> }\n                    </>\n                  )\n                  : (\n                    <div className=\"columnButtonContainer\">\n                      { edit.flag\n                        ? (\n                          <button type=\"submit\" className=\"hideShowButton\" onClick={() => showColumn(col)}>Show</button>\n                        )\n                        : null }\n                    </div>\n                  ) }\n              </th>\n            )) }\n            { edit.flag\n              ? (\n                <th className=\"column cornerstone editMode primary\">\n                  <AddColumn\n                    columnState={columnState}\n                    aggregates={aggregates}\n                  />\n                </th>\n              )\n              : null }\n          </tr>\n        </thead>\n        <tbody ref={parentOfRows}>\n          { paperOrder.map((id) => (\n            Object.values(paperState).map((paper) => (\n              paper.id === id\n                ? (\n                  <Paper\n                    key={paper.id + paper.title}\n                    paper={paper}\n                    columns={columns}\n                    makeClickable={makeClickable}\n                    editCell={editCell}\n                    parentOfRows={parentOfRows}\n                    papers={[paperState, setPaperState]}\n                    paperOrderValue={[paperOrder, setPaperOrder]}\n                  />\n                )\n                : null\n            ))\n          )) }\n        </tbody>\n      </table>\n    </section>\n  );\n}\n\nexport default DataTable;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/datatable/Paper.js","messages":[{"ruleId":"sonarjs/no-identical-functions","severity":2,"message":"Update this function so that its implementation is not identical to the one on line 231.","line":236,"column":25,"nodeType":null,"endLine":236,"endColumn":27}],"errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useContext, useState } from 'react';\nimport Cell from './Cell';\nimport { formatDateTimeSplit } from '../../../tools/datatools';\nimport EditContext from '../EditContext';\nimport RearrangeRow from '../RowRearranger';\nimport AddExperiment from '../AddExperiment';\nimport { RemovalPopup } from '../Popup';\n\nconst paperDetails = (paper) => {\n  const {\n    title, enteredBy, ctime, reference, description, link, doi, mtime,\n  } = paper;\n  return (\n    <>\n      <table>\n        <tbody>\n          <tr>\n            <td>\n              Paper:\n              { ' ' }\n            </td>\n            <td>\n              { title }\n            </td>\n          </tr>\n          <tr>\n            <td>\n              Reference:\n              { ' ' }\n            </td>\n            <td>\n              { reference || 'no reference available' }\n            </td>\n          </tr>\n          <tr>\n            <td>\n              Description:\n              { ' ' }\n            </td>\n            <td>\n              { description || 'No description available' }\n            </td>\n          </tr>\n          <tr>\n            <td>\n              Link:\n              { ' ' }\n            </td>\n            <td>\n              { link || 'No link available' }\n            </td>\n          </tr>\n          <tr>\n            <td>\n              DOI:\n              { ' ' }\n            </td>\n            <td>\n              { doi || 'No digital object identifier available' }\n            </td>\n          </tr>\n          <tr>\n            <td>\n              Entered by:\n              { ' ' }\n            </td>\n            <td>\n              { enteredBy }\n              { ' ' }\n              at\n              { ' ' }\n              { formatDateTimeSplit(ctime).time }\n              { ' ' }\n              on\n              { ' ' }\n              { formatDateTimeSplit(ctime).date }\n            </td>\n          </tr>\n          <tr>\n            <td>\n              Last modified:\n              { ' ' }\n            </td>\n            <td>\n              { formatDateTimeSplit(mtime).time }\n              { ' ' }\n              on\n              { ' ' }\n              { formatDateTimeSplit(mtime).date }\n            </td>\n          </tr>\n        </tbody>\n      </table>\n    </>\n  );\n};\n\nconst expDetails = (exp) => {\n  const { paper, title, description } = exp;\n  return (\n    <>\n      <table>\n        <tbody>\n          <tr>\n            <td>\n              Study or Experiment:\n              { ' ' }\n            </td>\n            <td>\n              { title }\n            </td>\n          </tr>\n          <tr>\n            <td>\n              Paper:\n              { ' ' }\n            </td>\n            <td>\n              { paper.title }\n            </td>\n          </tr>\n          <tr>\n            <td>\n              Description:\n              { ' ' }\n            </td>\n            <td>\n              { description || 'No description available' }\n            </td>\n          </tr>\n          <tr>\n            <td>\n              Entered by:\n              { ' ' }\n            </td>\n            <td>\n              { paper.enteredBy }\n              { ' ' }\n              at\n              { ' ' }\n              { formatDateTimeSplit(paper.ctime).time }\n              { ' ' }\n              on\n              { ' ' }\n              { formatDateTimeSplit(paper.ctime).date }\n            </td>\n          </tr>\n          <tr>\n            <td>\n              Last modified:\n              { ' ' }\n            </td>\n            <td>\n              { formatDateTimeSplit(paper.mtime).time }\n              { ' ' }\n              on\n              { ' ' }\n              { formatDateTimeSplit(paper.mtime).date }\n            </td>\n          </tr>\n        </tbody>\n      </table>\n    </>\n  );\n};\n\nfunction Paper(props) {\n  const {\n    paper, columns, makeClickable, editCell, parentOfRows, papers, paperOrderValue,\n  } = props;\n  const { title } = paper;\n  const [paperState, setPaperState] = papers;\n  const [paperOrder, setPaperOrder] = paperOrderValue;\n\n  const edit = useContext(EditContext);\n  const [rowEvent, setRowEvent] = useState({ rows: [], topRowIndex: null });\n  const [popupStatus, setPopupStatus] = useState(false);\n  const [experimentPopupStatus, setExperimentPopupStatus] = useState(false);\n  const [selectedExperiment, setSelectedExperiment] = useState(null);\n\n  const nExp = Object.keys(paper.experiments).length;\n\n  function popupToggle() {\n    setPopupStatus(!popupStatus);\n  }\n\n  function experimentPopupToggle() {\n    setExperimentPopupStatus(!experimentPopupStatus);\n  }\n\n  function removePaper() {\n    const paperOrderClone = [...paperOrder];\n    const papersClone = [...paperState];\n\n    paperOrderClone.splice(paperOrderClone.indexOf(paper.id), 1);\n    papersClone.splice(papersClone.indexOf(paper), 1);\n\n    setPaperState(papersClone);\n    setPaperOrder(paperOrderClone);\n  }\n\n  function removeExperiment() {\n    const papersClone = [...paperState];\n    if (paper.experiments.length === 1) {\n      removePaper();\n    } else {\n      papersClone[(papersClone.indexOf(paper))].experiments.splice(\n        paper.experiments.indexOf(paper.experiments[selectedExperiment]), 1,\n      );\n    }\n  }\n\n  function selectExperiment(e) {\n    const exper = e.currentTarget.getAttribute('experiment');\n    setSelectedExperiment(exper);\n  }\n\n  return (\n    paper.experiments.map((exp, key) => {\n      let newPaper;\n      let firstTr;\n      if (key === 0) {\n        newPaper = (\n          <td key={title} {...makeClickable(title, paperDetails(paper), 'paper')} rowSpan={nExp}>\n            { edit.flag\n              ? (\n                <button\n                  type=\"submit\"\n                  className=\"grabberButton\"\n                  onDragStart={\n                    (e) => RearrangeRow(\n                      rowEvent, setRowEvent, parentOfRows, e, papers, paperOrderValue,\n                    )\n                  }\n                  onDragEnd={\n                    (e) => RearrangeRow(\n                      rowEvent, setRowEvent, parentOfRows, e, papers, paperOrderValue,\n                    )\n                  }\n                >\n                  <img src=\"/img/grab-icon.png\" alt=\"Grabber\" className=\"grabberIcon\" />\n                </button>\n              )\n              : null }\n            { title }\n            { edit.flag\n              ? (\n                <div className=\"removePaperContainer\">\n                  <div className=\"removePaperButton\" role=\"button\" tabIndex={0} onClick={popupToggle} onKeyDown={popupToggle}>Remove</div>\n                  { popupStatus\n                    ? (\n                      <RemovalPopup\n                        closingFunc={popupToggle}\n                        removalFunc={removePaper}\n                        removalText={`paper: ${paper.title}`}\n                      />\n                    )\n                    : null }\n                </div>\n              )\n              : null }\n            <AddExperiment paper={paper} columns={columns} paperState={papers} />\n          </td>\n        );\n        firstTr = 'paperstart';\n      }\n      return (\n        <tr\n          key={exp.ctime + paper.id}\n          className={firstTr}\n        >\n          { newPaper }\n          <td {...makeClickable(exp.ctime + paper.id, expDetails(exp))} key={exp.title}>\n            { exp.title }\n          </td>\n          { columns.map((col) => (\n            <Cell\n              cellId={`${exp.ctime + paper.id}+${col.formula || col.id}`}\n              key={`${exp.ctime + paper.id}+${col.formula || col.id}`}\n              col={col}\n              exp={exp}\n              makeClickable={makeClickable}\n              editCell={editCell}\n            />\n          )) }\n          { edit.flag\n            ? (\n              <td className=\"experimentRemovalContainer\">\n                <div className=\"removeExperimentButton\" role=\"button\" tabIndex={0} experiment={exp.index} onClick={(e) => { experimentPopupToggle(); selectExperiment(e); }} onKeyDown={experimentPopupToggle}>Remove</div>\n                { experimentPopupStatus\n                  ? (\n                    <RemovalPopup\n                      closingFunc={experimentPopupToggle}\n                      removalFunc={removeExperiment}\n                      removalText={`experiment ${selectedExperiment} from paper: ${paper.title}`}\n                    />\n                  )\n                  : null }\n              </td>\n            )\n            : null }\n        </tr>\n      );\n    })\n  );\n}\n\nexport default Paper;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/plots/AddGraph.js","messages":[{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 32 to the 15 allowed.","line":4,"column":10,"nodeType":null,"endLine":4,"endColumn":23},{"ruleId":"sonarjs/no-duplicate-string","severity":2,"message":"Define a constant instead of duplicating this literal 3 times.","line":75,"column":14,"nodeType":"Literal","endLine":75,"endColumn":54},{"ruleId":"sonarjs/no-duplicate-string","severity":2,"message":"Define a constant instead of duplicating this literal 3 times.","line":77,"column":14,"nodeType":"Literal","endLine":77,"endColumn":49},{"ruleId":"eol-last","severity":2,"message":"Newline required at end of file but not found.","line":300,"column":25,"nodeType":"Program","messageId":"missing","fix":{"range":[8566,8566],"text":"\n"}}],"errorCount":4,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport Popup from '../Popup';\n\nfunction AddGraphPopup(props) {\n  const {\n    graphState, columns, flag, metaanalysis, setSelectedGraph,\n  } = props;\n  const [graphs, setGraphs] = graphState;\n  const [popupStatus, setPopupStatus] = flag;\n  const modCols = columns.filter((col) => col.subType === 'moderator');\n  const calcCols = columns.filter((col) => col.subType === 'calculator' || col.subType === 'calculatorN');\n  const [type, setType] = useState('grape');\n\n  let title;\n  let g1;\n  let g1Col;\n  let g1n;\n  let g1nCol;\n  let g2;\n  let g2Col;\n  let g2n;\n  let g2nCol;\n  let mod;\n  let modCol;\n\n  const closeHandler = () => {\n    setPopupStatus(!popupStatus);\n  };\n\n  function changeType(e) {\n    e.preventDefault();\n    setType(e.currentTarget.value);\n  }\n\n  function getGraphObject(elem) {\n    for (const element of elem) {\n      const input = element.children.children[0];\n      if (input) {\n        switch (input.name) {\n        case 'newGraphTitle':\n          title = input.value;\n          break;\n        case 'newGraphG1':\n          g1 = input.value;\n          g1Col = columns.filter((col) => col.subType === 'calculator' && col.id === input.value)[0];\n          g1nCol = columns.filter((col) => col.subType === 'calculatorN' && col.id === columns.filter((column) => column.subType === 'calculator' && column.id === input.value)[0].linkedN)[0];\n          break;\n        case 'newGraphG2':\n          g2 = input.value;\n          g2Col = columns.filter((col) => col.subType === 'calculator' && col.id === input.value)[0];\n          g2nCol = columns.filter((col) => col.subType === 'calculatorN' && col.id === columns.filter((column) => column.subType === 'calculator' && column.id === input.value)[0].linkedN)[0];\n          break;\n        case 'newGraphMod':\n          mod = input.value;\n          modCol = columns.filter((col) => col.subType === 'moderator' && col.id === input.value)[0];\n          break;\n        default:\n        }\n      }\n    }\n  }\n\n  function formGrapeObject(elem) {\n    const id = Object.keys(graphs).length;\n\n    getGraphObject(elem);\n\n    const graphObject = {\n      formula: `grapeChartPercentGraph(${g1},${g1n},${g2},${g2n},${mod},)`,\n      formulaName: 'grapeChartPercentGraph',\n      formulaObj: {\n        id: 'grapeChartPercentGraph',\n        label: 'Grape Chart (percentages)',\n        parameters: {\n          0: 'group 1 (e.g. experimental percentage)',\n          1: 'group 1 N',\n          2: 'group 2 (e.g. control percentage)',\n          3: 'group 2 N',\n          4: 'moderator',\n        },\n        type: {\n          type: 'graph',\n        },\n      },\n      formulaParams: [g1Col, g1nCol, g2Col, g2nCol, modCol],\n      fullLabel: `Grape Chart (percentages)( ${g1Col.title}, ${g1nCol.title}, ${g2Col.title}, ${g2nCol.title}, ${modCol.title} )`,\n      metaanalysis,\n      title,\n      id,\n    };\n\n    return graphObject;\n  }\n\n  function formForestObject(elem) {\n    const id = Object.keys(graphs).length;\n\n    getGraphObject(elem);\n\n    const graphObject = {\n      formula: `forestPlotPercentGraph(${g1Col.id},${g1nCol.id},${g2Col.id},${g2nCol.id})`,\n      formulaName: 'forestPlotPercentGraph',\n      formulaObj: {\n        id: 'forestPlotPercentGraph',\n        label: 'Forest Plot (percentages)',\n        parameters: {\n          0: 'group 1 (e.g. experimental percentage)',\n          1: 'group 1 N',\n          2: 'group 2 (e.g. control percentage)',\n          3: 'group 2 N',\n        },\n        type: {\n          type: 'graph',\n        },\n      },\n      formulaParams: [g1Col, g1nCol, g2Col, g2nCol],\n      fullLabel: `Forest Plot (percentages)( ${g1Col.title}, ${g1nCol.title}, ${g2Col.title}, ${g2nCol.title} )`,\n      metaanalysis,\n      title,\n      id,\n    };\n\n    return graphObject;\n  }\n\n  function formForestGroupObject(elem) {\n    const id = Object.keys(graphs).length;\n\n    getGraphObject(elem);\n\n    const graphObject = {\n      formula: `forestPlotGroupPercentGraph(${g1Col.id},${g1nCol.id},${g2Col.id},${g2nCol.id},${modCol.id},)`,\n      formulaName: 'forestPlotGroupPercentGraph',\n      formulaObj: {\n        id: 'forestPlotGroupPercentGraph',\n        label: 'Forest Plot With Groups (percentages)',\n        parameters: {\n          0: 'group 1 (e.g. experimental percentage)',\n          1: 'group 1 N',\n          2: 'group 2 (e.g. control percentage)',\n          3: 'group 2 N',\n          4: 'moderator',\n        },\n        type: {\n          type: 'graph',\n        },\n      },\n      formulaParams: [g1Col, g1nCol, g2Col, g2nCol, modCol],\n      fullLabel: `Forest Plot Group (percentages)( ${g1Col.title}, ${g1nCol.title}, ${g2Col.title}, ${g2nCol.title}, ${modCol.title} )`,\n      metaanalysis,\n      title,\n      id,\n    };\n\n    return graphObject;\n  }\n\n  function handleSubmit(e) {\n    e.preventDefault();\n    const formElem = e.currentTarget;\n    let graph;\n\n    switch (type) {\n    case 'grape':\n      graph = formGrapeObject(formElem);\n      break;\n    case 'forest':\n      graph = formForestObject(formElem);\n      break;\n    case 'forestGroup':\n      graph = formForestGroupObject(formElem);\n      break;\n    default:\n    }\n\n    if (graph && !graph.title.replace(/\\s/g, '')) {\n      graph.title = `Graph #${graphs.length + 1}`;\n    }\n\n    const graphsClone = [...graphs];\n    graphsClone.push(graph);\n    setGraphs(graphsClone);\n    setSelectedGraph(graph);\n\n    closeHandler();\n  }\n\n  const content = (\n    <>\n      <h1> Add a new graph </h1>\n      <form className=\"graphForm\" onSubmit={handleSubmit}>\n        <label htmlFor=\"newGraphTitle\">Title:\n          <input type=\"text\" name=\"newGraphTitle\" placeholder=\"Enter a title\" />\n        </label>\n\n        <label htmlFor=\"newGraphType\">Graph type:\n          <select name=\"newGraphType\" onChange={changeType}>\n            <option key=\"grape\" value=\"grape\" selected=\"selected\">Grape chart</option>\n            <option key=\"forest\" value=\"forest\">Forest plot</option>\n            <option key=\"forestGroup\" value=\"forestGroup\">Forest plot with moderator group</option>\n          </select>\n        </label>\n\n        <label htmlFor=\"newGraphG1\">Group 1:\n          <select name=\"newGraphG1\">\n            { calcCols && calcCols.map((col) => (\n              <>\n                { col.subType !== 'calculatorN'\n                  ? (\n                    <option\n                      key={`newGraphG1${col.id}`}\n                      value={col.id}\n                    >\n                      { col.title }\n                    </option>\n                  )\n                  : null }\n              </>\n            )) }\n          </select>\n        </label>\n\n        <label htmlFor=\"newGraphG2\">Group 2:\n          <select name=\"newGraphG2\">\n            { calcCols && calcCols.map((col) => (\n              <>\n                { col.subType !== 'calculatorN'\n                  ? (\n                    <option\n                      key={`newGraphG2${col.id}`}\n                      value={col.id}\n                    >\n                      { col.title }\n                    </option>\n                  )\n                  : null }\n              </>\n            )) }\n          </select>\n        </label>\n\n        { (type !== 'forest')\n          ? (\n            <label htmlFor=\"newGraphMod\">Moderator:\n              <select name=\"newGraphMod\">\n                { modCols && modCols.map((col) => (\n                  <option\n                    key={`newGraphMod${col.id}`}\n                    value={col.id}\n                  >\n                    { col.title }\n                  </option>\n                )) }\n              </select>\n            </label>\n          )\n          : null }\n        <input type=\"submit\" className=\"graphSubmit\" />\n      </form>\n    </>\n  );\n\n  if (popupStatus) {\n    return (\n      <Popup content={content} closingFunc={closeHandler} />\n    );\n  } else {\n    return null;\n  }\n}\n\nfunction AddGraph(props) {\n  const {\n    graphState, columns, metaanalysis, setSelectedGraph,\n  } = props;\n  const [popupStatus, setPopupStatus] = useState(false);\n\n  function popupToggle() {\n    setPopupStatus(!popupStatus);\n  }\n\n  return (\n    <>\n      <div id=\"addGraphButtonContainer\">\n        <div role=\"button\" type=\"submit\" id=\"addGraphButton\" onClick={popupToggle} onKeyDown={popupToggle} tabIndex={0}>\n          Add new graph\n        </div>\n        <AddGraphPopup\n          graphState={graphState}\n          columns={columns}\n          flag={[popupStatus, setPopupStatus]}\n          metaanalysis={metaanalysis}\n          setSelectedGraph={setSelectedGraph}\n        />\n      </div>\n    </>\n  );\n}\n\nexport default AddGraph;","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/plots/GrapeChart.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/plots/GraphEditor.js","messages":[{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 29 to the 15 allowed.","line":23,"column":12,"nodeType":null,"endLine":23,"endColumn":24},{"ruleId":"sonarjs/no-duplicate-string","severity":2,"message":"Define a constant instead of duplicating this literal 3 times.","line":84,"column":34,"nodeType":"Literal","endLine":85,"endColumn":11},{"ruleId":"sonarjs/no-duplicate-string","severity":2,"message":"Define a constant instead of duplicating this literal 3 times.","line":104,"column":34,"nodeType":"Literal","endLine":105,"endColumn":11},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 26 to the 15 allowed.","line":161,"column":12,"nodeType":null,"endLine":161,"endColumn":24},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 29 to the 15 allowed.","line":279,"column":12,"nodeType":null,"endLine":279,"endColumn":24}],"errorCount":5,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport Popup from '../Popup';\n\nfunction GrapeMenu(props) {\n  const {\n    graph, graphState, columns, popup,\n  } = props;\n  const [graphs, setGraphs] = graphState;\n  const [popupStatus, setPopupStatus] = popup;\n  const graphsClone = [...graphs];\n  const title = graph.title;\n  const params = graph.formulaParams;\n  const modCols = columns.filter((col) => col.subType === 'moderator');\n  const calcCols = columns.filter((col) => col.subType === 'calculator' || col.subType === 'calculatorN');\n  const newParams = [null, null, null, null, null];\n  const paramIndex = [null, null, null, null, null];\n  const newColumnParams = [null, null, null, null, null];\n\n  function popupToggle() {\n    setPopupStatus(!popupStatus);\n  }\n\n  function handleSubmit(e) {\n    e.preventDefault();\n    let formElem;\n    if (e.currentTarget.nodeName === 'FORM') {\n      formElem = e.currentTarget;\n    } else if (e.currentTarget.nodeName === 'SELECT' || e.currentTarget.nodeName === 'INPUT') {\n      formElem = e.currentTarget.parentNode.parentNode;\n    }\n    for (const element of formElem) {\n      const input = element.children.children[0];\n      if (input && (input.nodeName === 'INPUT' || input.nodeName === 'SELECT') && input.type !== 'submit') {\n        switch (input.name) {\n        case 'grapeTitle':\n          if (input.value) {\n            graph.title = input.value;\n          }\n          break;\n        case 'grapeG1':\n          newParams[0] = input.value;\n          break;\n        case 'grapeG2':\n          newParams[2] = input.value;\n          break;\n        case 'grapeMod':\n          newParams[4] = input.value;\n          break;\n        default:\n        }\n      }\n    }\n    for (let i = 0; i < newParams.length; i += 2) {\n      const colParam = columns.filter((col) => col.id === newParams[i] && col.type !== 'result')[0];\n      graph.formulaParams[i] = colParam;\n      newColumnParams[i] = colParam.title;\n      paramIndex[i] = (newParams[i] || graph.formulaParams[i].id);\n      if (i !== 4) {\n        const nColParam = columns.filter((col) => col.id === colParam.linkedN)[0];\n        graph.formulaParams[i + 1] = nColParam;\n        newColumnParams[i + 1] = nColParam.title;\n        paramIndex[i + 1] = nColParam.id;\n      }\n    }\n    graph.formula = `grapeChartPercentGraph(${paramIndex[0]},${paramIndex[1]},${paramIndex[2]},${paramIndex[3]},${paramIndex[4]})`;\n    graph.fullLabel = `Grape chart (percentages)( ${newColumnParams[0] || graph.formulaParams[0].title}, ${newColumnParams[1] || graph.formulaParams[1].title}, ${newColumnParams[2] || graph.formulaParams[2].title}, ${newColumnParams[3] || graph.formulaParams[3].title}, ${newColumnParams[4] || graph.formulaParams[4].title})`;\n    for (let i = 0; i < graphs.length; i += 1) {\n      if (graphsClone[i].id === graph.id) {\n        graphsClone[i] = graph;\n      }\n    }\n    setGraphs(graphsClone);\n    popupToggle();\n  }\n\n  return (\n    <>\n      <h1>Edit { graph.title }</h1>\n      <form className=\"graphForm\" onSubmit={handleSubmit}>\n        <label htmlFor=\"grapeTitle\">Title:\n          <input type=\"text\" name=\"grapeTitle\" placeholder={title} />\n        </label>\n\n        <label htmlFor=\"grapeG1\">Dependent variable 1:\n          <select name=\"grapeG1\">\n            { calcCols && calcCols.map((col) => (\n              <>\n                { col.subType !== 'calculatorN'\n                  ? (\n                    <option\n                      key={`grapeG1${col.id}`}\n                      value={col.id}\n                      selected={params[0] === col ? 'selected' : null}\n                    >\n                      { col.title }\n                    </option>\n                  )\n                  : null }\n              </>\n            )) }\n          </select>\n        </label>\n\n        <label htmlFor=\"grapeG2\">Dependent variable 2:\n          <select name=\"grapeG2\">\n            { calcCols && calcCols.map((col) => (\n              <>\n                { col.subType !== 'calculatorN'\n                  ? (\n                    <option\n                      key={`grapeG2${col.id}`}\n                      value={col.id}\n                      selected={params[2] === col ? 'selected' : null}\n                    >\n                      { col.title }\n                    </option>\n                  )\n                  : null }\n              </>\n            )) }\n          </select>\n        </label>\n\n        <label htmlFor=\"grapeMod\">Moderator:\n          <select name=\"grapeMod\">\n            { modCols && modCols.map((col) => (\n              <option\n                key={`grapeMod${col.id}`}\n                value={col.id}\n                selected={params[4] === col ? 'selected' : null}\n              >\n                { col.title }\n              </option>\n            )) }\n          </select>\n        </label>\n        <input type=\"submit\" className=\"graphSubmit\" />\n      </form>\n    </>\n  );\n}\n\nfunction ForestMenu(props) {\n  const {\n    graph, graphState, columns, popup,\n  } = props;\n  const [graphs, setGraphs] = graphState;\n  const [popupStatus, setPopupStatus] = popup;\n  const graphsClone = [...graphs];\n  const title = graph.title;\n  const params = graph.formulaParams;\n  const calcCols = columns.filter((col) => col.subType === 'calculator');\n  const newParams = [null, null, null, null];\n  const paramIndex = [null, null, null, null];\n  const newColumnParams = [null, null, null, null];\n\n  function popupToggle() {\n    setPopupStatus(!popupStatus);\n  }\n\n  function handleSubmit(e) {\n    e.preventDefault();\n    let formElem;\n    if (e.currentTarget.nodeName === 'FORM') {\n      formElem = e.currentTarget;\n    } else if (e.currentTarget.nodeName === 'SELECT' || e.currentTarget.nodeName === 'INPUT') {\n      formElem = e.currentTarget.parentNode.parentNode;\n    }\n    for (const element of formElem) {\n      const input = element.children.children[0];\n      if (input && (input.nodeName === 'INPUT' || input.nodeName === 'SELECT') && input.type !== 'submit') {\n        switch (input.name) {\n        case 'forestTitle':\n          if (input.value) {\n            graph.title = input.value;\n          }\n          break;\n        case 'forestG1':\n          newParams[0] = input.value;\n          break;\n        case 'forestG2':\n          newParams[2] = input.value;\n          break;\n        default:\n        }\n      }\n    }\n    for (let i = 0; i < newParams.length; i += 2) {\n      const colParam = columns.filter((col) => col.id === newParams[i] && col.type !== 'result')[0];\n      graph.formulaParams[i] = colParam;\n      newColumnParams[i] = colParam.title;\n      paramIndex[i] = (newParams[i] || graph.formulaParams[i].id);\n      const nColParam = columns.filter((col) => col.id === colParam.linkedN)[0];\n      graph.formulaParams[i + 1] = nColParam;\n      newColumnParams[i + 1] = nColParam.title;\n      paramIndex[i + 1] = nColParam.id;\n    }\n    graph.formula = `forestPlotPercentGraph(${paramIndex[0]},${paramIndex[1]},${paramIndex[2]},${paramIndex[3]})`;\n    graph.fullLabel = `Forest plot (percentages)( ${newColumnParams[0] || graph.formulaParams[0].title}, ${newColumnParams[1] || graph.formulaParams[1].title}, ${newColumnParams[2] || graph.formulaParams[2].title}, ${newColumnParams[3] || graph.formulaParams[3].title})`;\n    for (let i = 0; i < graphs.length; i += 1) {\n      if (graphsClone[i].id === graph.id) {\n        graphsClone[i] = graph;\n      }\n    }\n    setGraphs(graphsClone);\n    popupToggle();\n  }\n\n  return (\n    <form className=\"graphForm\" onSubmit={handleSubmit}>\n      <label htmlFor=\"forestTitle\">Title:\n        <input type=\"text\" name=\"forestTitle\" placeholder={title} />\n      </label>\n\n      <label htmlFor=\"forestG1\">Dependent variable 1:\n        <select name=\"forestG1\">\n          { calcCols && calcCols.map((col) => (\n            <>\n              { col.subType !== 'calculatorN'\n                ? (\n                  <option\n                    key={`forestG1${col.id}`}\n                    value={col.id}\n                    selected={params[0] === col ? 'selected' : null}\n                  >\n                    { col.title }\n                  </option>\n                )\n                : null }\n            </>\n          )) }\n        </select>\n      </label>\n\n      <label htmlFor=\"forestG2\">Dependent variable 2:\n        <select name=\"forestG2\">\n          { calcCols && calcCols.map((col) => (\n            <>\n              { col.subType !== 'calculatorN'\n                ? (\n                  <option\n                    key={`forestG2${col.id}`}\n                    value={col.id}\n                    selected={params[2] === col ? 'selected' : null}\n                  >\n                    { col.title }\n                  </option>\n                )\n                : null }\n            </>\n          )) }\n        </select>\n      </label>\n\n      <input type=\"submit\" className=\"graphSubmit\" />\n    </form>\n  );\n}\n\nfunction ForestGroupMenu(props) {\n  const {\n    graph, graphState, columns, popup,\n  } = props;\n  const [graphs, setGraphs] = graphState;\n  const [popupStatus, setPopupStatus] = popup;\n  const graphsClone = [...graphs];\n  const title = graph.title;\n  const params = graph.formulaParams;\n  const modCols = columns.filter((col) => col.subType === 'moderator');\n  const calcCols = columns.filter((col) => col.subType === 'calculator');\n  const newParams = [null, null, null, null, null];\n  const paramIndex = [null, null, null, null, null];\n  const newColumnParams = [null, null, null, null, null];\n\n  function popupToggle() {\n    setPopupStatus(!popupStatus);\n  }\n\n  function handleSubmit(e) {\n    e.preventDefault();\n    let formElem;\n    if (e.currentTarget.nodeName === 'FORM') {\n      formElem = e.currentTarget;\n    } else if (e.currentTarget.nodeName === 'SELECT' || e.currentTarget.nodeName === 'INPUT') {\n      formElem = e.currentTarget.parentNode.parentNode;\n    }\n    for (const element of formElem) {\n      const input = element.children.children[0];\n      if (input && (input.nodeName === 'INPUT' || input.nodeName === 'SELECT') && input.type !== 'submit') {\n        switch (input.name) {\n        case 'forestGroupTitle':\n          if (input.value) {\n            graph.title = input.value;\n          }\n          break;\n        case 'forestGroupG1':\n          newParams[0] = input.value;\n          break;\n        case 'forestGroupG2':\n          newParams[2] = input.value;\n          break;\n        case 'forestGroupMod':\n          newParams[4] = input.value;\n          break;\n        default:\n        }\n      }\n    }\n    for (let i = 0; i < newParams.length; i += 2) {\n      const colParam = columns.filter((col) => col.id === newParams[i] && col.type !== 'result')[0];\n      graph.formulaParams[i] = colParam;\n      newColumnParams[i] = colParam.title;\n      paramIndex[i] = (newParams[i] || graph.formulaParams[i].id);\n      if (i !== 4) {\n        const nColParam = columns.filter((col) => col.id === colParam.linkedN)[0];\n        graph.formulaParams[i + 1] = nColParam;\n        newColumnParams[i + 1] = nColParam.title;\n        paramIndex[i + 1] = nColParam.id;\n      }\n    }\n    graph.formula = `forestPlotGroupPercentGraph(${paramIndex[0]},${paramIndex[1]},${paramIndex[2]},${paramIndex[3]},${paramIndex[4]})`;\n    graph.fullLabel = `Forest Plot Group (percentages)( ${newColumnParams[0] || graph.formulaParams[0].title}, ${newColumnParams[1] || graph.formulaParams[1].title}, ${newColumnParams[2] || graph.formulaParams[2].title}, ${newColumnParams[3] || graph.formulaParams[3].title}, ${newColumnParams[4] || graph.formulaParams[4].title})`;\n    for (let i = 0; i < graphs.length; i += 1) {\n      if (graphsClone[i].id === graph.id) {\n        graphsClone[i] = graph;\n      }\n    }\n    setGraphs(graphsClone);\n    popupToggle();\n  }\n\n  return (\n    <form className=\"graphForm\" onSubmit={handleSubmit}>\n      <label htmlFor=\"forestGroupTitle\">Title:\n        <input type=\"text\" name=\"forestGroupTitle\" placeholder={title} />\n      </label>\n\n      <label htmlFor=\"forestGroupG1\">Dependent variable 1:\n        <select name=\"forestGroupG1\">\n          { calcCols && calcCols.map((col) => (\n            <>\n              { col.subType !== 'calculatorN'\n                ? (\n                  <option\n                    key={`forestGroupG1${col.id}`}\n                    value={col.id}\n                    selected={params[0] === col ? 'selected' : null}\n                  >\n                    { col.title }\n                  </option>\n                )\n                : null }\n            </>\n          )) }\n        </select>\n      </label>\n\n      <label htmlFor=\"forestGroupG2\">Dependent variable 2:\n        <select name=\"forestGroupG2\">\n          { calcCols && calcCols.map((col) => (\n            <>\n              { col.subType !== 'calculatorN'\n                ? (\n                  <option\n                    key={`forestGroupG2${col.id}`}\n                    value={col.id}\n                    selected={params[2] === col ? 'selected' : null}\n                  >\n                    { col.title }\n                  </option>\n                )\n                : null }\n            </>\n          )) }\n        </select>\n      </label>\n\n      <label htmlFor=\"forestGroupMod\">Moderator:\n        <select name=\"forestGroupMod\">\n          { modCols && modCols.map((col) => (\n            <option\n              key={`forestGroupMod${col.id}`}\n              value={col.id}\n              selected={params[4] === col ? 'selected' : null}\n            >\n              { col.title }\n            </option>\n          )) }\n        </select>\n      </label>\n      <input type=\"submit\" className=\"graphSubmit\" />\n    </form>\n  );\n}\n\nfunction GraphEditor(props) {\n  const { graph, graphState, columns } = props;\n  const [popupStatus, setPopupStatus] = useState(false);\n  let content;\n\n  function popupToggle() {\n    setPopupStatus(!popupStatus);\n  }\n\n  switch (graph.formulaName) {\n  case 'grapeChartPercentGraph':\n    content = (\n      <GrapeMenu\n        graph={graph}\n        graphState={graphState}\n        columns={columns}\n        popup={[popupStatus, setPopupStatus]}\n      />\n    );\n    break;\n  case 'forestPlotPercentGraph':\n    content = (\n      <ForestMenu\n        graph={graph}\n        graphState={graphState}\n        columns={columns}\n        popup={[popupStatus, setPopupStatus]}\n      />\n    );\n    break;\n  case 'forestPlotGroupPercentGraph':\n    content = (\n      <ForestGroupMenu\n        graph={graph}\n        graphState={graphState}\n        columns={columns}\n        popup={[popupStatus, setPopupStatus]}\n      />\n    );\n    break;\n  default:\n  }\n\n  return (\n    <>\n      <div id=\"editGraphButtonContainer\">\n        <div role=\"button\" type=\"submit\" id=\"editGraphButton\" onClick={popupToggle} onKeyDown={popupToggle} tabIndex={0}>\n          Edit this graph\n        </div>\n        { popupStatus\n          ? (\n            <Popup content={content} closingFunc={popupToggle} />\n          )\n          : null }\n      </div>\n    </>\n  );\n}\n\nexport default GraphEditor;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/plots/GroupingForestPlots.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/plots/PlotSelector.js","messages":[{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 16 to the 15 allowed.","line":9,"column":10,"nodeType":null,"endLine":9,"endColumn":22}],"errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useContext } from 'react';\nimport GraphEditor from './GraphEditor';\nimport AddGraph from './AddGraph';\nimport Plots from './Plots';\nimport EditContext from '../EditContext';\nimport { RemovalPopup } from '../Popup';\nimport './Plots.css';\n\nfunction PlotSelector(props) {\n  const { graphState, columns, metaanalysis } = props;\n  const [graphs, setGraphs] = graphState;\n  const [selectedGraph, setSelectedGraph] = useState(graphs[0]);\n  const [popupStatus, setPopupStatus] = useState(false);\n  const edit = useContext(EditContext);\n\n  function popupToggle() {\n    setPopupStatus(!popupStatus);\n  }\n\n  function removeGraph() {\n    const graphsClone = [...graphs];\n    graphsClone.splice(graphsClone.indexOf(selectedGraph), 1);\n\n    setGraphs(graphsClone);\n    setSelectedGraph(graphsClone[0]);\n  }\n\n  function handleGraphChange(e) {\n    let graph = graphs[0];\n    for (const g of graphs) {\n      if (g.id === Number(e.currentTarget.value)) {\n        graph = g;\n      }\n    }\n    setSelectedGraph(graph);\n  }\n\n  return (\n    <>\n      <div id=\"plotContainer\">\n        <div id=\"graphSelectionContainer\">\n          <label htmlFor=\"plotSelect\" id=\"plotSelect\"> Select a graph\n            <select name=\"plotSelect\" id=\"plotSelect\" onChange={handleGraphChange}>\n              { graphs.map((graph) => (\n                <option value={graph.id} key={graph.id} selected={graph === selectedGraph ? 'selected' : null}>{ graph.title }</option>\n              )) }\n            </select>\n          </label>\n          { edit.flag\n            ? (\n              <div id=\"graphButtonContainer\">\n                <AddGraph\n                  graphState={graphState}\n                  columns={columns}\n                  metaanalysis={metaanalysis}\n                  setSelectedGraph={setSelectedGraph}\n                />\n                { selectedGraph && graphs !== {}\n                  ? (\n                    <>\n                      <GraphEditor\n                        graph={selectedGraph}\n                        graphState={graphState}\n                        columns={columns}\n                      />\n                      <div className=\"removeGraphButton\" role=\"button\" tabIndex={0} onClick={popupToggle} onKeyDown={popupToggle}>Remove</div>\n                      { popupStatus\n                        ? (\n                          <RemovalPopup\n                            closingFunc={popupToggle}\n                            removalFunc={removeGraph}\n                            removalText={selectedGraph.title}\n                          />\n                        )\n                        : null }\n                    </>\n                  )\n                  : null }\n              </div>\n            )\n            : null }\n        </div>\n        <div id=\"graphContainer\">\n          { selectedGraph && graphs !== {}\n            ? (\n              <div id=\"graphSVGContainer\">\n                <Plots selectedGraph={selectedGraph} />\n              </div>\n            )\n            : null }\n        </div>\n      </div>\n    </>\n  );\n}\n\nexport default PlotSelector;\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/plots/Plots.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/plots/SimpleForestPlots.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/tags/NewTag.js","messages":[{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 18 to the 15 allowed.","line":3,"column":25,"nodeType":null,"endLine":3,"endColumn":31}],"errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useRef } from 'react';\n\nexport default function NewTag(props) {\n  const { empty, onAdd } = props;\n\n  const [newTag, setNewTag] = useState('');\n  const [adding, setAdding] = useState(false);\n\n  const inputEl = useRef();\n\n  useEffect(() => {\n    if (inputEl.current && adding === 'focus') {\n      inputEl.current.focus();\n      setAdding(true);\n    }\n  });\n\n  const handleChange = (e) => {\n    setNewTag(e.target.value);\n  };\n\n  const doAdd = (e) => {\n    if (e.type === 'click' || e.key === ' ' || e.key === 'Enter') {\n      if (adding) {\n        setNewTag('');\n        onAdd(newTag);\n      } else {\n        setAdding('focus');\n      }\n      e.preventDefault();\n    } else if (e.key === 'Escape' && adding) {\n      setNewTag('');\n      setAdding(false);\n      e.nativeEvent.stopImmediatePropagation();\n    }\n  };\n\n  const handleKey = (e) => {\n    if (e.key === 'Enter' || e.key === 'Escape') {\n      doAdd(e);\n    }\n  };\n\n  if (empty && !adding) {\n    return (\n      <li className=\"addtag\">\n        <span\n          className=\"text\"\n          role=\"button\"\n          tabIndex={0}\n          onClick={doAdd}\n          onKeyPress={doAdd}\n        >\n          add tags\n        </span>\n      </li>\n    );\n  }\n\n  return (\n    <>\n      { adding && (\n        <li className=\"new\">\n          <input\n            type=\"text\"\n            value={newTag}\n            onChange={handleChange}\n            onKeyDown={handleKey}\n            placeholder=\"new tag\"\n            ref={inputEl}\n          />\n        </li>\n      ) }\n      <li className=\"addtag\">\n        <span\n          className=\"text\"\n          role=\"button\"\n          tabIndex={0}\n          onClick={doAdd}\n          onKeyDown={doAdd}\n        >\n          +\n        </span>\n      </li>\n    </>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/tags/Tag.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/components/metaanalysis/tags/TagList.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/metaanalysis.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/tools/datatools.js","messages":[{"ruleId":"sonarjs/no-same-line-conditional","severity":2,"message":"{\"message\":\"Move this \\\"if\\\" to a new line or add the missing \\\"else\\\".\",\"secondaryLocations\":[{\"column\":2,\"line\":18,\"endColumn\":3,\"endLine\":18}]}","line":18,"column":5,"nodeType":null,"endLine":18,"endColumn":7},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 20 to the 15 allowed.","line":159,"column":10,"nodeType":null,"endLine":159,"endColumn":39},{"ruleId":"sonarjs/no-collapsible-if","severity":2,"message":"Merge this if statement with the nested one.","line":185,"column":5,"nodeType":null,"endLine":185,"endColumn":7},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 42 to the 15 allowed.","line":217,"column":17,"nodeType":null,"endLine":217,"endColumn":39}],"errorCount":4,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"function renumberComputedObjects(array, prefix) {\n  prefix = prefix || '';\n  let count = 0;\n  array.forEach((object) => {\n    if (object.formula) {\n      object.number = prefix + (count += 1);\n    }\n  });\n}\n\n// level is how much parameter nesting we want to show:\n// 0 - no parameters, e.g. sum(...)\n// 1 - parameters without their parameters, e.g. sum(weight(...))\n// Infinity - full nesting\nfunction getColTitle(col, level) {\n  if (col == null) {\n    return 'none';\n  } if (typeof col !== 'object') {\n    throw new Error(`we do not expect non-object param ${col}`);\n  } else if (col.id) {\n    return col.title;\n  } else if (col.formula) {\n    return getRichColumnLabel(col, level);\n  } else {\n    throw new Error(`this should never happen - we do not know what title this col should have: ${col}`);\n  }\n}\n\nfunction getFormulaLabel(formulaObj) {\n  return (formulaObj ? formulaObj.label : 'no formula selected');\n}\n\nfunction getRichColumnLabel(col, level) {\n  if (level == null) level = col.number == null ? 1 : 0;\n\n  if (col.title && level !== Infinity) { // Don't substitute full nesting for title\n    return col.title;\n  }\n\n  let retval = '';\n  if (level !== Infinity && col.number != null) retval += col.number;\n  if (col.grouping) retval += 'Grouping ';\n  retval += `${getFormulaLabel(col.formulaObj)}(`;\n\n  if (level === 0) {\n    retval += '';\n  } else {\n    for (let i = 0; i < col.formulaParams.length; i += 1) {\n      retval += ` ${getColTitle(col.formulaParams[i], level - 1)}`;\n      if (i < col.formulaParams.length - 1) retval += ',';\n    }\n    retval += ' ';\n  }\n  return `${retval})`;\n}\n\n// this function is the center of the app :\n// it will add some data to the MA object we receive from the API so we can display them in the app\n// it will also give some objects a circular reference to the parent object :\n// e.g.: each experiment will have access to its parent paper\nexport function populateCircularMa(ma) {\n  for (const paper of ma.papers) { // for each paper\n    paper.metaanalysis = ma; // we add a circular ref to the entire metaanalysis object\n    let i = 0;\n    for (const exp of paper.experiments) { // for each experiment of a paper\n      exp.index = i; // we add an index which will be usefull later\n      exp.paper = paper; // we also add a reference to its parent paper\n      i += 1;\n    }\n  }\n  // ..........\n\n  // \"excluded = true\" in each excluded experiment\n  const hashPapers = generateIDHash(ma.papers);\n  for (const excludedExp of ma.excludedExperiments) {\n    const [paperId, expIndex] = excludedExp.split(',');\n    if (hashPapers[paperId].experiments[expIndex] != null) {\n      hashPapers[paperId].experiments[expIndex].excluded = true;\n    }\n  }\n\n  ma.hashcols = generateIDHash(ma.columns);\n  if (ma.groupingColumn) {\n    ma.groups = getGroups(ma);\n  }\n\n  renumberComputedObjects(ma.columns);\n\n  // merges stock elements with the result of populateParsedFormula\n  for (let col of ma.columns) {\n    if (!col.id) {\n      const colWithParsedFormula = populateParsedFormula(col, ma, ma.hashcols);\n      col = Object.assign(col, colWithParsedFormula);\n      col.fullLabel = getColTitle(col, Infinity);\n    }\n  }\n  for (let aggr of ma.aggregates) {\n    const aggrWithParsedFormula = populateParsedFormula(aggr, ma, ma.hashcols);\n    aggr = Object.assign(aggr, aggrWithParsedFormula);\n    aggr.fullLabel = getColTitle(aggr, Infinity);\n  }\n  for (let aggr of ma.groupingAggregates) {\n    const aggrWithParsedFormula = populateParsedFormula(aggr, ma, ma.hashcols);\n    aggr = Object.assign(aggr, aggrWithParsedFormula);\n    aggr.fullLabel = getColTitle(aggr, Infinity);\n  }\n  for (let graph of ma.graphs) {\n    const aggrWithParsedFormula = populateParsedFormula(graph, ma, ma.hashcols);\n    graph = Object.assign(graph, aggrWithParsedFormula);\n    graph.fullLabel = getColTitle(graph, Infinity);\n  }\n}\n\n// \"converts\" an object into one that is easier to manipulate\nfunction generateIDHash(objects) {\n  const retval = {};\n  objects.forEach((obj) => {\n    if (obj.id) retval[obj.id] = obj;\n  });\n  return retval;\n}\n\nexport function formatNumber(x) {\n  if (typeof x !== 'number') return x;\n  const xabs = Math.abs(x);\n  // if (xabs >= 1000) return x.toFixed(0);\n  // this would drop the decimal point from large values (needs tweaks in padNumber below)\n  if (xabs >= 100) return x.toFixed(1);\n  if (xabs >= 10) return x.toFixed(2);\n  return x.toFixed(3);\n}\n\nfunction populateParsedFormula(col, ma, hashcols) {\n  const formula = window.lima.parseFormulaString(col.formula, hashcols);\n  formula.metaanalysis = ma;\n  return formula;\n}\n\nexport function isColCompletelyDefined(col) {\n  if (col == null) return false;\n  if (col.id) return true;\n  if (!col.formulaObj) return false;\n  for (const formula of col.formulaParams) {\n    if (!isColCompletelyDefined(formula)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction isExperimentsTableColumn(col) {\n  return col.id || (col.formulaObj && col.formulaObj.type === window.lima.FORMULA_TYPE);\n}\n\nfunction isAggregate(col) {\n  return col.formulaObj && col.formulaObj.type === window.lima.AGGREGATE_TYPE;\n}\n\nfunction getExperimentsTableDatumValue(col, experiment) {\n  let val = null;\n  if (col.id) {\n    const mappedColumnId = col.sourceColumnMap[experiment.paper.id];\n    // not a computed column\n    if (experiment\n        && experiment.data\n        && experiment.data[mappedColumnId]\n        && experiment.data[mappedColumnId].value != null) {\n      val = experiment.data[mappedColumnId].value;\n    }\n  } else {\n    // computed column\n    const inputs = [];\n\n    if (isColCompletelyDefined(col)) {\n      const formula = col.formulaObj;\n      if (formula == null) return NaN;\n      // compute the value\n      // if anything here throws an exception, value cannot be computed\n      for (const param of col.formulaParams) {\n        inputs.push(getDatumValue(param, experiment));\n      }\n      val = formula.func.apply(null, inputs);\n    }\n    // if the result is NaN but some of the inputs were empty, change the result to empty.\n    if (typeof val === 'number' && Number.isNaN(val)) {\n      if (inputs.some((x) => x == null || x === '')) val = null;\n    }\n  }\n\n  return val;\n}\n\nexport function getDatumValue(col, experiment) {\n  const { papers } = experiment.paper.metaanalysis;\n  if (isExperimentsTableColumn(col)) {\n    return getExperimentsTableDatumValue(col, experiment);\n  }\n\n  if (isAggregate(col)) {\n    if (col.grouping) {\n      const group = getGroup(experiment);\n      if (group == null) {\n        // no need to run the grouping aggregate if we don't have a group\n        console.warn('trying to compute a grouping aggregate without a group');\n        return NaN;\n      } else {\n        return getAggregateDatumValue(col, papers, group);\n      }\n    } else {\n      return getAggregateDatumValue(col, papers);\n    }\n  }\n\n  return null;\n}\n\nexport function getAggregateDatumValue(aggregate, papers, group, moderator) {\n  const ma = papers[0].metaanalysis; // TODO: probably a bug here\n  if (!aggregate.grouping) group = null;\n\n  // return NaN if we have a group but don't have a grouping column\n  if (group != null && ma.groupingColumnObj == null) {\n    console.warn('trying to compute a grouping aggregate without a grouping column');\n    return NaN;\n  }\n\n  const inputs = [];\n  let val;\n  if (isColCompletelyDefined(aggregate)) {\n    const formula = aggregate.formulaObj;\n    if (formula == null) return NaN;\n\n    // compute the value\n    // if anything here throws an exception, value cannot be computed\n    for (const param of aggregate.formulaParams) {\n      let currentInput;\n      if (isExperimentsTableColumn(param)) {\n        currentInput = [];\n        for (const paper of papers) {\n          for (const exp of paper.experiments) {\n            if (!exp.excluded && !(group != null && getGroup(exp, moderator) !== group)) {\n              currentInput.push(getDatumValue(param, exp));\n            }\n          }\n        }\n      } else if (isAggregate(param)) {\n        if (!param.grouping) {\n          currentInput = getAggregateDatumValue(param, papers, undefined);\n        } else if (param.grouping && group != null) {\n          currentInput = getAggregateDatumValue(param, papers, group);\n        } else if (param.grouping && group == null) {\n          // currentParam is grouping but we don't have a group\n          // so currentInput should be an array per group\n          const groups = getGroups(ma);\n          currentInput = [];\n          for (const g of groups) {\n            currentInput.push(getAggregateDatumValue(param, papers, g));\n          }\n        }\n      }\n      inputs.push(currentInput);\n    }\n    val = formula.func.apply(null, inputs);\n  }\n\n  return val;\n}\n\nfunction getGroup(experiment, moderatorObj) {\n  const { groupingColumnObj } = experiment.paper.metaanalysis;\n  if (!moderatorObj) {\n    moderatorObj = groupingColumnObj;\n  }\n  if (moderatorObj) {\n    return getDatumValue(moderatorObj, experiment);\n  } else {\n    return null;\n  }\n}\n\nexport function getGroups(ma) {\n  const groupingColumnObj = window.lima.parseFormulaString(ma.groupingColumn, ma.hashcols);\n  ma.groupingColumnObj = groupingColumnObj;\n  if (!groupingColumnObj) return [];\n\n  const groups = [];\n  for (const paper of ma.papers) {\n    for (const exp of paper.experiments) {\n      if (!exp.excluded) {\n        const group = getGroup(exp);\n        if (group != null && group !== '' && groups.indexOf(group) === -1) {\n          groups.push(group);\n        }\n      }\n    }\n  }\n\n  groups.sort(); // alphabetically\n  return groups;\n}\n\nfunction twoDigits(x) {\n  return x < 10 ? `0${x}` : `${x}`;\n}\n\n// this function is used each time we display ctime or mtime\nexport function formatDateTime(timestamp) {\n  const d = new Date(timestamp);\n\n  const date = `${d.getFullYear()}-${twoDigits((d.getMonth() + 1))}-${twoDigits(d.getDate())}`;\n  const time = `${twoDigits(d.getHours())}:${twoDigits(d.getMinutes())}`;\n  const datetime = `${date} ${time}`;\n  return datetime;\n}\n\n// this function is used to split date and time separately\nexport function formatDateTimeSplit(timestamp) {\n  const d = new Date(timestamp);\n\n  const date = `${d.getFullYear()}-${twoDigits((d.getMonth() + 1))}-${twoDigits(d.getDate())}`;\n  const time = `${twoDigits(d.getHours())}:${twoDigits(d.getMinutes())}`;\n  return { date: `${date}`, time: `${time}` };\n}\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/tools/editTools.js","messages":[{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 43 to the 15 allowed.","line":1,"column":25,"nodeType":null,"endLine":1,"endColumn":36},{"ruleId":"sonarjs/no-collapsible-if","severity":2,"message":"Merge this if statement with the nested one.","line":6,"column":9,"nodeType":null,"endLine":6,"endColumn":11}],"errorCount":2,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export default function replaceCell(papers, columns, value, cellId, currentUser) {\n  const papersClone = [...papers];\n  for (const paper of papersClone) {\n    for (const exp of paper.experiments) {\n      for (const col of columns) {\n        if (col.id) {\n          if (cellId === `${exp.ctime + paper.id}+${col.id}`) {\n            let mapped = col.sourceColumnMap[exp.paper.id];\n            // if the paper does not have data for this column\n            if (!mapped) {\n              // Assign each of its papers default data for the column,\n              // indexed by the maximum length of the paper's data attribute\n              let index;\n              for (const exper of paper.experiments) {\n                if (!index || index < Object.keys(exper.data).length) {\n                  index = Object.keys(exper.data).length;\n                }\n                exper.data[index + 1] = {\n                  ctime: null,\n                  enteredBy: null,\n                  value: null,\n                };\n              }\n              // Set the source map for the column to reflect the index\n              col.sourceColumnMap[exp.paper.id] = index + 1;\n              mapped = col.sourceColumnMap[exp.paper.id];\n            }\n            exp.data[mapped].value = value;\n            // If the paper's data for the column is still default\n            // set it to correct values\n            if (exp.data[mapped].ctime === null) {\n              const newTime = new Date().getTime();\n              exp.data[mapped].ctime = newTime;\n              exp.data[mapped].enteredBy = currentUser.displayName;\n            }\n          }\n        }\n      }\n    }\n  }\n  return papersClone;\n}\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/tools/google-auth.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/tools/graphtools.js","messages":[{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 61 to the 15 allowed.","line":3,"column":17,"nodeType":null,"endLine":3,"endColumn":40},{"ruleId":"sonarjs/prefer-object-literal","severity":2,"message":"Declare one or more properties of this object inside of the object literal syntax instead of using separate statements.","line":57,"column":15,"nodeType":"VariableDeclarator","endLine":57,"endColumn":24},{"ruleId":"sonarjs/no-duplicate-string","severity":2,"message":"Define a constant instead of duplicating this literal 3 times.","line":60,"column":39,"nodeType":"Literal","endLine":60,"endColumn":55},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 112 to the 15 allowed.","line":234,"column":17,"nodeType":null,"endLine":234,"endColumn":42},{"ruleId":"sonarjs/prefer-object-literal","severity":2,"message":"Declare one or more properties of this object inside of the object literal syntax instead of using separate statements.","line":295,"column":15,"nodeType":"VariableDeclarator","endLine":295,"endColumn":24},{"ruleId":"sonarjs/prefer-object-literal","severity":2,"message":"Declare one or more properties of this object inside of the object literal syntax instead of using separate statements.","line":362,"column":11,"nodeType":"VariableDeclarator","endLine":362,"endColumn":25},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 107 to the 15 allowed.","line":602,"column":17,"nodeType":null,"endLine":602,"endColumn":34},{"ruleId":"sonarjs/prefer-object-literal","severity":2,"message":"Declare one or more properties of this object inside of the object literal syntax instead of using separate statements.","line":662,"column":15,"nodeType":"VariableDeclarator","endLine":662,"endColumn":24},{"ruleId":"sonarjs/prefer-object-literal","severity":2,"message":"Declare one or more properties of this object inside of the object literal syntax instead of using separate statements.","line":707,"column":11,"nodeType":"VariableDeclarator","endLine":707,"endColumn":25},{"ruleId":"sonarjs/prefer-object-literal","severity":2,"message":"Declare one or more properties of this object inside of the object literal syntax instead of using separate statements.","line":834,"column":13,"nodeType":"VariableDeclarator","endLine":834,"endColumn":22}],"errorCount":10,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { isColCompletelyDefined, getDatumValue, getAggregateDatumValue } from './datatools';\n\nexport function getSimpleForestPlotData(graph) {\n  const { papers } = graph.metaanalysis;\n  const { formulaParams } = graph;\n\n  let orFunc;\n  let wtFunc;\n  let lclFunc;\n  let uclFunc;\n\n  const lineHeight = 30;\n  const graphWidth = 300;\n  const startHeight = 70;\n  const endHeight = 65;\n  const minWtSize = 4;\n  const maxWtSize = 14;\n  const minDiamondWidth = 14;\n\n  if (graph.formulaName === 'forestPlotGraph' && isColCompletelyDefined(graph)) {\n    orFunc = { formulaName: 'logOddsRatio', formulaParams: [formulaParams[0], formulaParams[2]] };\n    wtFunc = { formulaName: 'weight', formulaParams };\n    lclFunc = { formulaName: 'lowerConfidenceLimit', formulaParams };\n    uclFunc = { formulaName: 'upperConfidenceLimit', formulaParams };\n  } else\n  if (graph.formulaName === 'forestPlotNumberGraph' && isColCompletelyDefined(graph)) {\n    orFunc = { formulaName: 'logOddsRatioNumber', formulaParams };\n    wtFunc = { formulaName: 'weightNumber', formulaParams };\n    lclFunc = { formulaName: 'lowerConfidenceLimitNumber', formulaParams };\n    uclFunc = { formulaName: 'upperConfidenceLimitNumber', formulaParams };\n  } else\n  if (graph.formulaName === 'forestPlotPercentGraph' && isColCompletelyDefined(graph)) {\n    orFunc = { formulaName: 'logOddsRatioPercent', formulaParams: [formulaParams[0], formulaParams[2]] };\n    wtFunc = { formulaName: 'weightPercent', formulaParams };\n    lclFunc = { formulaName: 'lowerConfidenceLimitPercent', formulaParams };\n    uclFunc = { formulaName: 'upperConfidenceLimitPercent', formulaParams };\n  } else {\n    return;\n    // this function does not handle this type of graph or the graph is not completely defined\n  }\n\n  // get the data\n  orFunc.formula = window.lima.createFormulaString(orFunc);\n  wtFunc.formula = window.lima.createFormulaString(wtFunc);\n  lclFunc.formula = window.lima.createFormulaString(lclFunc);\n  uclFunc.formula = window.lima.createFormulaString(uclFunc);\n  orFunc.formulaObj = window.lima.getFormulaObject(orFunc.formulaName);\n  wtFunc.formulaObj = window.lima.getFormulaObject(wtFunc.formulaName);\n  lclFunc.formulaObj = window.lima.getFormulaObject(lclFunc.formulaName);\n  uclFunc.formulaObj = window.lima.getFormulaObject(uclFunc.formulaName);\n\n  const lines = [];\n\n  for (const paper of papers) {\n    for (const exp of paper.experiments) {\n      if (!exp.excluded) {\n        const line = {};\n        line.title = paper.title || 'new paper';\n        if (paper.experiments.length > 1) {\n          let expTitle = exp.title || 'new experiment';\n          if (expTitle.match(/^\\d+$/)) expTitle = `Exp. ${expTitle}`;\n          line.title += ` (${expTitle})`;\n        }\n        line.or = getDatumValue(orFunc, exp);\n        line.wt = getDatumValue(wtFunc, exp);\n        line.lcl = getDatumValue(lclFunc, exp);\n        line.ucl = getDatumValue(uclFunc, exp);\n        lines.push(line);\n\n        // if any of the values is NaN or Infinity, disregard this experiment\n        if (Number.isNaN(line.or * 0) || Number.isNaN(line.lcl * 0)\n              || Number.isNaN(line.ucl * 0) || Number.isNaN(line.wt * 0)\n              || line.or == null || line.lcl == null || line.ucl == null || line.wt == null) {\n          delete line.or;\n          delete line.lcl;\n          delete line.ucl;\n          delete line.wt;\n        }\n      }\n    }\n  }\n  if (lines.length === 0) {\n    const noDataLine = { title: 'No data' };\n    lines.push(noDataLine);\n  }\n  const orAggrFunc = { formulaName: 'weightedMeanAggr', formulaParams: [orFunc, wtFunc] };\n  const lclAggrFunc = { formulaName: 'lowerConfidenceLimitAggr', formulaParams: [orFunc, wtFunc] };\n  const uclAggrFunc = { formulaName: 'upperConfidenceLimitAggr', formulaParams: [orFunc, wtFunc] };\n\n  orAggrFunc.formula = window.lima.createFormulaString(orAggrFunc);\n  lclAggrFunc.formula = window.lima.createFormulaString(lclAggrFunc);\n  uclAggrFunc.formula = window.lima.createFormulaString(uclAggrFunc);\n  orAggrFunc.formulaObj = window.lima.getFormulaObject(orAggrFunc.formulaName);\n  lclAggrFunc.formulaObj = window.lima.getFormulaObject(lclAggrFunc.formulaName);\n  uclAggrFunc.formulaObj = window.lima.getFormulaObject(uclAggrFunc.formulaName);\n  orAggrFunc.metaanalysis = graph.metaanalysis;\n  lclAggrFunc.metaanalysis = graph.metaanalysis;\n  orAggrFunc.metaanalysis = graph.metaanalysis;\n\n  const aggregates = {\n    or: getAggregateDatumValue(orAggrFunc, graph.metaanalysis.papers),\n    lcl: getAggregateDatumValue(lclAggrFunc, graph.metaanalysis.papers),\n    ucl: getAggregateDatumValue(uclAggrFunc, graph.metaanalysis.papers),\n  };\n\n  if (Number.isNaN(aggregates.or * 0)\n        || Number.isNaN(aggregates.lcl * 0)\n        || Number.isNaN(aggregates.ucl * 0)) {\n    aggregates.lcl = 0;\n    aggregates.ucl = 0;\n  }\n  let sumOfWt = 0;\n  let minWt = Infinity;\n  let maxWt = -Infinity;\n  let minLcl = aggregates.lcl;\n  let maxUcl = aggregates.ucl;\n\n  if (Number.isNaN(minLcl)) minLcl = 0;\n  if (Number.isNaN(maxUcl)) maxUcl = 0;\n\n  for (const line of lines) {\n    // eslint-disable-next-line no-continue\n    if (line.or == null) continue;\n    sumOfWt += line.wt;\n    if (line.wt < minWt) minWt = line.wt;\n    if (line.wt > maxWt) maxWt = line.wt;\n    if (line.lcl < minLcl) minLcl = line.lcl;\n    if (line.ucl > maxUcl) maxUcl = line.ucl;\n  }\n  if (minLcl < -10) minLcl = -10;\n  if (maxUcl > 10) maxUcl = 10;\n\n  if (minWt === Infinity) {\n    minWt = 1;\n    maxWt = 1;\n  }\n  if (sumOfWt === 0) sumOfWt = 1;\n  let TICK_SPACING;\n\n  // select tick spacing based on a rough estimate of how many ticks we'll need anyway\n  const clSpread = (maxUcl - minLcl) / Math.LN10; // how many orders of magnitude we cover\n  if (clSpread > 3) TICK_SPACING = [100];\n  else if (clSpread > 1.3) TICK_SPACING = [10];\n  else TICK_SPACING = [2, 2.5, 2]; // ticks at 1, 2, 5, 10, 20, 50, 100...\n\n  // adjust minimum and maximum around decimal non-logarithmic values\n  let newBound = 1;\n  let tickNo = 0;\n  while (Math.log(newBound) > minLcl) {\n    tickNo -= 1;\n    newBound /= TICK_SPACING[window.lima._.mod(tickNo, TICK_SPACING.length)];\n    // JS % can be negative\n  }\n  minLcl = Math.log(newBound) - 0.1;\n\n  let startingTickVal = newBound;\n  let startingTick = tickNo;\n\n  newBound = 1;\n  tickNo = 0;\n  while (Math.log(newBound) < maxUcl) {\n    newBound *= TICK_SPACING[window.lima._.mod(tickNo, TICK_SPACING.length)];\n    tickNo += 1;\n  }\n  maxUcl = Math.log(newBound) + 0.1;\n\n  const xRatio = (1 / (maxUcl - minLcl)) * graphWidth;\n\n  // return the X coordinate on the graph that corresponds to the given logarithmic value\n  function getX(val) {\n    return (val - minLcl) * xRatio;\n  }\n\n  // adjust weights so that in case of very similar weights they don't range from minimum to maximum\n  const MIN_WT_SPREAD = 2.5;\n  if (maxWt / minWt < MIN_WT_SPREAD) {\n    minWt = (maxWt + minWt) / 2 / Math.sqrt(MIN_WT_SPREAD);\n    maxWt = minWt * MIN_WT_SPREAD;\n  }\n\n  // minWt = 0;\n  // we can uncomment this to make all weights relative to only the maximum weight\n  maxWt = Math.sqrt(maxWt);\n  minWt = Math.sqrt(minWt);\n  const wtRatio = (1 / (maxWt - minWt)) * (maxWtSize - minWtSize);\n\n  let currY = startHeight;\n\n  for (const line of lines) {\n    line.currY = currY;\n    currY += lineHeight;\n  }\n\n  if (!Number.isNaN(aggregates.or * 0)) {\n    let lclX = getX(aggregates.lcl);\n    let uclX = getX(aggregates.ucl);\n    const orX = getX(aggregates.or);\n    if ((uclX - lclX) < minDiamondWidth) {\n      const ratio = (uclX - lclX) / minDiamondWidth;\n      lclX = orX + (lclX - orX) / ratio;\n      uclX = orX + (uclX - orX) / ratio;\n    }\n    const confidenceInterval = `${lclX},0 ${orX},-10 ${uclX},0 ${orX},10`;\n\n    aggregates.minWtSize = minWtSize;\n    aggregates.minWt = minWt;\n    aggregates.wtRatio = wtRatio;\n    aggregates.minLcl = minLcl;\n    aggregates.xRatio = xRatio;\n    aggregates.sumOfWt = sumOfWt;\n    aggregates.currY = currY;\n    aggregates.confidenceInterval = confidenceInterval;\n\n    // put axes into the plot\n    const tickVals = [];\n    let tickVal;\n\n    while ((tickVal = Math.log(startingTickVal)) < maxUcl) {\n      tickVal = Math.log(startingTickVal);\n      tickVals.push([tickVal, startingTickVal]);\n      startingTickVal *= TICK_SPACING[window.lima._.mod(startingTick, TICK_SPACING.length)];\n      startingTick += 1;\n    }\n    currY += lineHeight;\n\n    graph.lines = lines;\n    graph.tickVals = tickVals;\n    graph.aggregates = aggregates;\n    graph.height = endHeight + currY;\n    graph.lineHeight = lineHeight;\n  }\n}\n\nexport function getGroupingForestPlotData(graph) {\n  const { papers } = graph.metaanalysis;\n  const { formulaParams } = graph;\n  const moderatorParam = formulaParams[4];\n\n  let orFunc;\n  let wtFunc;\n  let lclFunc;\n  let uclFunc;\n\n  const headingOffset = 10;\n  const groupLineOffset = 0;\n  const lineHeight = 30;\n  const graphWidth = 200;\n  const startHeight = 80;\n  const groupStartHeight = 10;\n  const heightBetweenGroups = 50;\n  const endHeight = 65;\n  const minWtSize = 4;\n  const maxWtSize = 14;\n  const extraLineLen = -40;\n  const minDiamondWidth = 14;\n\n  if (graph.formulaName === 'forestPlotGroupGraph' && isColCompletelyDefined(graph)) {\n    orFunc = { formulaName: 'logOddsRatio', formulaParams: [formulaParams[0], formulaParams[2]] };\n    wtFunc = { formulaName: 'weight', formulaParams };\n    lclFunc = { formulaName: 'lowerConfidenceLimit', formulaParams };\n    uclFunc = { formulaName: 'upperConfidenceLimit', formulaParams };\n  } else\n  if (graph.formulaName === 'forestPlotGroupNumberGraph' && isColCompletelyDefined(graph)) {\n    orFunc = { formulaName: 'logOddsRatioNumber', formulaParams };\n    wtFunc = { formulaName: 'weightNumber', formulaParams };\n    lclFunc = { formulaName: 'lowerConfidenceLimitNumber', formulaParams };\n    uclFunc = { formulaName: 'upperConfidenceLimitNumber', formulaParams };\n  } else\n  if (graph.formulaName === 'forestPlotGroupPercentGraph' && isColCompletelyDefined(graph)) {\n    orFunc = { formulaName: 'logOddsRatioPercent', formulaParams: [formulaParams[0], formulaParams[2]] };\n    wtFunc = { formulaName: 'weightPercent', formulaParams };\n    lclFunc = { formulaName: 'lowerConfidenceLimitPercent', formulaParams };\n    uclFunc = { formulaName: 'upperConfidenceLimitPercent', formulaParams };\n  } else {\n    // this function does not handle this type of graph or the graph is not completely defined\n    return;\n  }\n\n  // get the data\n  orFunc.formula = window.lima.createFormulaString(orFunc);\n  wtFunc.formula = window.lima.createFormulaString(wtFunc);\n  lclFunc.formula = window.lima.createFormulaString(lclFunc);\n  uclFunc.formula = window.lima.createFormulaString(uclFunc);\n  orFunc.formulaObj = window.lima.getFormulaObject(orFunc.formulaName);\n  wtFunc.formulaObj = window.lima.getFormulaObject(wtFunc.formulaName);\n  lclFunc.formulaObj = window.lima.getFormulaObject(lclFunc.formulaName);\n  uclFunc.formulaObj = window.lima.getFormulaObject(uclFunc.formulaName);\n\n  const lines = [];\n  const groups = [];\n\n  for (const paper of papers) {\n    for (const exp of paper.experiments) {\n      if (!exp.excluded) {\n        const line = {};\n        line.title = paper.title || 'new paper';\n        if (paper.experiments.length > 1) {\n          let expTitle = exp.title || 'new experiment';\n          if (expTitle.match(/^\\d+$/)) expTitle = `Exp. ${expTitle}`;\n          line.title += ` (${expTitle})`;\n        }\n        line.or = getDatumValue(orFunc, exp);\n        line.wt = getDatumValue(wtFunc, exp);\n        line.lcl = getDatumValue(lclFunc, exp);\n        line.ucl = getDatumValue(uclFunc, exp);\n        line.group = getDatumValue(moderatorParam, exp);\n        if (line.group != null && line.group !== '' && groups.indexOf(line.group) === -1) {\n          groups.push(line.group);\n        }\n\n        // if any of the values is NaN or Infinity, disregard this experiment\n        if (\n          Number.isNaN(line.or * 0)\n        || Number.isNaN(line.lcl * 0)\n        || Number.isNaN(line.ucl * 0)\n        || Number.isNaN(line.wt * 0)\n        || line.or == null\n        || line.lcl == null\n        || line.ucl == null\n        || line.wt == null\n        ) {\n          delete line.or;\n          delete line.lcl;\n          delete line.ucl;\n          delete line.wt;\n        }\n\n        lines.push(line);\n      }\n    }\n  }\n  // add indication to the graph when there is no data\n  if (lines.length === 0) {\n    const noDataLine = {\n      title: 'No data',\n      group: 'No data',\n    };\n    groups.push(noDataLine.group);\n    lines.push(noDataLine);\n  }\n\n  // graphIndex : pas compris\n\n  groups.sort();\n\n  for (const group of groups) {\n    let sumOfWtg = 0;\n    for (const line of lines) {\n      if (line.group === group) {\n        sumOfWtg += line.wt;\n      }\n    }\n    for (const line of lines) {\n      if (line.group === group) {\n        line.wtg = (line.wt / sumOfWtg) * 1000;\n      }\n    }\n  }\n\n  const dataGroups = [];\n  for (const group of groups) {\n    const dataGroup = {};\n    dataGroup.lines = lines.filter((exp) => exp.group === group);\n    dataGroups.push(dataGroup);\n  }\n\n  const perGroup = {};\n  for (const dataGroup of dataGroups) {\n    const { group } = dataGroup.lines[0];\n    perGroup[group] = {};\n    perGroup[group].wt = dataGroup.lines.reduce((acc, line) => (\n      line.wt !== null ? acc + line.wt : acc\n    ), 0);\n    if (perGroup[group].wt === 0) perGroup[group].wt = 1;\n    perGroup[group].or = dataGroup.lines.reduce((acc, line) => (\n      line.wt !== null ? acc + line.or * line.wt : acc\n    ), 0) / perGroup[group].wt;\n  }\n  const orAggrFunc = {\n    formulaName: 'weightedMeanAggr',\n    formulaParams: [orFunc, wtFunc],\n  };\n  const lclAggrFunc = {\n    formulaName: 'lowerConfidenceLimitAggr',\n    formulaParams: [orFunc, wtFunc],\n  };\n  const uclAggrFunc = {\n    formulaName: 'upperConfidenceLimitAggr',\n    formulaParams: [orFunc, wtFunc],\n  };\n\n  orAggrFunc.formula = window.lima.createFormulaString(orAggrFunc);\n  lclAggrFunc.formula = window.lima.createFormulaString(lclAggrFunc);\n  uclAggrFunc.formula = window.lima.createFormulaString(uclAggrFunc);\n  orAggrFunc.formulaObj = window.lima.getFormulaObject(orAggrFunc.formulaName);\n  lclAggrFunc.formulaObj = window.lima.getFormulaObject(lclAggrFunc.formulaName);\n  uclAggrFunc.formulaObj = window.lima.getFormulaObject(uclAggrFunc.formulaName);\n\n  const aggregates = {\n    or: getAggregateDatumValue(orAggrFunc, papers),\n    lcl: getAggregateDatumValue(lclAggrFunc, papers),\n    ucl: getAggregateDatumValue(uclAggrFunc, papers),\n  };\n\n  if (Number.isNaN(aggregates.or * 0)\n      || Number.isNaN(aggregates.lcl * 0)\n      || Number.isNaN(aggregates.ucl * 0)\n  ) {\n    aggregates.lcl = 0;\n    aggregates.ucl = 0;\n  }\n\n  // compute\n  //   sum of wt\n  //   min and max of wt\n  //   min of lcl and aggr lcl\n  //   max of ucl and aggr ucl\n  let sumOfWt = 0;\n  let minWt = Infinity;\n  let maxWt = -Infinity;\n  let minLcl = aggregates.lcl;\n  let maxUcl = aggregates.ucl;\n\n  if (Number.isNaN(minLcl)) minLcl = 0;\n  if (Number.isNaN(maxUcl)) maxUcl = 0;\n  for (const line of lines) {\n    if (line.or !== null) {\n      sumOfWt += line.wt;\n      if (line.wt < minWt) minWt = line.wt;\n      if (line.wt > maxWt) maxWt = line.wt;\n      if (line.lcl < minLcl) minLcl = line.lcl;\n      if (line.ucl > maxUcl) maxUcl = line.ucl;\n    }\n  }\n\n  if (minLcl < -10) minLcl = -10;\n  if (maxUcl > 10) maxUcl = 10;\n\n  if (minWt === Infinity) {\n    minWt = 1;\n    maxWt = 1;\n  }\n  if (sumOfWt === 0) sumOfWt = 1;\n\n  let TICK_SPACING;\n  // select tick spacing based on a rough estimate of how many ticks we'll need anyway\n  const clSpread = (maxUcl - minLcl) / Math.LN10; // how many orders of magnitude we cover\n  if (clSpread > 3) TICK_SPACING = [100];\n  else if (clSpread > 1.3) TICK_SPACING = [10];\n  else TICK_SPACING = [2, 2.5, 2]; // ticks at 1, 2, 5, 10, 20, 50, 100...\n\n  // adjust minimum and maximum around decimal non-logarithmic values\n  let newBound = 1;\n  let tickNo = 0;\n  while (Math.log(newBound) > minLcl) {\n    tickNo -= 1;\n    newBound /= TICK_SPACING[window.lima._.mod(tickNo, TICK_SPACING.length)];\n    // JS % can be negative\n  }\n  minLcl = Math.log(newBound) - 0.1;\n\n  let startingTickVal = newBound;\n  let startingTick = tickNo;\n\n  newBound = 1;\n  tickNo = 0;\n  while (Math.log(newBound) < maxUcl) {\n    newBound *= TICK_SPACING[window.lima._.mod(tickNo, TICK_SPACING.length)];\n    tickNo += 1;\n  }\n  maxUcl = Math.log(newBound) + 0.1;\n\n  const xRatio = (1 / (maxUcl - minLcl)) * graphWidth;\n\n  function getX(val) {\n    return (val - minLcl) * xRatio;\n  }\n\n  const MIN_WT_SPREAD = 2.5;\n  if (maxWt / minWt < MIN_WT_SPREAD) {\n    minWt = (maxWt + minWt) / 2 / Math.sqrt(MIN_WT_SPREAD);\n    maxWt = minWt * MIN_WT_SPREAD;\n  }\n\n  maxWt = Math.sqrt(maxWt);\n  minWt = Math.sqrt(minWt);\n  const wtRatio = (1 / (maxWt - minWt)) * (maxWtSize - minWtSize);\n\n  let currY = startHeight;\n  let currGY = groupStartHeight;\n  let hasInvalid = false;\n\n  let i = 0;\n  for (const group of groups) {\n    const groupAggregates = {\n      or: 0,\n      lcl: 0,\n      ucl: 0,\n      wt: 0,\n    };\n\n    let groupMembers = 0; // counter\n    let groupHasInvalid = false;\n    currGY = groupStartHeight;\n\n    for (const line of lines) {\n      if (line.group === group) {\n        if (line.or !== null) {\n          groupMembers += 1;\n          groupAggregates.or += line.or;\n          groupAggregates.lcl += line.lcl;\n          groupAggregates.ucl += line.ucl;\n          groupAggregates.wt += Math.round((line.wt / sumOfWt) * 1000) / 10;\n        } else {\n          hasInvalid = true;\n          groupHasInvalid = true;\n        }\n        line.currGY = currGY;\n        currGY += lineHeight;\n      }\n    }\n    // if stat != wt, then divide the groupAggregate sums by the number of valid lines in the group.\n    for (const stat in groupAggregates) {\n      if (stat !== 'wt') {\n        groupAggregates[stat] /= groupMembers;\n      } else {\n      // avoid having too much decimals\n        groupAggregates[stat] = groupAggregates[stat].toFixed(1);\n      }\n    }\n\n    // put group summary into the plot\n    if (!groupHasInvalid) {\n      let lclX = getX(groupAggregates.lcl);\n      let uclX = getX(groupAggregates.ucl);\n      const orX = getX(groupAggregates.or);\n      if ((uclX - lclX) < minDiamondWidth) {\n        const ratio = (uclX - lclX) / minDiamondWidth;\n        lclX = orX + (lclX - orX) / ratio;\n        uclX = orX + (uclX - orX) / ratio;\n      }\n      const confidenceInterval = `${lclX},0 ${orX},-10 ${uclX},0 ${orX},10`;\n      dataGroups[i].confidenceInterval = confidenceInterval;\n      dataGroups[i].groupAggregates = groupAggregates;\n      dataGroups[i].currGY = currGY;\n      currGY += lineHeight;\n    }\n    dataGroups[i].currY = currY;\n    currY += currGY + heightBetweenGroups;\n    i += 1;\n  }\n\n  // put axes into the plot\n  const tickVals = [];\n  let tickVal;\n\n  while ((tickVal = Math.log(startingTickVal)) < maxUcl) {\n    tickVals.push([tickVal, startingTickVal]);\n    startingTickVal *= TICK_SPACING[window.lima._.mod(startingTick, TICK_SPACING.length)];\n    startingTick += 1;\n  }\n\n  const yAxis = currY;\n  // put summary into the plot\n  if (!Number.isNaN(aggregates.or * 0) && !hasInvalid) {\n    currY += 2 * lineHeight;\n    let lclX = getX(aggregates.lcl);\n    let uclX = getX(aggregates.ucl);\n    const orX = getX(aggregates.or);\n    if ((uclX - lclX) < minDiamondWidth) {\n      const ratio = (uclX - lclX) / minDiamondWidth;\n      lclX = orX + (lclX - orX) / ratio;\n      uclX = orX + (uclX - orX) / ratio;\n    }\n\n    const confidenceInterval = `${lclX},0 ${orX},-10 ${uclX},0 ${orX},10`;\n    graph.confidenceInterval = confidenceInterval;\n  }\n\n  const height = endHeight + currY;\n  graph.height = height;\n  graph.yAxis = yAxis;\n  graph.groupLineOffset = groupLineOffset;\n  graph.headingOffset = headingOffset;\n  graph.tickVals = tickVals;\n  graph.groups = groups;\n  graph.lines = lines;\n  graph.dataGroups = dataGroups;\n  graph.aggregates = aggregates;\n  graph.minWtSize = minWtSize;\n  graph.minWt = minWt;\n  graph.wtRatio = wtRatio;\n  graph.xRatio = xRatio;\n  graph.minLcl = minLcl;\n  graph.currY = currY;\n  graph.extraLineLen = extraLineLen;\n  graph.lineHeight = lineHeight;\n\n  // todo set plot widths based on maximum text sizes\n}\n\nexport function getGrapeChartData(graph) {\n  const { papers } = graph.metaanalysis;\n  const { formulaParams } = graph;\n  const moderatorParam = formulaParams[4];\n  const dataParams = formulaParams.slice(0, 4);\n\n  let orFunc;\n  let wtFunc;\n  let lclFunc;\n  let uclFunc;\n\n  const height = 600;\n  const zeroGroupsWidth = 70;\n  const graphHeight = 500;\n  const minGrapeSize = 7;\n  const maxGrapeSize = 14;\n  const firstGroup = 210;\n  const groupSpacing = 300;\n  const grapeSpacing = 1.5;\n  const tooltipPadding = 20;\n  const tooltipMinWidth = 150;\n  const nbGroups = 7;\n\n  if (graph.formulaName === 'grapeChartGraph' && isColCompletelyDefined(graph)) {\n    orFunc = { formulaName: 'logOddsRatio', formulaParams: [formulaParams[0], formulaParams[2]] };\n    wtFunc = { formulaName: 'weight', formulaParams };\n    lclFunc = { formulaName: 'lowerConfidenceLimit', formulaParams };\n    uclFunc = { formulaName: 'upperConfidenceLimit', formulaParams };\n  } else\n  if (graph.formulaName === 'grapeChartNumberGraph' && isColCompletelyDefined(graph)) {\n    orFunc = { formulaName: 'logOddsRatioNumber', formulaParams: dataParams };\n    wtFunc = { formulaName: 'weightNumber', formulaParams: dataParams };\n    lclFunc = { formulaName: 'lowerConfidenceLimitNumber', formulaParams: dataParams };\n    uclFunc = { formulaName: 'upperConfidenceLimitNumber', formulaParams: dataParams };\n  } else\n  if (graph.formulaName === 'grapeChartPercentGraph' && isColCompletelyDefined(graph)) {\n    orFunc = { formulaName: 'logOddsRatioPercent', formulaParams: [dataParams[0], dataParams[2]] };\n    wtFunc = { formulaName: 'weightPercent', formulaParams: dataParams };\n    lclFunc = { formulaName: 'lowerConfidenceLimitPercent', formulaParams: dataParams };\n    uclFunc = { formulaName: 'upperConfidenceLimitPercent', formulaParams: dataParams };\n  } else {\n    // this function does not handle this type of graph or the graph is not completely defined\n    return;\n  }\n\n  orFunc.formula = window.lima.createFormulaString(orFunc);\n  wtFunc.formula = window.lima.createFormulaString(wtFunc);\n  lclFunc.formula = window.lima.createFormulaString(lclFunc);\n  uclFunc.formula = window.lima.createFormulaString(uclFunc);\n  orFunc.formulaObj = window.lima.getFormulaObject(orFunc.formulaName);\n  wtFunc.formulaObj = window.lima.getFormulaObject(wtFunc.formulaName);\n  lclFunc.formulaObj = window.lima.getFormulaObject(lclFunc.formulaName);\n  uclFunc.formulaObj = window.lima.getFormulaObject(uclFunc.formulaName);\n\n  const data = [];\n  const groups = [];\n\n  for (const paper of papers) {\n    for (const exp of paper.experiments) {\n      if (!exp.excluded) {\n        const line = {};\n        line.paper = paper.title || 'new paper';\n        line.exp = exp.title || 'new experiment';\n        if (line.exp.match(/^\\d+$/)) {\n          line.exp = `Exp. ${line.exp}`;\n        }\n        line.or = getDatumValue(orFunc, exp);\n        line.wt = getDatumValue(wtFunc, exp);\n        line.lcl = getDatumValue(lclFunc, exp);\n        line.ucl = getDatumValue(uclFunc, exp);\n        line.group = getDatumValue(moderatorParam, exp);\n        if (line.group != null && line.group !== '' && groups.indexOf(line.group) === -1) {\n          groups.push(line.group);\n        }\n        if (Number.isNaN(line.or * 0)\n            || Number.isNaN(line.lcl * 0)\n            || Number.isNaN(line.ucl * 0)\n            || Number.isNaN(line.wt * 0)\n            || line.or == null\n            || line.lcl == null\n            || line.ucl == null\n            || line.wt == null) {\n          delete line.or;\n          delete line.lcl;\n          delete line.ucl;\n          delete line.wt;\n        }\n        data.push(line);\n      }\n    }\n  }\n  if (data.length === 0) {\n    const noDataLine = {\n      paper: 'No paper',\n      exp: 'No experiment',\n      group: 'No data',\n    };\n    groups.push(noDataLine.group);\n    data.push(noDataLine);\n  }\n\n  groups.sort(); // alphabetically\n\n  const dataGroups = [];\n  for (const group of groups) {\n    const dataGroup = {};\n    dataGroup.data = data.filter((exp) => exp.group === group);\n    dataGroups.push(dataGroup);\n  }\n\n  const perGroup = {};\n  for (const dataGroup of dataGroups) {\n    const { group } = dataGroup.data[0];\n    perGroup[group] = {};\n    perGroup[group].wt = dataGroup.data.reduce((acc, line) => (\n      line.wt != null ? acc + line.wt : acc\n    ), 0);\n    if (perGroup[group].wt === 0) perGroup[group].wt = 1;\n    perGroup[group].or = dataGroup.data.reduce((acc, line) => (\n      line.wt !== null ? acc + line.or * line.wt : acc\n    ), 0) / perGroup[group].wt;\n  }\n\n  let minWt = Infinity;\n  let maxWt = -Infinity;\n  let minOr = Infinity;\n  let maxOr = -Infinity;\n\n  for (const exp of data) {\n    if (exp.or !== null) {\n      if (exp.wt < minWt) minWt = exp.wt;\n      if (exp.wt > maxWt) maxWt = exp.wt;\n      if (exp.or < minOr) minOr = exp.or;\n      if (exp.or > maxOr) maxOr = exp.or;\n    }\n  }\n\n  if (minOr < -10) minOr = -10;\n  if (maxOr > 10) maxOr = 10;\n  if (minOr === Infinity) {\n    minOr = 0;\n    maxOr = 0;\n  }\n  if (minWt === Infinity) {\n    minWt = 1;\n    maxWt = 1;\n  }\n\n  let TICK_SPACING;\n  // select tick spacing based on a rough estimate of how many ticks we'll need anyway\n  const clSpread = (maxOr - minOr) / Math.LN10; // how many orders of magnitude we cover\n  if (clSpread > 5) TICK_SPACING = [100];\n  else if (clSpread > 2) TICK_SPACING = [10];\n  else TICK_SPACING = [2, 2.5, 2]; // ticks at 1, 2, 5, 10, 20, 50, 100...\n  // adjust minimum and maximum around decimal non-logarithmic values\n  let newBound = 1;\n  let tickNo = 0;\n  while (Math.log(newBound) > minOr) {\n    tickNo -= 1;\n    newBound /= TICK_SPACING[window.lima._.mod(tickNo, TICK_SPACING.length)];\n    // JS % can be negative\n  }\n  minOr = Math.log(newBound) - 0.1;\n\n  let startingTickVal = newBound;\n  let startingTick = tickNo;\n\n  newBound = 1;\n  tickNo = 0;\n  while (Math.log(newBound) < maxOr) {\n    newBound *= TICK_SPACING[window.lima._.mod(tickNo, TICK_SPACING.length)];\n    tickNo += 1;\n  }\n  maxOr = Math.log(newBound) + 0.1;\n  const midOr = (minOr + maxOr) / 2;\n\n  const yRatio = (1 / (maxOr - minOr)) * graphHeight;\n  function getY(logVal) {\n    if (logVal == null) return 0;\n    return -(logVal - minOr) * yRatio;\n  }\n\n  function isTopHalf(logVal) {\n    return logVal > midOr;\n  }\n\n  const MIN_WT_SPREAD = 2.5;\n  if (maxWt / minWt < MIN_WT_SPREAD) {\n    minWt = (maxWt + minWt) / 2 / Math.sqrt(MIN_WT_SPREAD);\n    maxWt = minWt * MIN_WT_SPREAD;\n  }\n\n  // minWt = 0;\n  // todo we can uncomment this to make all weights relative to only the maximum weight\n  // square root the weights because we're using them as\n  // lengths of the side of a square whose area should correspond to the weight\n  maxWt = Math.sqrt(maxWt);\n  minWt = Math.sqrt(minWt);\n  const wtRatio = (1 / (maxWt - minWt)) * (maxGrapeSize - minGrapeSize);\n\n  function getGrapeRadius(wt) {\n    if (wt == null) return minGrapeSize;\n    return (Math.sqrt(wt) - minWt) * wtRatio + minGrapeSize;\n  }\n\n  let currentGroup = -1;\n  const numberOfColours = +nbGroups;\n\n  for (const group of groups) {\n    currentGroup += 1;\n    const dataGroup = dataGroups[currentGroup];\n\n    if (currentGroup === 0) {\n      dataGroup.withLegend = true;\n    }\n    if (currentGroup === groups.length - 1) {\n      dataGroup.withPosButton = true;\n    }\n    resetPositioning();\n    let index = 0;\n    for (const exp of dataGroup.data) {\n      exp.index = index;\n      precomputePosition(exp.index, getY(exp.or), getGrapeRadius(exp.wt) + grapeSpacing);\n      index += 1;\n    }\n    finalizePositioning();\n\n    dataGroup.guidelineY = getY(perGroup[group].or);\n\n    const texts = [];\n\n    for (const exp of dataGroup.data) {\n      const text = {};\n      text.paper = exp.paper;\n      text.exp = exp.exp;\n      if (exp.or != null) {\n        text.or = Math.exp(exp.or).toFixed(2);\n        text.wt = `${((exp.wt * 100) / perGroup[group].wt).toFixed(2)}%`;\n        text.ci = `${Math.exp(exp.lcl).toFixed(2)}, ${Math.exp(exp.ucl).toFixed(2)}`;\n      } else {\n        dataGroup.invalid = true;\n      }\n      if (isTopHalf(exp.or)) {\n        exp.isTopHalf = true;\n      }\n\n      let boxWidth = +tooltipMinWidth;\n      for (const txt of texts) {\n        try {\n          const w = txt.getBBox().width;\n          boxWidth = Math.max(boxWidth, w);\n        // eslint-disable-next-line no-empty\n        } catch (e) {}\n      }\n      exp.text = text;\n      exp.radius = getGrapeRadius(exp.wt);\n      exp.grapeX = getPosition(exp.index);\n      exp.grapeY = getY(exp.or);\n      exp.boxWidth = boxWidth;\n    }\n  }\n  // put axes into the plot\n  const tickVals = [];\n  let tickVal;\n\n  while ((tickVal = Math.log(startingTickVal)) < maxOr) {\n    tickVals.push([tickVal, startingTickVal, getY(tickVal)]);\n    startingTickVal *= TICK_SPACING[window.lima._.mod(startingTick, TICK_SPACING.length)];\n    startingTick += 1;\n  }\n  let positionedGrapes;\n\n  graph.width = zeroGroupsWidth + groups.length * groupSpacing;\n  graph.height = height;\n  graph.viewBox = `0 0 ${graph.width} ${height}`;\n  graph.groups = groups;\n  graph.dataGroups = dataGroups;\n  graph.firstGroup = firstGroup;\n  graph.groupSpacing = groupSpacing;\n  graph.numberOfColours = numberOfColours;\n  graph.tooltipPadding = tooltipPadding;\n  graph.tickVals = tickVals;\n  function resetPositioning() {\n    positionedGrapes = {\n      pre: [],\n      sorted: [],\n      post: [],\n      ybounds: new window.lima._.Bounds(), // this helps us center blocks of grapes\n    };\n  }\n\n  function precomputePosition(index, y, r) {\n    positionedGrapes.ybounds.add(y - r, y + r);\n    positionedGrapes.sorted[index] = { index, y, r };\n    positionedGrapes.pre[index] = positionedGrapes.sorted[index];\n  }\n\n  function finalizePositioning() {\n    // position big grapes first so they tend to be more central\n    const sortingStrategy = (a, b) => b.r - a.r;\n    positionedGrapes.sorted.sort(sortingStrategy);\n\n    // compute X coordinates\n    positionedGrapes.sorted.forEach((g1, index) => {\n      const xbounds = new window.lima._.Bounds();\n      positionedGrapes.post.forEach((g2) => {\n        // check that the current grape is close enough to g on the y axis that they can touch\n        if (Math.abs(g1.y - g2.y) < (g1.r + g2.r)) {\n          // presence of g means current grape cannot be at g.x  delta\n          const delta = Math.sqrt((g1.r + g2.r) * (g1.r + g2.r) - (g1.y - g2.y) * (g1.y - g2.y));\n          const min = g2.x - delta;\n          const max = g2.x + delta;\n\n          xbounds.add(min, max);\n        }\n      });\n\n      // choose the nearest available x to 0\n      g1.x = xbounds.getNearestOutsideValue(0);\n\n      // todo? if 0, maybe keep left- and right-slack so we can move things around a bit afterwards\n\n      positionedGrapes.post[index] = g1;\n    });\n\n    // center connecting groups\n    // use ybounds to group grapes in buckets so we can center them together\n    const buckets = [];\n    positionedGrapes.pre.forEach((g) => {\n      const bucketNo = positionedGrapes.ybounds.indexOf(g.y);\n      if (bucketNo === -1) throw new Error('assertion failed: grape not in ybounds'); // should never happen\n      if (!buckets[bucketNo]) buckets[bucketNo] = [];\n      buckets[bucketNo].push(g);\n    });\n\n    buckets.forEach((bucket) => {\n      let min = Infinity;\n      let max = -Infinity;\n      bucket.forEach((g) => {\n        min = Math.min(min, g.x - g.r);\n        max = Math.max(max, g.x + g.r);\n      });\n\n      if (min < Infinity && Math.abs(min + max) > 1) {\n        // got a connecting group that wants to be moved, move it to center\n        const dx = (max + min) / 2;\n        bucket.forEach((g) => { g.x -= dx; });\n      }\n    });\n  }\n\n  function getPosition(i) {\n    return positionedGrapes.pre[i].x;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]},{"filePath":"/Users/NATFINEST/Documents/GitHub/lima-main/webpages-react/tools/modifyColumns.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-spaced-func","replacedBy":["func-call-spacing"]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]}]}]